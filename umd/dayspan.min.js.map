{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///dayspan.min.js","webpack:///webpack/bootstrap e076d78c7afd9cb5feab","webpack:///external {\"commonjs\":\"moment\",\"commonjs2\":\"moment\",\"amd\":\"moment\",\"root\":\"moment\"}","webpack:///./src/Operation.ts","webpack:///./src/Functions.ts","webpack:///./src/Units.ts","webpack:///./src/Constants.ts","webpack:///./src/DaySpan.ts","webpack:///./src/Identifier.ts","webpack:///./src/Suffix.ts","webpack:///./src/Iterator.ts","webpack:///./src/Pattern.ts","webpack:///./src/ScheduleModifier.ts","webpack:///./src/Schedule.ts","webpack:///./src/Event.ts","webpack:///./src/Time.ts","webpack:///./src/Parse.ts","webpack:///./src/Day.ts","webpack:///./src/CalendarDay.ts","webpack:///./src/CalendarEvent.ts","webpack:///./src/Calendar.ts","webpack:///./src/Month.ts","webpack:///./src/Weekday.ts","webpack:///./src/Sort.ts"],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_0__","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","__webpack_exports__","operate","value","op","absolute","isFinite","Math","abs","Op","NONE","FLOOR","floor","CEIL","ceil","ROUND","round","TRUNCATE","DOWN","UP","Functions","isArray","input","Array","isArrayEquals","x","y","length","isString","isNumber","isObject","isDefined","isValue","isFrequencyValueEvery","every","isFrequencyValueOneOf","coalesce","a","b","extend","target","from","prop","pad","padding","before","padNumber","first","substring","Units","DaySpan__a","Constants","MILLIS_IN_SECOND","MILLIS_IN_MINUTE","MILLIS_IN_HOUR","MILLIS_IN_DAY","MILLIS_IN_WEEK","MINUTES_IN_HOUR","MINUTES_IN_DAY","DAYS_IN_WEEK","MONTHS_IN_YEAR","HOURS_IN_DAY","MONTH_MIN","MONTH_MAX","DAY_MIN","DAY_MAX","HOUR_MIN","HOUR_MAX","MINUTE_MIN","MINUTE_MAX","SECOND_MIN","SECOND_MAX","MILLIS_MIN","MILLIS_MAX","WEEKDAY_MIN","WEEKDAY_MAX","DURATION_DEFAULT","DURATION_DEFAULT_UNIT_ALL","DURATION_DEFAULT_UNIT_TIMES","DURATION_DEFAULT_UNIT","all","DURATION_TO_MILLIS","minute","minutes","hour","hours","day","days","week","weeks","month","months","MAX_EVENTS_PER_DAY","WEEK_OF_MONTH_MINIMUM_WEEKDAY","DaySpan_DaySpan","DaySpan","start","end","time","contains","compareTo","matchesDay","sameDay","matchesWeek","sameWeek","matchesMonth","sameMonth","matchesYear","sameYear","millis","millisBetween","seconds","secondsBetween","minutesBetween","hoursBetween","daysBetween","weeksBetween","monthsBetween","years","yearsBetween","startDelta","relativeTo","endDelta","getBounds","dayHeight","dayWidth","columnOffset","columnWidth","clip","offsetX","offsetY","startRaw","endRaw","max","min","left","right","width","top","bottom","height","summary","type","dayOfWeek","short","repeat","contextual","delimiter","formats","SUMMARY_FORMATS","today","Day_Day","showStartYear","showEndYear","format","intersects","span","intersection","isAfter","union","point","DAY","year","WEEK","MONTH","YEAR","__extends","extendStatics","setPrototypeOf","__proto__","__","constructor","create","Identifier_Identifier","Identifier","is","id","getLength","compute","values","_i","arguments","scales","getScales","total","decompute","parseInt","curr","next","mod","push","find","Time","Day","Week","Month","Year","outer","inner","outerString","Quarter","Identifier_IdentifierTime","_super","IdentifierTime","apply","SCALES","LENGTH","dayOfMonth","obj","build","endInclusive","endOfHour","describe","DESCRIBE_FORMAT_SHORT","DESCRIBE_FORMAT_LONG","matches","timeIdentifier","Identifier_IdentifierDay","IdentifierDay","dayIdentifier","Identifier_IdentifierWeek","IdentifierWeek","withWeek","endOfWeek","weekIdentifier","Identifier_IdentifierMonth","IdentifierMonth","endOfMonth","monthIdentifier","Identifier_IdentifierQuarter","IdentifierQuarter","quarter","relativeMonths","quarterIdentifier","Identifier_IdentifierYear","IdentifierYear","endOfYear","IteratorAction","Suffix","_CACHE","_CACHE_SIZE","determine","MAP","prepend","suffix","Calendar__a","Iterator_Iterator","Iterator","source","result","clone","act","item","action","Continue","replaceWith","callback","stop","Stop","replace","Replace","remove","Remove","isEmpty","filter","empty","iterate","iterator","count","list","out","getKey","key","take","amount","_this","prev","skip","skipped","append","iterators","join","concat","purge","reverse","items","modifies","actions","replaces","index_1","reduce","initial","reducer","reduced","prevItem","map","mapper","unmapper","nextItem","undefined","withResult","getResult","forArray","splice","forObject","parent","iterators_1","child","childIterator","ScheduleModifier_ScheduleModifier","ScheduleModifier","clear","otherwise","lookAtTime","getIdentifier","getAll","move","fromType","to","toType","fromIdentifier","toIdentifier","moveTime","fromTime","toTime","moveIds","_a","sameTime","moved","moveIds_1","newStart","withTime","newId","removeTime","removed","set","unset","rawId","asNumber","validAsNumber","query","identifiers","spans","describeMap","__WEBPACK_IMPORTED_MODULE_10_moment__","Schedule_Schedule","Schedule","exclude","include","cancel","meta","parseMeta","Parse_Parse","schedule","toInput","times","isFullDay","updateDurationInDays","lastTime","toMilliseconds","duration","durationUnit","durationInDays","updateChecks","checks","givenFrequency","weekOfYear","fullWeekOfYear","weekspanOfYear","lastFullWeekOfYear","lastWeekspanOfYear","weekOfMonth","weekspanOfMonth","fullWeekOfMonth","lastWeekspanOfMonth","lastFullWeekOfMonth","lastDayOfMonth","dayOfYear","matchesSpan","isSameOrAfter","isBefore","matchesRange","isExcluded","isIncluded","isCancelled","getMeta","getMetas","setFullDay","fullDay","defaultTime","adjustDefinedSpan","addSpan","single","getSingleEventSpan","getFullSpan","add","getTimeSpan","isFullyExcluded","check","hasIncludedTime","iterateIncludeTimes","nextDay","includeDay","lookAhead","iterateDaycast","nextDays","prevDay","lookBack","prevDays","lookup","iterated","iterateSpans","covers","current","lookBehind","timeIterator","matchesTime","sameMinute","coversDay","coversTime","setFrequency","frequency","setExcluded","excluded","identifierType","setCancelled","cancelled","removeInclude","found","moveSingleEvent","moveInstance","takeTime","isSingleEvent","asTime","startOfYear","isSingleYear","isSingleDayOfYear","isSingleMonth","isSingleDayOfMonth","isSingleWeekOfMonth","isSingleDayOfWeek","isSingleWeekOfYear","isSingleFrequency","forecast","around","daysAfter","daysBefore","lookAround","tuplesForDay","tuples","last","offset","matchAgainst","isIncludedTime","getSpan","returnDays","returnTimes","timeFormat","alwaysDuration","defaultUnit","exclusions","v","inclusions","cancels","hasMeta","toString","thing","includeRange","includeTimes","includeDuration","includeExcludes","includeIncludes","includeCancels","describeRule","CACHE","describeArray","excludes","includes","unit","everyOffset","the","on","required","valueEvery","valueOne","array","forDay","parse","forTime","forSpan","isDay","isHour","Event","data","visible","Time_Time","second","millisecond","formatterEntries","FORMATTERS","handled","k","entry","part","size","formatter","charAt","matchesHour","matchesMinute","matchesSecond","parsed","valid","toObject","fromString","REGEX","exec","h","SSS","t","HH","hh","kk","mm","ss","SS","A","H","S","Parse","given","every_1","offset_1","map_1","unix","fromArray","fromObject","input_1","timeInput","sort","modifier","input_2","identifier","checks_1","event","parseData","cron","pattern","__WEBPACK_IMPORTED_MODULE_5_moment__","date","valueOf","getLastDayOfMonth","getWeekOfYear","getWeekspanOfYear","getFullWeekOfYear","getLastWeekspanOfYear","getLastFullWeekOfYear","getWeekOfMonth","getWeekspanOfMonth","getFullWeekOfMonth","getLastWeekspanOfMonth","getLastFullWeekOfMonth","sameQuarter","sameHour","precision","isSameOrBefore","diff","isBetween","inclusive","mutate","mutator","toMoment","relative","relativeDays","withDayOfMonth","withDayOfWeek","withDayOfYear","withMonth","prevMonth","nextMonth","relativeWeek","withWeekOfYear","withFullWeekOfYear","withWeekspanOfYear","withWeekOfMonth","withWeekspanOfMonth","withFullWeekOfMonth","relativeWeeks","prevWeek","nextWeek","withYear","relativeYears","prevYear","nextYear","withHour","relativeHours","prevHour","nextHour","withTimes","startOf","isStart","endOf","isEnd","startOfHour","isStartOfHour","isEndOfHour","startOfWeek","isStartOfWeek","isEndOfWeek","startOfMonth","isStartOfMonth","isEndOfMonth","daysInMonth","isStartOfYear","isEndOfYear","daysInYear","weeksInYear","utc","keepLocalTime","toDate","toArray","toJSON","toISOString","keepOffset","isDST","isLeapYear","now","tomorrow","fromMoment","moment","isValid","unixSeconds","fromFormat","fromDate","fromDayIdentifier","lastOfYear","firstOfYear","weeksMax","lastWeek","dom","dow","sundayDate","CalendarDay___extends","CalendarDay_CalendarDay","CalendarDay","currentDay","currentWeek","currentMonth","currentYear","currentOffset","selectedDay","selectedWeek","selectedMonth","selectedYear","inCalendar","events","iterateEvents","updateCurrent","updateSelected","selected","clearSelected","CalendarEvent_CalendarEvent","CalendarEvent","actualDay","row","col","colWidth","starting","isPoint","ending","getTimeBounds","Calendar_Calendar","Calendar","moveStart","moveEnd","fill","minimumSize","repeatCovers","listTimes","eventsOutside","updateRows","updateColumns","eventSorter","selection","filled","refresh","typeChange","sizeChange","focus_1","otherwiseFocus","prefer","preferToday","TYPES","getStart","getEnd","focus_2","setEvents","delayRefresh","withMinimumSize","withRepeatCovers","refreshEvents","withListTimes","withEventsOutside","withUpdateRows","refreshRows","withUpdateColumns","refreshColumns","split","by","calendar","resetDays","refreshCurrent","refreshSelection","refreshVisible","resetFilled","e","iterateDays","eventsForDay","eventToRow","onlyFullDay","used","event_1","rowIndex","_b","_c","event_2","packEvents","columns","columnsLength","forEach","colIndex","colSpan","expandEvent","collidesWith","e1","e2","j","lastEventEnding","events_1","event_3","placed","getDay","dayCount","getTimes","sorter","entries","entryIndex","eventId","timeIndex","findEvent","event_4","removeEvents","events_2","event_5","removeEvent","indexOf","addEvent","allowDuplicates","addEvents","events_3","event_6","parsedEvents","select","unselect","jump","plain","plainData","plainMeta","event_7","plainEvent","fromInput","forType","focus","defaultInput","JANUARY","FEBRUARY","MARCH","APRIL","MAY","JUNE","JULY","AUGUST","SEPTEMBER","OCTOBER","NOVEMBER","DECEMBER","LIST","Weekday","SUNDAY","MONDAY","TUESDAY","WEDNESDAY","THURSDAY","FRIDAY","SATURDAY","ENDS","Pattern_Pattern","Pattern","listed","rules","applyGeneric","removeFrequency","PROPS","rule","isMatch","exactlyWith","isMatchGeneric","getFrequency","exactly","ruleOffset","withName","PatternMap","findMatch","listedOnly","Patterns_1","Patterns","Pattern__i","Patterns_2","Pattern_pattern","Sorts","Start","End","FullDay","Duration","Desc","Alphabetical","getString","as","bs","localeCompare","Ordered","getOrder","List","sorters","sorters_1","compare"],"mappings":"CAAA,SAAAA,EAAAC,GACA,gBAAAC,UAAA,gBAAAC,QACAA,OAAAD,QAAAD,EAAAG,QAAA,WACA,kBAAAC,gBAAAC,IACAD,OAAA,gBAAAJ,GACA,gBAAAC,SACAA,QAAA,GAAAD,EAAAG,QAAA,WAEAJ,EAAA,GAAAC,EAAAD,EAAA,SACCO,KAAA,SAAAC,GACD,MCAgB,UAAUC,GCN1B,QAAAC,GAAAC,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAT,OAGA,IAAAC,GAAAS,EAAAD,IACAE,EAAAF,EACAG,GAAA,EACAZ,WAUA,OANAO,GAAAE,GAAAI,KAAAZ,EAAAD,QAAAC,IAAAD,QAAAQ,GAGAP,EAAAW,GAAA,EAGAX,EAAAD,QAvBA,GAAAU,KA4DA,OAhCAF,GAAAM,EAAAP,EAGAC,EAAAO,EAAAL,EAGAF,EAAAQ,EAAA,SAAAhB,EAAAiB,EAAAC,GACAV,EAAAW,EAAAnB,EAAAiB,IACAG,OAAAC,eAAArB,EAAAiB,GACAK,cAAA,EACAC,YAAA,EACAC,IAAAN,KAMAV,EAAAiB,EAAA,SAAAxB,GACA,GAAAiB,GAAAjB,KAAAyB,WACA,WAA2B,MAAAzB,GAAA,SAC3B,WAAiC,MAAAA,GAEjC,OADAO,GAAAQ,EAAAE,EAAA,IAAAA,GACAA,GAIAV,EAAAW,EAAA,SAAAQ,EAAAC,GAAsD,MAAAR,QAAAS,UAAAC,eAAAjB,KAAAc,EAAAC,IAGtDpB,EAAAuB,EAAA,GAGAvB,IAAAwB,EAAA,KDgBM,SAAU/B,EAAQD,GE7ExBC,EAAAD,QAAAM,GFmFM,SAAUL,EAAQD,EAASQ,GAEjCP,EAAOD,QAAUQ,EAAoB,IAK/B,SAAUP,EAAQgC,EAAqBzB,GAE7C,YGrCM,SAAA0B,GAAkBC,EAAeC,EAAQC,GAE7C,OAF6C,KAAAA,OAAA,GAEzCC,SAASH,GAOX,OALIE,IAEFF,EAAQI,KAAKC,IAAKL,IAGZC,GAER,IAAKK,GAAGC,KACN,MAAOP,EACT,KAAKM,GAAGE,MACN,MAAOJ,MAAKK,MAAOT,EACrB,KAAKM,GAAGI,KACN,MAAON,MAAKO,KAAMX,EACpB,KAAKM,GAAGM,MACN,MAAOR,MAAKS,MAAOb,EACrB,KAAKM,GAAGQ,SACR,IAAKR,GAAGS,KACN,MAAOf,GAAQ,EAAII,KAAKO,KAAMX,GAAUI,KAAKK,MAAOT,EACtD,KAAKM,GAAGU,GACN,MAAOhB,GAAQ,EAAII,KAAKK,MAAOT,GAAUI,KAAKO,KAAMX,GAIxD,MAAOA,GHWTf,OAAOC,eAAeY,EAAqB,cAAgBE,OAAO,GItFlE,IDHYM,GCGZW,EAAA,mBAAAA,MA+NA,MAtNgBA,GAAAC,QAAd,SAAsBC,GAEpB,MAAOA,aAAiBC,QAYZH,EAAAI,cAAd,SAA4BC,EAAUC,GAEpC,GAAID,IAAMC,EAAG,OAAO,CACpB,IAAID,EAAEE,SAAWD,EAAEC,OAAQ,OAAO,CAElC,KAAK,GAAIhD,GAAI,EAAGA,EAAI8C,EAAEE,OAAQhD,IAE5B,GAAI8C,EAAG9C,KAAQ+C,EAAG/C,GAEhB,OAAO,CAIX,QAAO,GASKyC,EAAAQ,SAAd,SAAuBN,GAErB,MAAyB,gBAAZ,IAUDF,EAAAS,SAAd,SAAuBP,GAErB,MAAOhB,UAASgB,IAA2B,gBAAVA,IASrBF,EAAAU,SAAd,SAAuBR,GAErB,MAAiB,QAAVA,IAAmBjD,KAAKgD,QAAQC,IAA4B,gBAAZ,IAS3CF,EAAAW,UAAd,SAAwBT,GAEtB,WAAyB,KAAZ,GASDF,EAAAY,QAAd,SAAsBV,GAEpB,MAAiB,QAAVA,OAAoC,KAAZ,GAqBnBF,EAAAa,sBAAd,SAAoCX,GAElC,MAAOjD,MAAKyD,SAAUR,IAAWjD,KAAKwD,SAAUP,EAAMY,QAkB1Cd,EAAAe,sBAAd,SAAoCb,GAElC,MAAOjD,MAAKgD,QAASC,IAAWA,EAAMK,OAAS,GAkBnCP,EAAAgB,SAAd,SAAuBC,EAAQC,EAAQvD,GAErC,MAAOV,MAAK0D,UAAWM,GAAMA,EAAKhE,KAAK0D,UAAWO,GAAMA,EAAIvD,GAUhDqC,EAAAmB,OAAd,SAAqBC,EAAaC,GAEhC,IAAK,GAAIC,KAAQD,GAEfD,EAAQE,GAASD,EAAMC,EAGzB,OAAOF,IAmBKpB,EAAAuB,IAAd,SAAkBlB,EAAWE,EAAgBiB,EAAiBC,GAE5D,KAAOpB,EAAEE,OAASA,GAEhBkB,EAASpB,EAAImB,EAAUnB,EAAIA,GAAQmB,CAGrC,OAAOnB,IAoBKL,EAAA0B,UAAd,SAAwBrB,EAAWE,EAAgBoB,GAEjD,WAFiD,KAAAA,MAAApB,GAE1CtD,KAAKsE,IAAIlB,EAAI,GAAIE,EAAQ,KAAK,GAAMqB,UAAW,EAAGD,IAG7D3B,MDlOA,SAAYX,GAKVA,IAAA,eAKAA,IAAA,iBAKAA,IAAA,eAMAA,IAAA,iBAKAA,IAAA,uBAMAA,IAAA,WAMAA,IAAA,gBAtCUA,YECZ,IAAYwC,IAAZ,SAAYA,GAEVA,IAAA,aACAA,IAAA,eACAA,IAAA,iBACAA,IAAA,gBALUA,YCAZ,INy4BIC,GMz4BJC,EAAA,mBAAAA,MAqLA,MA/KgBA,GAAAC,iBAA2B,IAK3BD,EAAAE,iBAAwD,GAA7BF,EAAUC,iBAKrCD,EAAAG,eAAsD,GAA7BH,EAAUE,iBAKnCF,EAAAI,cAAmD,GAA3BJ,EAAUG,eAKlCH,EAAAK,eAAmD,EAA1BL,EAAUI,cAKnCJ,EAAAM,gBAAkB,GAKlBN,EAAAO,eAAiB,KAKjBP,EAAAQ,aAAuB,EAMvBR,EAAAS,eAAyB,GAKzBT,EAAAU,aAAuB,GAMvBV,EAAAW,UAAoB,EAKpBX,EAAAY,UAAoB,GAKpBZ,EAAAa,QAAkB,EAKlBb,EAAAc,QAAkB,GAKlBd,EAAAe,SAAmB,EAKnBf,EAAAgB,SAAmB,GAKnBhB,EAAAiB,WAAqB,EAKrBjB,EAAAkB,WAAqB,GAKrBlB,EAAAmB,WAAqB,EAKrBnB,EAAAoB,WAAqB,GAKrBpB,EAAAqB,WAAqB,EAKrBrB,EAAAsB,WAAqB,IAKrBtB,EAAAuB,YAAsB,EAKtBvB,EAAAwB,YAAsB,EAMtBxB,EAAAyB,iBAA2B,EAK3BzB,EAAA0B,0BAAoC,OAKpC1B,EAAA2B,4BAAsC,QAQtC3B,EAAA4B,sBACZ,SAAAC,GAAO,MAAAA,GAAM7B,EAAU0B,0BACV1B,EAAU2B,6BAMX3B,EAAA8B,oBACZC,OAAU/B,EAAUE,iBACpB8B,QAAUhC,EAAUE,iBACpB+B,KAAUjC,EAAUG,eACpB+B,MAAUlC,EAAUG,eACpBgC,IAAUnC,EAAUI,cACpBgC,KAAUpC,EAAUI,cACpBiC,KAAUrC,EAAUK,eACpBiC,MAAUtC,EAAUK,eACpBkC,MAAUvC,EAAUI,cAAgBJ,EAAUc,QAC9C0B,OAAUxC,EAAUI,cAAgBJ,EAAUc,SAQlCd,EAAAyC,mBAA6B,GAM7BzC,EAAA0C,8BAAwC,EAExD1C,KCxIA2C,EAAA,WAqBE,QAAAC,GAAmBC,EAAYC,GAE7B5H,KAAK2H,MAAQA,EACb3H,KAAK4H,IAAMA,EAgYf,MA1XE7G,QAAAC,eAAW0G,EAAAlG,UAAA,WPmeLL,IOneN,WAEE,MAAOnB,MAAK2H,MAAME,OAAS7H,KAAK4H,IAAIC,MPoehC3G,YAAY,EACZD,cAAc,IO3dbyG,EAAAlG,UAAAsG,SAAP,SAAgBb,GAEd,MAAOA,GAAIY,MAAQ7H,KAAK2H,MAAME,MAAQZ,EAAIY,MAAQ7H,KAAK4H,IAAIC,MAYtDH,EAAAlG,UAAAuG,UAAP,SAAiBd,GAEf,MAAOA,GAAIY,KAAO7H,KAAK2H,MAAME,MAAQ,EAAKZ,EAAIY,KAAO7H,KAAK4H,IAAIC,KAAO,EAAI,GAUpEH,EAAAlG,UAAAwG,WAAP,SAAkBf,GAEhB,MAAOjH,MAAK8H,SAAUb,IAASA,EAAIgB,QAASjI,KAAK2H,QAAWV,EAAIgB,QAASjI,KAAK4H,MAUzEF,EAAAlG,UAAA0G,YAAP,SAAmBjB,GAEjB,MAAOjH,MAAK8H,SAAUb,IAASA,EAAIkB,SAAUnI,KAAK2H,QAAWV,EAAIkB,SAAUnI,KAAK4H,MAU3EF,EAAAlG,UAAA4G,aAAP,SAAoBnB,GAElB,MAAOjH,MAAK8H,SAAUb,IAASA,EAAIoB,UAAWrI,KAAK2H,QAAWV,EAAIoB,UAAWrI,KAAK4H,MAU7EF,EAAAlG,UAAA8G,YAAP,SAAmBrB,GAEjB,MAAOjH,MAAK8H,SAAUb,IAASA,EAAIsB,SAAUvI,KAAK2H,QAAWV,EAAIsB,SAAUvI,KAAK4H,MAY3EF,EAAAlG,UAAAgH,OAAP,SAAczG,EAAkBC,GAE9B,WAFY,KAAAD,MAASK,EAAGS,UAAM,KAAAb,OAAA,GAEvBhC,KAAK2H,MAAMc,cAAczI,KAAK4H,IAAK7F,EAAIC,IAWzC0F,EAAAlG,UAAAkH,QAAP,SAAe3G,EAAkBC,GAE/B,WAFa,KAAAD,MAASK,EAAGS,UAAM,KAAAb,OAAA,GAExBhC,KAAK2H,MAAMgB,eAAe3I,KAAK4H,IAAK7F,EAAIC,IAW1C0F,EAAAlG,UAAAsF,QAAP,SAAe/E,EAAkBC,GAE/B,WAFa,KAAAD,MAASK,EAAGS,UAAM,KAAAb,OAAA,GAExBhC,KAAK2H,MAAMiB,eAAe5I,KAAK4H,IAAK7F,EAAIC,IAW1C0F,EAAAlG,UAAAwF,MAAP,SAAajF,EAAkBC,GAE7B,WAFW,KAAAD,MAASK,EAAGS,UAAM,KAAAb,OAAA,GAEtBhC,KAAK2H,MAAMkB,aAAa7I,KAAK4H,IAAK7F,EAAIC,IAWxC0F,EAAAlG,UAAA0F,KAAP,SAAYnF,EAAkBC,GAE5B,WAFU,KAAAD,MAASK,EAAGS,UAAM,KAAAb,OAAA,GAErBhC,KAAK2H,MAAMmB,YAAY9I,KAAK4H,IAAK7F,EAAIC,IAWvC0F,EAAAlG,UAAA4F,MAAP,SAAarF,EAAkBC,GAE7B,WAFW,KAAAD,MAASK,EAAGS,UAAM,KAAAb,OAAA,GAEtBhC,KAAK2H,MAAMoB,aAAa/I,KAAK4H,IAAK7F,EAAIC,IAWxC0F,EAAAlG,UAAA8F,OAAP,SAAcvF,EAAkBC,GAE9B,WAFY,KAAAD,MAASK,EAAGS,UAAM,KAAAb,OAAA,GAEvBhC,KAAK2H,MAAMqB,cAAchJ,KAAK4H,IAAK7F,EAAIC,IAWzC0F,EAAAlG,UAAAyH,MAAP,SAAalH,EAAkBC,GAE7B,WAFW,KAAAD,MAASK,EAAGS,UAAM,KAAAb,OAAA,GAEtBhC,KAAK2H,MAAMuB,aAAalJ,KAAK4H,IAAK7F,EAAIC,IAaxC0F,EAAAlG,UAAA2H,WAAP,SAAkBC,GAEhB,OAAQpJ,KAAK2H,MAAME,KAAOuB,EAAWvB,MAAQ/C,EAAUI,eAalDwC,EAAAlG,UAAA6H,SAAP,SAAgBD,GAEd,OAAQpJ,KAAK4H,IAAIC,KAAOuB,EAAWvB,MAAQ/C,EAAUI,eAuBhDwC,EAAAlG,UAAA8H,UAAP,SAAiBF,EAAiBG,EAAuBC,EAAsBC,EAA0BC,EAAyBC,EAAsBC,EAAqBC,OAA3I,KAAAN,MAAA,OAAuB,KAAAC,MAAA,OAAsB,KAAAC,MAAA,OAA0B,KAAAC,MAAA,OAAyB,KAAAC,OAAA,OAAsB,KAAAC,MAAA,OAAqB,KAAAC,MAAA,EAE3K,IAAMC,GAAmB9J,KAAKmJ,WAAYC,GACpCW,EAAiB/J,KAAKqJ,SAAUD,GAEhCzB,EAAgBgC,EAAOzH,KAAK8H,IAAI,EAAGF,GAAYA,EAC/ClC,EAAc+B,EAAOzH,KAAK+H,IAAI,EAAGF,GAAUA,EAE3CG,EAAeT,EACfU,EAAgBX,EAAWU,EAE3BE,EAAgBV,GAAe,EAE/BW,EAAc1C,EAAQ4B,EACtBe,EAAiB1C,EAAM2B,CAE7B,QACEc,IAAKA,EAAMR,EACXS,OAAQA,EAAST,EACjBU,OAAQD,EAASD,EACjBH,KAAMA,EAAON,EACbO,MAAOA,EAAQP,EACfQ,MAAOA,IAmBJ1C,EAAAlG,UAAAgJ,QAAP,SAAeC,EAAaC,EAA2BC,EAAwBC,EAAyBC,EAA4BC,OAAxG,KAAAJ,OAAA,OAA2B,KAAAC,OAAA,OAAwB,KAAAC,OAAA,OAAyB,KAAAC,OAAA,OAA4B,KAAAC,MAAA,MAElI,IAAIC,GAAUrD,EAAQsD,gBAAiBP,GACnCQ,EAAaC,EAAID,QACjBE,GAA0BN,IAAe7K,KAAK2H,MAAMY,SAAU0C,GAC9DG,GAAwBP,IAAe7K,KAAK4H,IAAIW,SAAU0C,GAC1DtD,EAAgB3H,KAAK2H,MAAM0D,OAAQN,EAAQJ,EAAOD,EAAWS,IAC7DvD,EAAc5H,KAAK4H,IAAIyD,OAAQN,EAAQJ,EAAOD,EAAWU,IACzDZ,EAAkB7C,CAiBtB,OAfIA,KAAUC,GAEPgD,IAEHJ,EAAUxK,KAAK2H,MAAM0D,OAAQN,EAAQJ,EAAOD,GAAY1K,KAAK2H,MAAMY,SAASvI,KAAK4H,QAGnF4C,GAAWM,EACXN,GAAW5C,GAIX4C,EAAU7C,EAGL6C,GASF9C,EAAAlG,UAAA8J,WAAP,SAAkBC,GAEhB,QACEvL,KAAK4H,IAAIC,KAAO0D,EAAK5D,MAAME,MAC3B7H,KAAK2H,MAAME,KAAO0D,EAAK3D,IAAIC,OAWxBH,EAAAlG,UAAAgK,aAAP,SAAoBD,GAElB,GAAI5D,GAAa3H,KAAK2H,MAAMqC,IAAKuB,EAAK5D,OAClCC,EAAW5H,KAAK4H,IAAIqC,IAAKsB,EAAK3D,IAElC,OAAOD,GAAM8D,QAAS7D,GAAQ,KAAO,GAAIF,GAAQC,EAAOC,IASnDF,EAAAlG,UAAAkK,MAAP,SAAaH,GAKX,MAAO,IAAI7D,GAHM1H,KAAK2H,MAAMsC,IAAKsB,EAAK5D,OACvB3H,KAAK4H,IAAIoC,IAAKuB,EAAK3D,OAYtBF,EAAAiE,MAAd,SAAoB1E,GAElB,MAAO,IAAIS,GAAST,EAAKA,IAObS,EAAAsD,iBAAenG,KAE3BA,EAACD,EAAMgH,KAAM,SAACjB,EAAgBD,EAAoBmB,GAChD,OAAQnB,EAAaC,EAAQ,QAAU,SAAY,KAAOA,EAAQ,OAAS,SAAW,MAAQkB,EAAO,QAAU,KAEjHhH,EAACD,EAAMkH,MAAO,SAACnB,EAAgBD,EAAoBmB,GACjD,OAAQnB,EAAaC,EAAQ,QAAU,SAAY,KAAOA,EAAQ,OAAS,SAAW,MAAQkB,EAAO,QAAU,KAEjHhH,EAACD,EAAMmH,OAAQ,SAACpB,EAAgBD,EAAoBmB,GAClD,OAAQlB,EAAQ,MAAQ,SAAWkB,EAAO,QAAU,KAEtDhH,EAACD,EAAMoH,MAAO,SAACrB,EAAgBD,EAAoBmB,GACjD,MAAQA,GAAO,OAAS,IPoctBhH,GOhcR6C,KPwcIuE,EAAajM,MAAQA,KAAKiM,WAAc,WACxC,GAAIC,GAAgBnL,OAAOoL,iBACpBC,uBAA2BlJ,QAAS,SAAUvC,EAAGsD,GAAKtD,EAAEyL,UAAYnI,IACvE,SAAUtD,EAAGsD,GAAK,IAAK,GAAIvC,KAAKuC,GAAOA,EAAExC,eAAeC,KAAIf,EAAEe,GAAKuC,EAAEvC,IACzE,OAAO,UAAUf,EAAGsD,GAEhB,QAASoI,KAAOrM,KAAKsM,YAAc3L,EADnCuL,EAAcvL,EAAGsD,GAEjBtD,EAAEa,UAAkB,OAANyC,EAAalD,OAAOwL,OAAOtI,IAAMoI,EAAG7K,UAAYyC,EAAEzC,UAAW,GAAI6K,QQt1BvFG,EAAA,mBAAAC,MA+LA,MAtLSA,GAAAjL,UAAAkL,GAAP,SAAUC,GAER,OAAQA,EAAK,IAAIrJ,SAAWtD,KAAK4M,aA0EzBH,EAAAjL,UAAAqL,QAAV,WR2yBM,IQ3yBY,GAAAC,MAAAC,EAAA,EAAAA,EAAAC,UAAA1J,OAAAyJ,IAAAD,EAAAC,GAAAC,UAAAD,EAKhB,KAAK,GAHCE,GAAmBjN,KAAKkN,YAC1BC,EAAgB,EAEX7M,EAAI,EAAGA,EAAIwM,EAAOxJ,OAAQhD,IAEjC6M,GAASL,EAAQxM,GAAM2M,EAAQ3M,EAGjC,OAAON,MAAK0M,GAAIS,GAAUA,EAAQpK,EAAG0B,UAAU0I,EAAOnN,KAAK4M,cAUnDH,EAAAjL,UAAA4L,UAAV,SAAoBT,GAMlB,IAAK,GAJCM,GAAmBjN,KAAKkN,YAC1BC,EAAgBpK,EAAGS,SAASmJ,GAAcA,EAAKU,SAAiBV,GAChEG,KAEKxM,EAAI,EAAGA,EAAI2M,EAAO3J,OAAS,EAAGhD,IACvC,CACE,GAAIgN,GAAeL,EAAQ3M,EAAI,GAC3BiN,EAAeN,EAAQ3M,EAAI,GAC3BkN,EAAcD,EAAOD,EACrBxL,EAAgBqL,EAAQK,CAE5BV,GAAOW,KAAM3L,GACbqL,EAAQjL,KAAKK,MAAO4K,EAAQK,GAK9B,MAFAV,GAAOW,KAAMN,GAENL,GAwCKL,EAAAiB,KAAd,SAAmBf,GAEjB,MAAI3M,MAAK2N,KAAKjB,GAAGC,GAAY3M,KAAK2N,KAC9B3N,KAAK4N,IAAIlB,GAAGC,GAAY3M,KAAK4N,IAC7B5N,KAAK6N,KAAKnB,GAAGC,GAAY3M,KAAK6N,KAC9B7N,KAAK8N,MAAMpB,GAAGC,GAAY3M,KAAK8N,MAC/B9N,KAAK+N,KAAKrB,GAAGC,GAAY3M,KAAK+N,KAE3B,MAYKtB,EAAA3E,SAAd,SAAuBkG,EAAwBC,GAE7C,GAAIC,GAAsBF,EAAQ,EAElC,QAAQC,EAAQ,IAAItJ,UAAW,EAAGuJ,EAAY5K,UAAa4K,GA1D/CzB,EAAAkB,KAAmB,KAKnBlB,EAAAmB,IAAkB,KAKlBnB,EAAAoB,KAAmB,KAKnBpB,EAAAqB,MAAoB,KAKpBrB,EAAA0B,QAAsB,KAKtB1B,EAAAsB,KAAmB,KAoCnCtB,KAGA2B,EAAA,SAAAC,GAAA,QAAAC,KR6xBQ,MAAkB,QAAXD,GAAmBA,EAAOE,MAAMvO,KAAMgN,YAAchN,KQ3sBnE,MAlF6BiM,GAAAqC,EAAAD,GAcjBC,EAAA9M,UAAA0L,UAAV,WAEE,MAAOoB,GAAeE,QAGdF,EAAA9M,UAAAoL,UAAV,WAEE,MAAO0B,GAAeG,QAGjBH,EAAA9M,UAAAL,IAAP,SAAW8F,GAET,MAAOjH,MAAK6M,QAAQ5F,EAAIJ,OAAQI,EAAIF,KAAME,EAAIyH,WAAYzH,EAAII,MAAQ,EAAGJ,EAAI4E,OAGxEyC,EAAA9M,UAAAF,OAAP,SAAcqL,GAEZ,GAAIG,GAAmB9M,KAAKoN,UAAUT,EAEtC,QACE9F,OAAUiG,EAAO,GACjB/F,KAAU+F,EAAO,GACjB7F,IAAU6F,EAAO,GACjBzF,MAAUyF,EAAO,GAAK,EACtBjB,KAAUiB,EAAO,KAIdwB,EAAA9M,UAAAmG,MAAP,SAAagF,GAEX,GAAIgC,GAAwB3O,KAAKsB,OAAOqL,EAGxC,OAFiBzB,GAAI0D,MAAOD,EAAI9C,KAAM8C,EAAItH,MAAOsH,EAAI1H,IAAK0H,EAAI5H,KAAM4H,EAAI9H,SAKnEyH,EAAA9M,UAAA+J,KAAP,SAAYoB,EAAqBkC,OAAA,KAAAA,OAAA,EAE/B,IAAIlH,GAAa3H,KAAK2H,MAAOgF,GACzB/E,EAAWD,EAAMmH,UAAWD,EAEhC,OAAO,IAAIpH,GAAQE,EAAOC,IAGrB0G,EAAA9M,UAAAuN,SAAP,SAAgBpC,EAAqBhC,OAAA,KAAAA,OAAA,EAEnC,IAAIhD,GAAa3H,KAAK2H,MAAOgF,GACzBtB,EAAiBV,EAAQ2D,EAAeU,sBAAwBV,EAAeW,oBAEnF,OAAOtH,GAAM0D,OAAQA,IAGhBiD,EAAA9M,UAAA0N,QAAP,SAAejI,EAAU0F,GAEvB,MAAO1F,GAAIkI,iBAAmBxC,GAjElB2B,EAAAW,qBAA+B,MAC/BX,EAAAU,sBAAgC,MAE/BV,EAAAE,QACb,EACA,IACA,IACA,IACA,KACaF,EAAAG,OAAiB,GAsElCH,GAlF6B9B,GAqF7B4C,EAAA,SAAAf,GAAA,QAAAgB,KR4wBQ,MAAkB,QAAXhB,GAAmBA,EAAOE,MAAMvO,KAAMgN,YAAchN,KQhsBnE,MA5E4BiM,GAAAoD,EAAAhB,GAYhBgB,EAAA7N,UAAA0L,UAAV,WAEE,MAAOmC,GAAcb,QAGba,EAAA7N,UAAAoL,UAAV,WAEE,MAAOyC,GAAcZ,QAGhBY,EAAA7N,UAAAL,IAAP,SAAW8F,GAET,MAAOjH,MAAK6M,QAAQ5F,EAAIyH,WAAYzH,EAAII,MAAQ,EAAGJ,EAAI4E,OAGlDwD,EAAA7N,UAAAF,OAAP,SAAcqL,GAEZ,GAAIG,GAAmB9M,KAAKoN,UAAUT,EAEtC,QACE1F,IAAU6F,EAAO,GACjBzF,MAAUyF,EAAO,GAAK,EACtBjB,KAAUiB,EAAO,KAIduC,EAAA7N,UAAAmG,MAAP,SAAagF,GAEX,GAAIgC,GAAwB3O,KAAKsB,OAAOqL,EAGxC,OAFiBzB,GAAI0D,MAAOD,EAAI9C,KAAM8C,EAAItH,MAAOsH,EAAI1H,MAKhDoI,EAAA7N,UAAA+J,KAAP,SAAYoB,EAAqBkC,OAAA,KAAAA,OAAA,EAE/B,IAAIlH,GAAa3H,KAAK2H,MAAOgF,GACzB/E,EAAWD,EAAMC,IAAKiH,EAE1B,OAAO,IAAIpH,GAAQE,EAAOC,IAGrByH,EAAA7N,UAAAuN,SAAP,SAAgBpC,EAAqBhC,OAAA,KAAAA,OAAA,EAEnC,IAAIhD,GAAa3H,KAAK2H,MAAOgF,GACzBtB,EAAiBV,EAAQ0E,EAAcL,sBAAwBK,EAAcJ,oBAEjF,OAAOtH,GAAM0D,OAAQA,IAGhBgE,EAAA7N,UAAA0N,QAAP,SAAejI,EAAU0F,GAEvB,MAAO1F,GAAIqI,gBAAkB3C,GA7DjB0C,EAAAJ,qBAA+B,KAC/BI,EAAAL,sBAAgC,KAE/BK,EAAAb,QACb,EACA,IACA,KACaa,EAAAZ,OAAiB,EAkElCY,GA5E4B7C,GA+E5B+C,EAAA,SAAAlB,GAAA,QAAAmB,KR2vBQ,MAAkB,QAAXnB,GAAmBA,EAAOE,MAAMvO,KAAMgN,YAAchN,KQlrBnE,MAzE6BiM,GAAAuD,EAAAnB,GAWjBmB,EAAAhO,UAAA0L,UAAV,WAEE,MAAOsC,GAAehB,QAGdgB,EAAAhO,UAAAoL,UAAV,WAEE,MAAO4C,GAAef,QAGjBe,EAAAhO,UAAAL,IAAP,SAAW8F,GAET,MAAOjH,MAAK6M,QAAQ5F,EAAIE,KAAMF,EAAI4E,OAG7B2D,EAAAhO,UAAAF,OAAP,SAAcqL,GAEZ,GAAIG,GAAmB9M,KAAKoN,UAAUT,EAEtC,QACExF,KAAU2F,EAAO,GACjBjB,KAAUiB,EAAO,KAId0C,EAAAhO,UAAAmG,MAAP,SAAagF,GAEX,GAAIgC,GAAwB3O,KAAKsB,OAAOqL,EAGxC,OAFiBzB,GAAI0D,MAAOD,EAAI9C,KAAM,GAAI4D,SAAUd,EAAIxH,OAKnDqI,EAAAhO,UAAA+J,KAAP,SAAYoB,EAAqBkC,OAAA,KAAAA,OAAA,EAE/B,IAAIlH,GAAa3H,KAAK2H,MAAOgF,GACzB/E,EAAWD,EAAM+H,UAAWb,EAEhC,OAAO,IAAIpH,GAAQE,EAAOC,IAGrB4H,EAAAhO,UAAAuN,SAAP,SAAgBpC,EAAqBhC,OAAA,KAAAA,OAAA,EAEnC,IAAIhD,GAAa3H,KAAK2H,MAAOgF,GACzBtB,EAAiBV,EAAQ6E,EAAeR,sBAAwBQ,EAAeP,oBAEnF,OAAOtH,GAAM0D,OAAQA,IAGhBmE,EAAAhO,UAAA0N,QAAP,SAAejI,EAAU0F,GAEvB,MAAO1F,GAAI0I,iBAAmBhD,GA3DlB6C,EAAAP,qBAA+B,oBAC/BO,EAAAR,sBAAgC,oBAE/BQ,EAAAhB,QACb,EACA,KACagB,EAAAf,OAAiB,EAgElCe,GAzE6BhD,GA4E7BoD,EAAA,SAAAvB,GAAA,QAAAwB,KR0uBQ,MAAkB,QAAXxB,GAAmBA,EAAOE,MAAMvO,KAAMgN,YAAchN,KQjqBnE,MAzE8BiM,GAAA4D,EAAAxB,GAWlBwB,EAAArO,UAAA0L,UAAV,WAEE,MAAO2C,GAAgBrB,QAGfqB,EAAArO,UAAAoL,UAAV,WAEE,MAAOiD,GAAgBpB,QAGlBoB,EAAArO,UAAAL,IAAP,SAAW8F,GAET,MAAOjH,MAAK6M,QAAQ5F,EAAII,MAAQ,EAAGJ,EAAI4E,OAGlCgE,EAAArO,UAAAF,OAAP,SAAcqL,GAEZ,GAAIG,GAAmB9M,KAAKoN,UAAUT,EAEtC,QACEtF,MAAUyF,EAAO,GAAK,EACtBjB,KAAUiB,EAAO,KAId+C,EAAArO,UAAAmG,MAAP,SAAagF,GAEX,GAAIgC,GAAwB3O,KAAKsB,OAAOqL,EAGxC,OAFiBzB,GAAI0D,MAAOD,EAAI9C,KAAM8C,EAAItH,QAKrCwI,EAAArO,UAAA+J,KAAP,SAAYoB,EAAqBkC,OAAA,KAAAA,OAAA,EAE/B,IAAIlH,GAAa3H,KAAK2H,MAAOgF,GACzB/E,EAAWD,EAAMmI,WAAYjB,EAEjC,OAAO,IAAIpH,GAAQE,EAAOC,IAGrBiI,EAAArO,UAAAuN,SAAP,SAAgBpC,EAAqBhC,OAAA,KAAAA,OAAA,EAEnC,IAAIhD,GAAa3H,KAAK2H,MAAOgF,GACzBtB,EAAiBV,EAAQkF,EAAgBb,sBAAwBa,EAAgBZ,oBAErF,OAAOtH,GAAM0D,OAAQA,IAGhBwE,EAAArO,UAAA0N,QAAP,SAAejI,EAAU0F,GAEvB,MAAO1F,GAAI8I,kBAAoBpD,GA3DnBkD,EAAAZ,qBAA+B,YAC/BY,EAAAb,sBAAgC,WAE/Ba,EAAArB,QACb,EACA,KACaqB,EAAApB,OAAiB,EAgElCoB,GAzE8BrD,GA4E9BwD,EAAA,SAAA3B,GAAA,QAAA4B,KRytBQ,MAAkB,QAAX5B,GAAmBA,EAAOE,MAAMvO,KAAMgN,YAAchN,KQhpBnE,MAzEgCiM,GAAAgE,EAAA5B,GAWpB4B,EAAAzO,UAAA0L,UAAV,WAEE,MAAO+C,GAAkBzB,QAGjByB,EAAAzO,UAAAoL,UAAV,WAEE,MAAOqD,GAAkBxB,QAGpBwB,EAAAzO,UAAAL,IAAP,SAAW8F,GAET,MAAOjH,MAAK6M,QAAQ5F,EAAIiJ,QAASjJ,EAAI4E,OAGhCoE,EAAAzO,UAAAF,OAAP,SAAcqL,GAEZ,GAAIG,GAAmB9M,KAAKoN,UAAUT,EAEtC,QACEuD,QAAUpD,EAAO,GACjBjB,KAAUiB,EAAO,KAIdmD,EAAAzO,UAAAmG,MAAP,SAAagF,GAEX,GAAIgC,GAAwB3O,KAAKsB,OAAOqL,EAGxC,OAFiBzB,GAAI0D,MAAOD,EAAI9C,KAA0B,GAAnB8C,EAAIuB,QAAU,KAKhDD,EAAAzO,UAAA+J,KAAP,SAAYoB,EAAqBkC,OAAA,KAAAA,OAAA,EAE/B,IAAIlH,GAAa3H,KAAK2H,MAAOgF,GACzB/E,EAAWD,EAAMwI,eAAgB,GAAIL,WAAYjB,EAErD,OAAO,IAAIpH,GAAQE,EAAOC,IAGrBqI,EAAAzO,UAAAuN,SAAP,SAAgBpC,EAAqBhC,OAAA,KAAAA,OAAA,EAEnC,IAAIhD,GAAa3H,KAAK2H,MAAOgF,GACzBtB,EAAiBV,EAAQsF,EAAkBjB,sBAAwBiB,EAAkBhB,oBAEzF,OAAOtH,GAAM0D,OAAQA,IAGhB4E,EAAAzO,UAAA0N,QAAP,SAAejI,EAAU0F,GAEvB,MAAO1F,GAAImJ,oBAAsBzD,GA3DrBsD,EAAAhB,qBAA+B,oBAC/BgB,EAAAjB,sBAAgC,oBAE/BiB,EAAAzB,QACb,EACA,IACayB,EAAAxB,OAAiB,EAgElCwB,GAzEgCzD,GA4EhC6D,EAAA,SAAAhC,GAAA,QAAAiC,KRwsBQ,MAAkB,QAAXjC,GAAmBA,EAAOE,MAAMvO,KAAMgN,YAAchN,KQloBnE,MAtE6BiM,GAAAqE,EAAAjC,GAUjBiC,EAAA9O,UAAA0L,UAAV,WAEE,MAAOoD,GAAe9B,QAGd8B,EAAA9O,UAAAoL,UAAV,WAEE,MAAO0D,GAAe7B,QAGjB6B,EAAA9O,UAAAL,IAAP,SAAW8F,GAET,MAAOjH,MAAK6M,QAAQ5F,EAAI4E,OAGnByE,EAAA9O,UAAAF,OAAP,SAAcqL,GAIZ,OACEd,KAHqB7L,KAAKoN,UAAUT,GAGnB,KAId2D,EAAA9O,UAAAmG,MAAP,SAAagF,GAEX,GAAIgC,GAAwB3O,KAAKsB,OAAOqL,EAGxC,OAFiBzB,GAAI0D,MAAOD,EAAI9C,KAAM,IAKjCyE,EAAA9O,UAAA+J,KAAP,SAAYoB,EAAqBkC,OAAA,KAAAA,OAAA,EAE/B,IAAIlH,GAAa3H,KAAK2H,MAAOgF,GACzB/E,EAAWD,EAAM4I,UAAW1B,EAEhC,OAAO,IAAIpH,GAAQE,EAAOC,IAGrB0I,EAAA9O,UAAAuN,SAAP,SAAgBpC,EAAqBhC,OAAA,KAAAA,OAAA,EAEnC,IAAIhD,GAAa3H,KAAK2H,MAAOgF,GACzBtB,EAAiBV,EAAQ2F,EAAetB,sBAAwBsB,EAAerB,oBAEnF,OAAOtH,GAAM0D,OAAQA,IAGhBiF,EAAA9O,UAAA0N,QAAP,SAAejI,EAAU0F,GAEvB,MAAO1F,GAAI4E,OAASc,GAzDR2D,EAAArB,qBAA+B,OAC/BqB,EAAAtB,sBAAgC,OAE/BsB,EAAA9B,QACb,GACa8B,EAAA7B,OAAiB,EA8DlC6B,GAtE6B9D,EAyE7BA,GAAWmB,KAAO,GAAIS,GACtB5B,EAAWoB,IAAM,GAAIwB,GACrB5C,EAAWqB,KAAO,GAAI0B,GACtB/C,EAAWsB,MAAQ,GAAI8B,GACvBpD,EAAW2B,QAAU,GAAI6B,GACzBxD,EAAWuB,KAAO,GAAIsC,EChtBtB,ICwBYG,GDxBZC,EAAA,mBAAAA,MAgEA,MAxCE1P,QAAAC,eAAkByP,EAAA,STi4CZtP,ISj4CN,WAEE,IAAKnB,KAAK0Q,OACV,CACE1Q,KAAK0Q,SAEL,KAAK,GAAIpQ,GAAI,EAAGA,GAAKN,KAAK2Q,YAAarQ,IAErCN,KAAK0Q,OAAQpQ,GAAMN,KAAKmB,IAAKb,GAAG,GAIpC,MAAON,MAAK0Q,QT83CRxP,YAAY,EACZD,cAAc,ISt3CNwP,EAAAG,UAAd,SAAwB9O,GAEtB,MAAOA,IAAS,IAAMA,GAAS,GAAK,KAAO9B,KAAK6Q,IAAK/O,EAAQ9B,KAAK6Q,IAAIvN,SAU1DmN,EAAAtP,IAAd,SAAkBW,EAAegP,OAAA,KAAAA,OAAA,EAE/B,IAAIC,GAAiB/Q,KAAK4Q,UAAU9O,EAEpC,OAAOgP,GAAUhP,EAAQiP,EAASA,GAvDtBN,EAAAI,KACZ,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,MAWzCJ,EAAAE,YAAsB,IA8CvCF,MCxCA,SAAYD,GAKVA,IAAA,uBAKAA,IAAA,eAKAA,IAAA,mBAKAA,IAAA,sBApBUA,YCoaZ,KAAoB,GXqtLhBQ,GUhjMJC,EAAA,WAoCE,QAAAC,GAAmBC,GA9BZnR,KAAAoR,OAAc,KAgCnBpR,KAAKmR,OAASA,EAknBlB,MA1mBSD,GAAA1P,UAAA6P,MAAP,WAEE,MAAO,IAAIH,GAAalR,KAAKmR,SASxBD,EAAA1P,UAAA8P,IAAP,SAAWC,GAOT,MALAvR,MAAKwR,OAAShB,EAAeiB,SAC7BzR,KAAK0R,YAAc,KAEnB1R,KAAK2R,SAAUJ,EAAMvR,MAEdA,KAAKwR,QAQPN,EAAA1P,UAAAoQ,KAAP,SAAYR,GAKV,MAHApR,MAAKoR,OAASA,EACdpR,KAAKwR,OAAShB,EAAeqB,KAEtB7R,MAQFkR,EAAA1P,UAAAsQ,QAAP,SAAeJ,GAKb,MAHA1R,MAAK0R,YAAcA,EACnB1R,KAAKwR,OAAShB,EAAeuB,QAEtB/R,MAMFkR,EAAA1P,UAAAwQ,OAAP,WAIE,MAFAhS,MAAKwR,OAAShB,EAAeyB,OAEtBjS,MAUFkR,EAAA1P,UAAA0Q,QAAP,SAAeC,OAAA,KAAAA,MAAA,KAEb,IAAIC,IAAiB,CAarB,OAXApS,MAAKqS,QAAQ,SAACd,EAAMe,GAEdH,IAAWA,EAAQZ,KAKvBa,GAAQ,EACRE,EAASV,UAGJQ,GAWFlB,EAAA1P,UAAA+Q,MAAP,SAAaJ,OAAA,KAAAA,MAAA,KAEX,IAAIhF,GAAgB,CAYpB,OAVAnN,MAAKqS,QAAQ,SAACd,EAAMe,GAEdH,IAAWA,EAAQZ,IAKvBpE,MAGKA,GAUF+D,EAAA1P,UAAAkD,MAAP,SAAayN,OAAA,KAAAA,MAAA,KAEX,IAAIzN,GAAW,IAaf,OAXA1E,MAAKqS,QAAQ,SAACd,EAAMe,GAEdH,IAAWA,EAAQZ,KAKvB7M,EAAQ6M,EACRe,EAASV,UAGJlN,GAYFwM,EAAA1P,UAAAgR,KAAP,SAAYC,EAAeN,GAYzB,WAZU,KAAAM,cAAe,KAAAN,MAAA,MAEzBnS,KAAKqS,QAAQ,SAACd,EAAMe,GAEdH,IAAWA,EAAQZ,IAKvBkB,EAAIhF,KAAM8D,KAGLkB,GAaFvB,EAAA1P,UAAAF,OAAP,SAAcoR,EAA0BD,EAAeN,GAcrD,WAdsC,KAAAM,cAAe,KAAAN,MAAA,MAErDnS,KAAKqS,QAAQ,SAACd,EAAMe,GAElB,IAAIH,GAAWA,EAAQZ,GAAvB,CAKA,GAAIoB,GAAMD,EAAQnB,EAElBkB,GAAKE,GAAQpB,KAGRkB,GASFvB,EAAA1P,UAAAoR,KAAP,SAAYC,GAAZ,GAAAC,GAAA9S,IAEE,OAAO,IAAIkR,GAAY,SAAA3D,GAErBuF,EAAKT,QAAQ,SAACd,EAAMwB,GAElB,OAAQxF,EAAK+D,IAAKC,IAEhB,IAAKf,GAAeqB,KAClBkB,EAAKnB,MACL,MACF,KAAKpB,GAAeyB,OAClBc,EAAKf,QACL,MACF,KAAKxB,GAAeuB,QAClBgB,EAAKjB,QAASvE,EAAKmE,eAIjBmB,GAAU,GAEdE,EAAKnB,YAaNV,EAAA1P,UAAAwR,KAAP,SAAYH,GAAZ,GAAAC,GAAA9S,IAEE,OAAO,IAAIkR,GAAY,SAAA3D,GAErB,GAAI0F,GAAkB,CAEtBH,GAAKT,QAAQ,SAACd,EAAMwB,GAElB,GAAIE,GAAWJ,EAEb,OAAQtF,EAAK+D,IAAKC,IAEhB,IAAKf,GAAeqB,KAClBkB,EAAKnB,MACL,MACF,KAAKpB,GAAeyB,OAClBc,EAAKf,QACL,MACF,KAAKxB,GAAeuB,QAClBgB,EAAKjB,QAASvE,EAAKmE,aAKzBuB,SAYC/B,EAAA1P,UAAA0R,OAAP,WVi2CM,IUj2CQ,GAAAC,MAAApG,EAAA,EAAAA,EAAAC,UAAA1J,OAAAyJ,IAAAoG,EAAApG,GAAAC,UAAAD,EAEZ,OAAOmE,GAASkC,KAAI7E,MAAb2C,GAAkBlR,MAAIqT,OAAKF,KAU7BjC,EAAA1P,UAAAsP,QAAP,WVm2CM,IUn2CS,GAAAqC,MAAApG,EAAA,EAAAA,EAAAC,UAAA1J,OAAAyJ,IAAAoG,EAAApG,GAAAC,UAAAD,EAEb,OAAOmE,GAASkC,KAAI7E,MAAb2C,EAAqBiC,EAASE,QAAErT,SAQlCkR,EAAA1P,UAAA8R,MAAP,SAAanB,GAUX,MARAnS,MAAKqS,QAAQ,SAACd,EAAMe,GAEdH,EAAOZ,IAETe,EAASN,WAINhS,MASFkR,EAAA1P,UAAA+R,QAAP,cAAAT,GAAA9S,IAEE,OAAO,IAAIkR,GAAY,SAAAoB,GAOrB,IAAK,GALDkB,GAAaV,EAAKN,OAClBiB,GAAoB,EACpBC,KACAC,KAEKrT,EAAIkT,EAAMlQ,OAAS,EAAGhD,GAAK,EAAGA,IACvC,CACE,GAAIiR,GAAUiC,EAAOlT,GACjBkR,EAAyBc,EAAShB,IAAKC,EAE3C,IAAIC,IAAWhB,EAAeqB,KAE5B,KAGEL,KAAWhB,EAAeiB,WAE5BgC,GAAW,EAEXC,EAASpT,GAAMkR,EACfmC,EAAUrT,GAAMgS,EAASZ,aAI7B,GAAI+B,EACJ,CACE,GAAIG,GAAgB,CAEpBd,GAAKT,QAAQ,SAACd,EAAMe,GAElB,OAAQoB,EAASE,IAEf,IAAKpD,GAAeyB,OAClBK,EAASN,QACT,MACF,KAAKxB,GAAeuB,QAClBO,EAASR,QAAS6B,EAAUC,IAIhCA,UAUD1C,EAAA1P,UAAAqS,OAAP,SAAiBC,EAAYC,EAAqC5B,OAAA,KAAAA,MAAA,KAEhE,IAAI6B,GAAaF,CAYjB,OAVA9T,MAAKqS,QAAQ,SAACd,EAAMe,GAEdH,IAAWA,EAAQZ,KAKvByC,EAAUD,EAASxC,EAAMyC,MAGpBA,GAUF9C,EAAA1P,UAAA2Q,OAAP,SAAcA,GAAd,GAAAW,GAAA9S,IAEE,OAAO,IAAIkR,GAAY,SAAA3D,GAErBuF,EAAKT,QAAQ,SAAC4B,EAAUlB,GAEtB,GAAIZ,EAAO8B,GAET,OAAQ1G,EAAK+D,IAAK2C,IAEhB,IAAKzD,GAAeqB,KAClBkB,EAAKnB,MACL,MACF,KAAKpB,GAAeyB,OAClBc,EAAKf,QACL,MACF,KAAKxB,GAAeuB,QAClBgB,EAAKjB,QAASvE,EAAKmE,mBAqBxBR,EAAA1P,UAAA0S,IAAP,SAAcC,EACZhC,EACAiC,GAFF,GAAAtB,GAAA9S,IAIE,YAHA,KAAAmS,MAAA,UACA,KAAAiC,MAAA,MAEO,GAAIlD,GAAY,SAAA3D,GAErBuF,EAAKT,QAAQ,SAAC4B,EAAUlB,GAEtB,IAAIZ,GAAWA,EAAQ8B,GAAvB,CAKA,GAAII,GAAcF,EAAQF,EAAUlB,EAEpC,IAAIhQ,EAAGW,UAAW2Q,GAEhB,OAAQ9G,EAAK+D,IAAK+C,IAEhB,IAAK7D,GAAeqB,KAClBkB,EAAKnB,MACL,MACF,KAAKpB,GAAeyB,OAClBc,EAAKf,QACL,MACF,KAAKxB,GAAeuB,QACdqC,GACFrB,EAAKjB,QAASsC,EAAU7G,EAAKmE,YAAa2C,EAAUJ,WAgB3D/C,EAAA1P,UAAA6Q,QAAP,SAAeV,GAQb,MANA3R,MAAKoR,WAASkD,GACdtU,KAAK2R,SAAWA,EAChB3R,KAAKwR,OAAShB,EAAeiB,SAC7BzR,KAAKmR,OAAQnR,MACbA,KAAK2R,SAAW,KAET3R,MASFkR,EAAA1P,UAAA+S,WAAP,SAAkBC,GAOhB,MALIxU,MAAKoR,QAEPoD,EAAWxU,KAAKoR,QAGXpR,MAUKkR,EAAAuD,SAAd,SAA0BjB,EAAYD,GAEpC,WAFoC,KAAAA,OAAA,GAE7B,GAAIrC,GAAY,SAAAoB,GAErB,GAAIiB,EAEF,IAAK,GAAIjT,GAAIkT,EAAMlQ,OAAS,EAAGhD,GAAK,EAAGA,IAErC,OAAQgS,EAAShB,IAAIkC,EAAOlT,KAE1B,IAAKkQ,GAAeqB,KAClB,MACF,KAAKrB,GAAeyB,OAClBuB,EAAMkB,OAAOpU,EAAG,EAChB,MACF,KAAKkQ,GAAeuB,QAClByB,EAAMkB,OAAOpU,EAAG,EAAGgS,EAASZ,iBAOlC,KAAK,GAAIpR,GAAI,EAAGA,EAAIkT,EAAMlQ,OAAQhD,IAEhC,OAAQgS,EAAShB,IAAIkC,EAAOlT,KAE1B,IAAKkQ,GAAeqB,KAClB,MACF,KAAKrB,GAAeyB,OAClBuB,EAAMkB,OAAOpU,EAAG,GAChBA,GACA,MACF,KAAKkQ,GAAeuB,QAClByB,EAAMkB,OAAOpU,EAAG,EAAGgS,EAASZ,iBAgB1BR,EAAAyD,UAAd,SAA2BnB,EAA6B/R,GAEtD,WAFsD,KAAAA,OAAA,GAE/C,GAAIyP,GAAY,SAAAoB,GAErB,IAAK,GAAIK,KAAOa,GAEd,IAAI/R,GAAmB+R,EAAM/R,eAAgBkR,GAK7C,OAAQL,EAAShB,IAAIkC,EAAOb,KAE1B,IAAKnC,GAAeqB,KAClB,MACF,KAAKrB,GAAeyB,aACXuB,GAAOb,EACd,MACF,KAAKnC,GAAeuB,QAClByB,EAAOb,GAAQL,EAASZ,gBAgBpBR,EAAAkC,KAAd,WVyyCM,IUzyCgB,GAAAD,MAAApG,EAAA,EAAAA,EAAAC,UAAA1J,OAAAyJ,IAAAoG,EAAApG,GAAAC,UAAAD,EAEpB,OAAO,IAAImE,GAAY,SAAA0D,GAErB,IAAkB,GAAA7H,GAAA,EAAA8H,EAAA1B,EAAApG,EAAA8H,EAAAvR,OAAAyJ,IAAS,CAAtB,GAAI+H,GAAKD,EAAA9H,EAkBZ,IAhBA+H,EAAMzC,QAAQ,SAACd,EAAMwD,GAEnB,OAAQH,EAAOtD,IAAKC,IAElB,IAAKf,GAAeyB,OAClB8C,EAAc/C,QACd,MACF,KAAKxB,GAAeqB,KAClBkD,EAAcnD,MACd,MACF,KAAKpB,GAAeuB,QAClBgD,EAAcjD,QAAS8C,EAAOlD,gBAKhCoD,EAAMtD,SAAWhB,EAAeqB,KAElC,WAWMX,EAAAkB,MAAd,WAEE,MAAO,IAAIlB,GAAY,SAAA0D,OAG3B1D,KEluBA8D,EAAA,WAYE,QAAAC,KAEEjV,KAAKkU,OAuVT,MAjVSe,GAAAzT,UAAA0T,MAAP,WAIE,MAFAlV,MAAKkU,OAEElU,MAMFiV,EAAAzT,UAAA0Q,QAAP,WAGE,IAAK,GAAIvF,KAAM3M,MAAKkU,IAElB,OAAQvH,CAGV,QAAO,GAaFsI,EAAAzT,UAAAL,IAAP,SAAW8F,EAAUkO,EAAcC,OAAA,KAAAA,OAAA,EAEjC,IAAIlB,GAAMlU,KAAKkU,GAEf,OAAQkB,IAAclB,EAAKjN,EAAIkI,iBAC7B+E,EAAKjN,EAAIqI,gBACT4E,EAAKjN,EAAI8I,kBACTmE,EAAKjN,EAAI0I,iBACTuE,EAAKjN,EAAImJ,oBACT+E,GAWGF,EAAAzT,UAAA6T,cAAP,SAAqBpO,EAAUmO,OAAA,KAAAA,OAAA,EAE7B,IAAIlB,GAAMlU,KAAKkU,GAEf,OAAIkB,IAAcrS,EAAGW,UAAWwQ,EAAKjN,EAAIkI,iBAA2B3C,EAAWmB,KAC3E5K,EAAGW,UAAWwQ,EAAKjN,EAAIqI,gBAA0B9C,EAAWoB,IAC5D7K,EAAGW,UAAWwQ,EAAKjN,EAAI8I,kBAA4BvD,EAAWsB,MAC9D/K,EAAGW,UAAWwQ,EAAKjN,EAAI0I,iBAA2BnD,EAAWqB,KAC7D9K,EAAGW,UAAWwQ,EAAKjN,EAAImJ,oBAA8B5D,EAAW2B,QAChEpL,EAAGW,UAAWwQ,EAAKjN,EAAI4E,OAAiBW,EAAWuB,KAEhD,MAWFkH,EAAAzT,UAAA8T,OAAP,SAAcrO,GAEZ,GAAIiN,GAAMlU,KAAKkU,IACXvN,IAQJ,OANIuN,GAAKjN,EAAIkI,iBAAkBxI,EAAI8G,KAAMyG,EAAKjN,EAAIkI,iBAC9C+E,EAAKjN,EAAIqI,gBAAiB3I,EAAI8G,KAAMyG,EAAKjN,EAAIqI,gBAC7C4E,EAAKjN,EAAI8I,kBAAmBpJ,EAAI8G,KAAMyG,EAAKjN,EAAI8I,kBAC/CmE,EAAKjN,EAAI0I,iBAAkBhJ,EAAI8G,KAAMyG,EAAKjN,EAAI0I,iBAC9CuE,EAAKjN,EAAImJ,oBAAqBzJ,EAAI8G,KAAMyG,EAAKjN,EAAImJ,oBAE9CzJ,GAWFsO,EAAAzT,UAAA+T,KAAP,SAAYnR,EAAWoR,EAAsBC,EAASC,GAEpD,GAAIC,GAAiBH,EAASrU,IAAKiD,GAC/BwR,EAAeF,EAAOvU,IAAKsU,EAM/B,OAJAzV,MAAKkU,IAAK0B,GAAiB5V,KAAKkU,IAAKyB,SAE9B3V,MAAKkU,IAAKyB,GAEV3V,MAWFiV,EAAAzT,UAAAqU,SAAP,SAAgBC,EAAgBC,GAE9B,GAAItL,GAAmB+B,EAAWmB,KAC9BqI,IAEJhW,MAAKqS,UAAUA,QAAQ,SAAC4D,GZ8/DhB,GY9/DiBtJ,GAAAsJ,EAAA,EAAIA,GAAA,EAE3B,IAAIxL,EAAKiC,GAAIC,GACb,CACmBlC,EAAK9C,MAAOgF,GAEnBuJ,SAAUJ,IAElBE,EAAQvI,KAAMd,KAOpB,KAAe,GAFXwJ,GAAgB,EAELpJ,EAAA,EAAAqJ,EAAAJ,EAAAjJ,EAAAqJ,EAAA9S,OAAAyJ,IAAO,CAAjB,GAAIJ,GAAEyJ,EAAArJ,GAELjL,EAAW9B,KAAKkU,IAAKvH,GACrBhF,EAAa8C,EAAK9C,MAAOgF,GACzB0J,EAAgB1O,EAAM2O,SAAUP,GAChCQ,EAAyB9L,EAAKtJ,IAAKkV,EAElCrW,MAAKkU,IAAKqC,KAEbvW,KAAKkU,IAAKqC,GAAUzU,QACb9B,MAAKkU,IAAKvH,GACjBwJ,KAIJ,MAAOA,IASFlB,EAAAzT,UAAAgV,WAAP,SAAkB3O,GAEhB,GAAI4C,GAAmB+B,EAAWmB,KAC9B8I,EAAkB,CAgBtB,OAdAzW,MAAKqS,UAAUA,QAAQ,SAAC4D,EAAO3D,GZm/DvB,GYn/DiB3F,GAAAsJ,EAAA,EAEvB,IAAIxL,EAAKiC,GAAIC,GACb,CACmBlC,EAAK9C,MAAOgF,GAEnBuJ,SAAUrO,KAElByK,EAASN,SACTyE,QAKCA,GAWFxB,EAAAzT,UAAAkV,IAAP,SAAWzP,EAAUnF,EAAU2I,GAI7B,MAFAzK,MAAKkU,IAAKzJ,EAAKtJ,IAAK8F,IAAUnF,EAEvB9B,MAUFiV,EAAAzT,UAAAmV,MAAP,SAAa1P,EAAUwD,GAIrB,aAFOzK,MAAKkU,IAAKzJ,EAAKtJ,IAAK8F,IAEpBjH,MAQFiV,EAAAzT,UAAA6Q,QAAP,cAAAS,GAAA9S,IAEE,OAAO,IAAIiR,GAA+B,SAAAqB,GAExC,GAAI4B,GAAMpB,EAAKoB,GAEf,KAAK,GAAI0C,KAAS1C,GAClB,CACE,GAAI2C,GAAmBxJ,SAAUuJ,GAC7BE,EAAyBD,EAAW,KAAOD,EAC3CjK,EAAsBmK,EAAgBD,EAAWD,CAErD,QAAQtE,EAAShB,KAAK3E,EAAIuH,EAAK0C,MAE7B,IAAKpG,GAAeqB,KAClB,MACF,KAAKrB,GAAeyB,aACXiC,GAAK0C,QAef3B,EAAAzT,UAAAuV,MAAP,SAAaA,GAEX,MAAO/W,MAAKqS,UACTF,OAAO,SAAC8D,GZi+DH,GYj+DItJ,GAAAsJ,EAAA,EAAIA,GAAA,EAAW,OAAAzJ,GAAW1E,SAAUiP,EAAOpK,MAOlDsI,EAAAzT,UAAAwV,YAAP,SAAmB7E,GAEjB,MAAOnS,MAAKqS,UACTF,OAAO,SAAC8D,GZk+DH,GYl+DItJ,GAAAsJ,EAAA,GAAInU,EAAAmU,EAAA,EAAW,QAAC9D,GAAUA,EAAQrQ,EAAO6K,KAClDuH,IAAqB,SAAC+B,GAAW,MAAVA,GAAA,MAarBhB,EAAAzT,UAAAyV,MAAP,SAAapI,GAEX,WAFW,KAAAA,OAAA,GAEJ7O,KAAKqS,UACT6B,IAAI,SAAC+B,GZs+DA,GYt+DCtJ,GAAAsJ,EAAA,GAAInU,EAAAmU,EAAA,GAELxL,EAAmB+B,EAAWkB,KAAKf,EAEvC,IAAIlC,EACJ,CAGE,OAASc,KAFEd,EAAKc,KAAMoB,EAAIkC,GAEX/M,MAAKA,OAYrBmT,EAAAzT,UAAAuN,SAAP,SAAgBpE,GAEd,WAFc,KAAAA,OAAA,GAEP3K,KAAKqS,UACT6B,IAAa,SAAC+B,GZi+DT,GYj+DUtJ,GAAAsJ,EAAA,GAEVxL,EAAmB+B,EAAWkB,KAAMf,EAExC,IAAIlC,EAEF,MAAOA,GAAKsE,SAAUpC,EAAIhC,MAa3BsK,EAAAzT,UAAA0V,YAAP,SAAmBvM,OAAA,KAAAA,OAAA,EAEjB,IAAIuJ,GAAMlU,KAAKkU,IACXzB,IAEJ,KAAK,GAAI9F,KAAMuH,GACf,CACE,GAAIzJ,GAAmB+B,EAAWkB,KAAKf,EAEnClC,KAEFgI,EAAKhI,EAAKsE,SAAUpC,EAAIhC,IAAYuJ,EAAKvH,IAI7C,MAAO8F,IAGXwC,KZ29DyBkC,EAAwChX,EAAoB,GatqErFiX,GbuqEyEjX,EAAoBiB,EAAE+V,GavqE/F,WAwKE,QAAAE,GAAmBpU,GAEjBjD,KAAKsX,QAAU,GAAItC,GACnBhV,KAAKuX,QAAU,GAAIvC,GACnBhV,KAAKwX,OAAS,GAAIxC,GAClBhV,KAAKyX,KAAO,GAAIzC,GAEZjS,EAAGW,UAAUT,IAEfjD,KAAK0W,IAAIzT,GA+9Cf,MAp9CSoU,GAAA7V,UAAAkV,IAAP,SAAWzT,EACTyU,GAWA,WAXA,KAAAA,MAAA,SAAgCtU,GAAK,MAAGA,KAEpCH,YAAiBoU,GAEnBM,EAAMC,SAAa3U,EAAM4U,cAAWvD,GAAWtU,MAI/C2X,EAAMC,SAAY3U,EAAOF,EAAGgB,SAAUd,EAAMyU,UAAWA,GAAa1X,MAG/DA,MAOTe,OAAAC,eAAWqW,EAAA7V,UAAA,YbghELL,IahhEN,WAEE,MAAOnB,MAAK8X,MAAO9X,KAAK8X,MAAMxU,OAAS,IbihEnCpC,YAAY,EACZD,cAAc,Ia3gEpBF,OAAAC,eAAWqW,EAAA7V,UAAA,kBbkhELL,IalhEN,WAEE,MAAOnB,MAAK+X,YAAcvL,EAAWoB,IAAMpB,EAAWmB,MbmhElDzM,YAAY,EACZD,cAAc,Ia5gEboW,EAAA7V,UAAAwW,qBAAP,WAEE,GAAIrQ,GAAgB3H,KAAKiY,SAAWjY,KAAKiY,SAASC,iBAAmB,EACjEC,EAAmBnY,KAAKmY,UAAYrT,EAAU8B,mBAAoB5G,KAAKoY,eAAkB,GACzFd,EAAkBxS,EAAUI,cAC5B+B,EAAcnC,EAAUI,aAI5B,OAFAlF,MAAKqY,eAAiBnW,KAAK8H,IAAI,EAAG9H,KAAKO,MAAMkF,EAAQwQ,EAAWb,GAAWrQ,IAEpEjH,MAOFqX,EAAA7V,UAAA8W,aAAP,WAsBE,MApBAtY,MAAKuY,OAASZ,EAAMa,gBAClBxY,KAAK6L,KACL7L,KAAKqH,MACLrH,KAAKmH,KACLnH,KAAKyY,WACLzY,KAAK0Y,eACL1Y,KAAK2Y,eACL3Y,KAAK4Y,mBACL5Y,KAAK6Y,mBACL7Y,KAAK8Y,YACL9Y,KAAK+Y,gBACL/Y,KAAKgZ,gBACLhZ,KAAKiZ,oBACLjZ,KAAKkZ,oBACLlZ,KAAK0K,UACL1K,KAAK0O,WACL1O,KAAKmZ,eACLnZ,KAAKoZ,YAGApZ,MAYFqX,EAAA7V,UAAA6X,YAAP,SAAmBpS,GAEjB,OAAuB,OAAfjH,KAAK2H,OAAkBV,EAAIqS,cAActZ,KAAK2H,UACtC,OAAb3H,KAAK4H,KAAgBX,EAAIsS,SAASvZ,KAAK4H,OAarCyP,EAAA7V,UAAAgY,aAAP,SAAoB7R,EAAYC,GAE9B,QAAI5H,KAAK2H,QAASC,EAAI2R,SAASvZ,KAAK2H,WAKhC3H,KAAK4H,MAAOD,EAAM8D,QAAQzL,KAAK4H,OAgB9ByP,EAAA7V,UAAAiY,WAAP,SAAkBxS,EAAUmO,GAE1B,WAF0B,KAAAA,OAAA,GAEnBpV,KAAKsX,QAAQnW,IAAK8F,GAAK,EAAOmO,IAWhCiC,EAAA7V,UAAAkY,WAAP,SAAkBzS,EAAUmO,GAE1B,WAF0B,KAAAA,OAAA,GAEnBpV,KAAKuX,QAAQpW,IAAK8F,GAAK,EAAOmO,IAWhCiC,EAAA7V,UAAAmY,YAAP,SAAmB1S,EAAUmO,GAE3B,WAF2B,KAAAA,OAAA,GAEpBpV,KAAKwX,OAAOrW,IAAK8F,GAAK,EAAOmO,IAY/BiC,EAAA7V,UAAAoY,QAAP,SAAe3S,EAAUkO,EAAqBC,GAE5C,WAFuB,KAAAD,MAAA,UAAqB,KAAAC,OAAA,GAErCpV,KAAKyX,KAAKtW,IAAK8F,EAAKkO,EAAWC,IASjCiC,EAAA7V,UAAAqY,SAAP,SAAgB5S,GAEd,MAAOjH,MAAKyX,KAAKnC,OAAQrO,IAUpBoQ,EAAA7V,UAAAuW,UAAP,WAEE,MAA6B,KAAtB/X,KAAK8X,MAAMxU,QAiBb+T,EAAA7V,UAAAsY,WAAP,SAAkBC,EAAyBC,GA0BzC,WA1BgB,KAAAD,OAAA,OAAyB,KAAAC,MAAA,SAErCD,IAAY/Z,KAAK+X,cAEfgC,GAEF/Z,KAAK8X,SAEqB,SAAtB9X,KAAKoY,cAAiD,QAAtBpY,KAAKoY,eAEvCpY,KAAKmY,SAAW,EAChBnY,KAAKoY,aAAe,UAKtBpY,KAAK8X,OAASH,EAAM9P,KAAMmS,IAEA,UAAtBha,KAAKoY,cAAkD,SAAtBpY,KAAKoY,eAExCpY,KAAKmY,SAAW,EAChBnY,KAAKoY,aAAe,WAKnBpY,MAWFqX,EAAA7V,UAAAyY,kBAAP,SAAyBC,OAAA,KAAAA,OAAA,EAEvB,IAAIC,GAAkBna,KAAKoa,oBAQ3B,OANID,KAAWD,GAAYla,KAAK2H,OAAS3H,KAAK4H,OAE5C5H,KAAK2H,MAAQwS,EAAOxS,MAAMA,QAC1B3H,KAAK4H,IAAMuS,EAAOvS,IAAIA,OAGjB5H,MAUFqX,EAAA7V,UAAA6Y,YAAP,SAAmBpT,GAEjB,GAAIU,GAAaV,EAAIU,QACjBC,EAAWD,EAAM2S,IAAKta,KAAKmY,SAAUnY,KAAKoY,aAE9C,OAAO,IAAI3Q,GAASE,EAAOC,IAWtByP,EAAA7V,UAAA+Y,YAAP,SAAmBtT,EAAUY,GAE3B,GAAIF,GAAaV,EAAIqP,SAAUzO,GAC3BD,EAAWD,EAAM2S,IAAKta,KAAKmY,SAAUnY,KAAKoY,aAE9C,OAAO,IAAI3Q,GAASE,EAAOC,IAetByP,EAAA7V,UAAAwG,WAAP,SAAkBf,GAEhB,GAAIjH,KAAK0Z,WAAYzS,GAAK,GAExB,OAAO,CAGT,KAAKjH,KAAKqZ,YAAapS,IAASjH,KAAKwa,gBAAiBvT,GAEpD,OAAO,CAGT,KAAkB,GAAA8F,GAAA,EAAAkJ,EAAAjW,KAAKuY,OAALxL,EAAAkJ,EAAA3S,OAAAyJ,IAAW,CAAxB,GAAI0N,GAAKxE,EAAAlJ,EAEZ,KAAK0N,EAAexT,EAAKwT,EAAMlZ,WAE7B,OAAO,EAIX,OAAO,GAWF8V,EAAA7V,UAAAkZ,gBAAP,SAAuBzT,GAErB,OAAQjH,KAAK2a,oBAAqB1T,GAAMiL,WAYnCmF,EAAA7V,UAAAgZ,gBAAP,SAAuBvT,GAErB,GAAIjH,KAAKyZ,WAAWxS,GAAK,GAEvB,OAAO,CAGT,IAAIjH,KAAK+X,YAEP,OAAO,CAGT,KAAiB,GAAAhL,GAAA,EAAAkJ,EAAAjW,KAAK8X,MAAL/K,EAAAkJ,EAAA3S,OAAAyJ,IAAU,CAAtB,GAAIlF,GAAIoO,EAAAlJ,EAEX,KAAK/M,KAAKyZ,WAAYxS,EAAIqP,SAAUzO,IAElC,OAAO,EAIX,OAAO,GAaFwP,EAAA7V,UAAAoZ,QAAP,SAAe3T,EAAU4T,EAA6BC,GAEpD,WAFuB,KAAAD,OAAA,OAA6B,KAAAC,MAAA,KAE7C9a,KAAK+a,eAAe9T,EAAK,GAAG,EAAM4T,EAAYC,GAAWpW,SAgB3D2S,EAAA7V,UAAAwZ,SAAP,SAAgB/T,EAAU+C,EAAa6Q,EAA6BC,GAElE,WAFqC,KAAAD,OAAA,OAA6B,KAAAC,MAAA,KAE3D9a,KAAK+a,eAAe9T,EAAK+C,GAAK,EAAM6Q,EAAYC,IAalDzD,EAAA7V,UAAAyZ,QAAP,SAAehU,EAAU4T,EAA6BK,GAEpD,WAFuB,KAAAL,OAAA,OAA6B,KAAAK,MAAA,KAE7Clb,KAAK+a,eAAe9T,EAAK,GAAG,EAAO4T,EAAYK,GAAUxW,SAgB3D2S,EAAA7V,UAAA2Z,SAAP,SAAgBlU,EAAU+C,EAAa6Q,EAA6BK,GAElE,WAFqC,KAAAL,OAAA,OAA6B,KAAAK,MAAA,KAE3Dlb,KAAK+a,eAAe9T,EAAK+C,GAAK,EAAO6Q,EAAYK,IAgBnD7D,EAAA7V,UAAAuZ,eAAP,SAAsB9T,EAAU+C,EAAauD,EAAesN,EAA6BO,GAAzF,GAAAtI,GAAA9S,IAEE,YAF0D,KAAA6a,OAAA,OAA6B,KAAAO,MAAA,KAEhF,GAAInK,GAAc,SAAAqB,GAIvB,IAAK,GAFD+I,GAAmB,EAEdnU,EAAO,EAAGA,EAAOkU,EAAQlU,IAOhC,KALK2T,GAAc3T,EAAO,KAExBD,EAAMsG,EAAOtG,EAAIsG,OAAStG,EAAI8L,SAG3BD,EAAKwI,aAAcrU,GAAK,GAAQiL,UACrC,CACE,GAAIV,GAAyBc,EAAShB,IAAKrK,EAE3C,IAAIuK,IAAWhB,EAAeqB,QAAUwJ,GAAYrR,EAElD,WAiBHqN,EAAA7V,UAAA8Z,aAAP,SAAoBrU,EAAUsU,GAA9B,GAAAzI,GAAA9S,IAEE,YAF4B,KAAAub,OAAA,GAErB,GAAItK,GAAkB,SAAAqB,GAE3B,GAAIkJ,GAAevU,EACfwU,EAAqBF,EAASzI,EAAKuF,eAAiB,CAGxD,IAAIvF,EAAKiF,YAIP,KAAO0D,GAAc,GACrB,CAEE,GAAI3I,EAAK9K,WAAYwT,GACrB,CAEE,GAAIjQ,GAAgBuH,EAAKuH,YAAamB,EAGtC,IAAIjQ,EAAKvD,WAAYf,GAEnB,OAAQqL,EAAShB,IAAK/F,IAEpB,IAAKiF,GAAeqB,KAClB,QAKR2J,EAAUA,EAAQzI,OAClB0I,QAQF,MAAOA,GAAc,GACrB,CAEE,GAAI3I,EAAK9K,WAAYwT,GAGnB,IAAiB,GAAAzO,GAAA,EAAAkJ,EAAAnD,EAAKgF,MAAL/K,EAAAkJ,EAAA3S,OAAAyJ,IAAU,CAAtB,GAAIlF,GAAIoO,EAAAlJ,GAEPxB,EAAgBuH,EAAKyH,YAAaiB,EAAS3T,EAI/C,IAAI0D,EAAKvD,WAAYf,KAAU6L,EAAK2G,WAAYlO,EAAK5D,OAAO,GAE1D,OAAQ2K,EAAShB,IAAK/F,IAEpB,IAAKiF,GAAeqB,KAClB,YAoBR,IAVAiB,EAAK6H,oBAAoBa,EAASvU,GAAKoL,QAAQ,SAAC9G,EAAMmQ,GAEpD,OAAQpJ,EAAShB,IAAK/F,IAEpB,IAAKiF,GAAeqB,KAClB6J,EAAa9J,UAKfU,EAASd,SAAWhB,EAAeqB,KAErC,MAIJ2J,GAAUA,EAAQzI,OAClB0I,QAaDpE,EAAA7V,UAAAma,YAAP,SAAmB1U,GAEjB,QAASjH,KAAKsb,aAAcrU,GAAK,GAAOvC,MAAO,SAAA6G,GAAQ,MAAAA,GAAK5D,MAAMiU,WAAY3U,MAazEoQ,EAAA7V,UAAAqa,UAAP,SAAiB5U,GAEf,OAAQjH,KAAKsb,aAAcrU,GAAK,GAAOiL,WAWlCmF,EAAA7V,UAAAsa,WAAP,SAAkB7U,GAEhB,QAASjH,KAAKsb,aAAcrU,GAAK,GAAOvC,MAAO,SAAA6G,GAAQ,MAAAA,GAAKzD,SAAUb,MAWjEoQ,EAAA7V,UAAAua,aAAP,SAAoBxa,EAAuBya,GAIzC,MAFAhc,MAAMuB,GAAaoW,EAAMqE,UAAWA,EAAWza,GAExCvB,MAUFqX,EAAA7V,UAAAya,YAAP,SAAmBpU,EAAWqU,OAAA,KAAAA,OAAA,EAE5B,IAAIzR,GAAmBzK,KAAKmc,cAK5B,OAHAnc,MAAKsX,QAAQZ,IAAK7O,EAAMqU,EAAUzR,GAClCzK,KAAKuX,QAAQb,IAAK7O,GAAOqU,EAAUzR,GAE5BzK,MAWFqX,EAAA7V,UAAA4a,aAAP,SAAoBvU,EAAWwU,GAI7B,WAJ6B,KAAAA,OAAA,GAE7Brc,KAAKwX,OAAOd,IAAK7O,EAAMwU,EAAWrc,KAAKmc,gBAEhCnc,MAWFqX,EAAA7V,UAAAgV,WAAP,SAAkB3O,EAAYyU,OAAA,KAAAA,OAAA,EAI5B,KAAK,GAFDC,IAAiB,EAEZjc,EAAI,EAAGA,EAAIN,KAAK8X,MAAMxU,SAAWiZ,EAAOjc,KAE3Cic,EAAQ1U,EAAKqH,QAASlP,KAAK8X,MAAOxX,MAEpCN,KAAK8X,MAAMpD,OAAQpU,EAAG,EAgB1B,OAZIic,KAEED,GAEFtc,KAAKuX,QAAQf,WAAY3O,GAG3B7H,KAAKsX,QAAQd,WAAY3O,GACzB7H,KAAKwX,OAAOhB,WAAY3O,GACxB7H,KAAKyX,KAAKjB,WAAY3O,IAGjB0U,GAcFlF,EAAA7V,UAAA+T,KAAP,SAAYQ,EAAaD,EAAgB2B,GAEvC,QAAKzX,KAAKwc,gBAAiBzG,KAAYD,IAE9B9V,KAAKyc,aAAc3G,EAAUC,IAejCsB,EAAA7V,UAAAqU,SAAP,SAAgBC,EAAgBC,GAI9B,IAAK,GAFDwG,IAAiB,EAEZjc,EAAI,EAAGA,EAAIN,KAAK8X,MAAMxU,SAAWiZ,EAAOjc,KAE3Cic,EAAQzG,EAAS5G,QAASlP,KAAK8X,MAAOxX,MAExCN,KAAK8X,MAAMpD,OAAQpU,EAAG,EAAGyV,EAc7B,OAVIwG,KAEFvc,KAAKuX,QAAQ1B,SAAUC,EAAUC,GACjC/V,KAAKsX,QAAQzB,SAAUC,EAAUC,GACjC/V,KAAKwX,OAAO3B,SAAUC,EAAUC,GAChC/V,KAAKyX,KAAK5B,SAAUC,EAAUC,GAE9B/V,KAAKia,mBAAmB,IAGnBsC,GAcFlF,EAAA7V,UAAAib,aAAP,SAAoB3G,EAAeC,GAEjC,GAAItL,GAAmBzK,KAAKmc,cAE5Bnc,MAAKsX,QAAQZ,IAAKZ,GAAU,EAAMrL,GAClCzK,KAAKsX,QAAQZ,IAAKX,GAAQ,EAAOtL,GAEjCzK,KAAKuX,QAAQb,IAAKX,GAAQ,EAAMtL,GAChCzK,KAAKuX,QAAQb,IAAKZ,GAAU,EAAOrL,GAE/BzK,KAAKwX,OAAOrW,IAAK2U,GAAU,KAAY9V,KAAKwX,OAAOrW,IAAK4U,GAAQ,KAElE/V,KAAKwX,OAAOd,IAAKX,GAAQ,EAAMtL,GAE3BzK,KAAKwX,OAAOnC,cAAeS,KAAerL,GAE5CzK,KAAKwX,OAAOb,MAAOb,EAAUrL,GAIjC,IAAIgN,GAAUzX,KAAKyX,KAAKtW,IAAK2U,EAAU,KAYvC,OAVI2B,IAAQA,IAASzX,KAAKyX,KAAKtW,IAAK4U,EAAQ,QAE1C/V,KAAKyX,KAAKf,IAAKX,EAAQ0B,EAAMhN,GAEzBzK,KAAKyX,KAAKpC,cAAeS,KAAerL,GAE1CzK,KAAKyX,KAAKd,MAAOb,EAAUrL,KAIxB,GAeF4M,EAAA7V,UAAAgb,gBAAP,SAAuBzG,EAAa2G,GAElC,OAFkC,KAAAA,OAAA,IAE7B1c,KAAK2c,gBAER,OAAO,CAGT,KAAkB,GAAA5P,GAAA,EAAAkJ,EAAAjW,KAAKuY,OAALxL,EAAAkJ,EAAA3S,OAAAyJ,IAAW,CAAxB,GAAI0N,GAAKxE,EAAAlJ,GAER1I,EAAqBoW,EAAMlZ,SAC3BO,EAAQiU,EAAQ1R,GAChB2X,EAA4BrE,EAAMqE,WAAYla,GAAQuC,EAE1DrE,MAAMqE,GAAS2X,EAGS,IAAtBhc,KAAK8X,MAAMxU,QAAgBoZ,IAE7B1c,KAAK8X,OAAS/B,EAAO6G,WAGvB5c,KAAKsY,cAEL,IAAI/M,GAAgBvL,KAAKoa,oBAYzB,OAVIpa,MAAK2H,QAEP3H,KAAK2H,MAAQ4D,EAAK5D,MAAMA,SAGtB3H,KAAK4H,MAEP5H,KAAK4H,IAAM2D,EAAK3D,IAAIA,QAGf,GAUFyP,EAAA7V,UAAA4Y,mBAAP,WAEE,IAAKpa,KAAK2c,gBAER,MAAO,KAGT,IAAIE,GAAmB3R,EAAI0D,MAAO5O,KAAK6L,KAAK5I,MAAM,GAAI,EAAG,GACrD0E,EAAa3H,KAAK+a,eAAgB8B,EAAa,GAAG,GAAM,EAAM,KAAMnY,OAExE,OAAKiD,GAKE3H,KAAK+X,YACV/X,KAAKqa,YAAa1S,GAClB3H,KAAKua,YAAa5S,EAAO3H,KAAK8X,MAAO,IAL9B,MAqBJT,EAAA7V,UAAAmb,cAAP,WAGE,QAAI3c,KAAK8X,MAAMxU,OAAS,OAMnBtD,KAAKuX,QAAQrF,cAMblS,KAAK8c,mBAMN9c,KAAK+c,yBAML/c,KAAKgd,kBAAmBhd,KAAKid,2BAM7Bjd,KAAKgd,iBAAmBhd,KAAKkd,uBAAyBld,KAAKmd,yBAM3Dnd,KAAKod,uBAAwBpd,KAAKmd,2BAajC9F,EAAA7V,UAAAsb,aAAP,WAEE,MAAO9c,MAAKqd,kBAAmBrd,KAAK6L,OAO/BwL,EAAA7V,UAAAwb,cAAP,WAEE,MAAOhd,MAAKqd,kBAAmBrd,KAAKqH,QAS/BgQ,EAAA7V,UAAAyb,mBAAP,WAEE,MAAOjd,MAAKqd,kBAAmBrd,KAAK0O,aAClC1O,KAAKqd,kBAAmBrd,KAAKmZ,iBAQ1B9B,EAAA7V,UAAA2b,kBAAP,WAEE,MAAOnd,MAAKqd,kBAAmBrd,KAAK0K,YAQ/B2M,EAAA7V,UAAAub,kBAAP,WAEE,MAAO/c,MAAKqd,kBAAmBrd,KAAKoZ,YAY/B/B,EAAA7V,UAAA0b,oBAAP,WAEE,MAAOld,MAAKqd,kBAAmBrd,KAAK+Y,kBAClC/Y,KAAKqd,kBAAmBrd,KAAKgZ,kBAC7BhZ,KAAKqd,kBAAmBrd,KAAK8Y,cAC7B9Y,KAAKqd,kBAAmBrd,KAAKkZ,sBAC7BlZ,KAAKqd,kBAAmBrd,KAAKiZ,sBAa1B5B,EAAA7V,UAAA4b,mBAAP,WAEE,MAAOpd,MAAKqd,kBAAmBrd,KAAK2Y,iBAClC3Y,KAAKqd,kBAAmBrd,KAAK0Y,iBAC7B1Y,KAAKqd,kBAAmBrd,KAAKmH,OAC7BnH,KAAKqd,kBAAmBrd,KAAKyY,aAC7BzY,KAAKqd,kBAAmBrd,KAAK4Y,qBAC7B5Y,KAAKqd,kBAAmBrd,KAAK6Y,qBAQ1BxB,EAAA7V,UAAA6b,kBAAP,SAAyBrB,GAEvB,MAAOjZ,GAAGC,QAASgZ,EAAU/Y,QAAkD,IAA5B+Y,EAAU/Y,MAAOK,QAqB/D+T,EAAA7V,UAAA8b,SAAP,SAAgBC,EACdhC,EACAiC,EACAC,EACA3F,EACA4F,GALF,GAAA5K,GAAA9S,SACE,KAAAub,OAAA,OAEA,KAAAkC,MAAAD,OACA,KAAA1F,OAAA,OACA,KAAA4F,MAAA,IAEA,IAAIjT,GAAmBzK,KAAKmc,eAExBwB,EAAe,SAAC1W,EAAU2W,GAM5B,IAAK,GAJD3G,GAAmBnE,EAAKwI,aAAcrU,EAAKsU,GAAS/I,OACpDqL,EAAe/F,EAAQb,EAAM3T,OAASpB,KAAK+H,IAAK,EAAGgN,EAAM3T,QACzDwa,EAAiBhG,EAAQ,EAAIb,EAAM3T,OAAS,EAEvChD,EAAI,EAAGA,EAAIud,EAAMvd,IAC1B,CACE,GAAIiL,GAAgB0L,EAAO3W,EAAIwd,GAC3BnR,EAAsBlC,EAAKtJ,IAAKoK,EAAK5D,MAEzC,IAAIiW,EAAOtM,KAAO/F,EAAMtE,EAAK0F,MAAW6D,EAAeqB,KAErD,OAAO,EAIX,OAAO,GAGLkB,EAAO,GAAI9B,GAA6B,SAAAqB,GAI1C,IAAK,GAFDhF,GAAYiQ,EAEPjd,EAAI,EAAGA,EAAIod,GAEbC,EAAcrQ,EAAMgF,GAFKhS,IAO9BgN,EAAOA,EAAKyF,SAIZxF,EAAO,GAAI0D,GAA6B,SAAAqB,GAI1C,IAAK,GAFDhF,GAAYiQ,EAEPjd,EAAI,EAAGA,EAAIod,IAElBpQ,EAAOA,EAAKC,OAEPoQ,EAAcrQ,EAAMgF,IAJKhS,OAWlC,OAAOyS,GAAKH,KAAM6K,EAAa,GAAIlK,UAAUL,OAAQ3F,EAAKqF,KAAM4K,KAW3DnG,EAAA7V,UAAAmZ,oBAAP,SAA2B1T,EAAU8W,GAArC,GAAAjL,GAAA9S,SAAqC,KAAA+d,MAAA9W,EAEnC,IAAI+W,GAAiB,SAAC5M,GAEf,GAAAzE,GAAAyE,EAAA,EAEL,OAFSA,GAAA,IAEU5E,EAAWmB,KAAKjB,GAAIC,IAGrCsR,EAAU,SAAC7M,GAER,GAAAzE,GAAAyE,EAAA,GACDvJ,EAAY2E,EAAWmB,KAAKhG,MAAOgF,GACnCpB,EAAgBuH,EAAKyH,YAAa1S,EAAMA,EAAK+U,SAEjD,IAAIrR,EAAKvD,WAAY+V,GAEnB,MAAOxS,GAIX,OAAOvL,MAAKuX,QAAQR,MAAO9P,EAAIqI,eAAgB4E,IAAc+J,EAASD,IAQjE3G,EAAA7V,UAAA6P,MAAP,WAEE,MAAO,IAAIgG,GAAarX,KAAK6X,YAkBxBR,EAAA7V,UAAAqW,QAAP,SAAeqG,EAA6BC,EAA8BC,EAAyBC,OAApF,KAAAH,OAAA,OAA6B,KAAAC,OAAA,OAA8B,KAAAC,MAAA,QAAyB,KAAAC,OAAA,EAUjG,KAAiB,GARbC,GAAsBxZ,EAAU4B,sBAAuB1G,KAAK+X,aAC5DwG,EAAgCve,KAAKsX,QAAQN,YAAY,SAAAwH,GAAK,MAAAA,KAAGhM,OACjEiM,EAAgCze,KAAKuX,QAAQP,YAAY,SAAAwH,GAAK,MAAAA,KAAGhM,OACjEkM,EAA6B1e,KAAKwX,OAAOR,YAAY,SAAAwH,GAAK,MAAAA,KAAGhM,OAC7DmM,GAAoB3e,KAAKyX,KAAKvF,UAC9BO,KACAqF,KAEa/K,EAAA,EAAAkJ,EAAAjW,KAAK8X,MAAL/K,EAAAkJ,EAAA3S,OAAAyJ,IAAU,CAAtB,GAAIlF,GAAIoO,EAAAlJ,EAEX+K,GAAMrK,KAAM0Q,EAActW,EAAQuW,EAAavW,EAAKwD,OAAQ+S,GAAevW,EAAK+W,YA8BlF,MA3BI5e,MAAK2H,QAAO8K,EAAI9K,MAAQuW,EAAale,KAAK2H,MAAQ3H,KAAK2H,MAAME,MAC7D7H,KAAK4H,MAAK6K,EAAI7K,IAAMsW,EAAale,KAAK4H,IAAM5H,KAAK4H,IAAIC,MACrDiQ,EAAMxU,SAAQmP,EAAIqF,MAAQA,IAC1BuG,GAAkBre,KAAKmY,WAAarT,EAAUyB,oBAAkBkM,EAAI0F,SAAWnY,KAAKmY,WACpFkG,GAAkBre,KAAKoY,eAAiBkG,KAAa7L,EAAI2F,aAAepY,KAAKoY,cAC7EmG,EAAWjb,SAAQmP,EAAI6E,QAAUiH,GACjCE,EAAWnb,SAAQmP,EAAI8E,QAAUkH,GACjCC,EAAQpb,SAAQmP,EAAI+E,OAASkH,GAC7BC,IAASlM,EAAIgF,KAAO1U,EAAGmB,UAAYlE,KAAKyX,KAAKvD,MAC7ClU,KAAK0K,UAAUzH,QAAOwP,EAAI/H,UAAY1K,KAAK0K,UAAUzH,OACrDjD,KAAK0O,WAAWzL,QAAOwP,EAAI/D,WAAa1O,KAAK0O,WAAWzL,OACxDjD,KAAKmZ,eAAelW,QAAOwP,EAAI0G,eAAiBnZ,KAAKmZ,eAAelW,OACpEjD,KAAKoZ,UAAUnW,QAAOwP,EAAI2G,UAAYpZ,KAAKoZ,UAAUnW,OACrDjD,KAAK6L,KAAK5I,QAAOwP,EAAI5G,KAAO7L,KAAK6L,KAAK5I,OACtCjD,KAAKqH,MAAMpE,QAAOwP,EAAIpL,MAAQrH,KAAKqH,MAAMpE,OACzCjD,KAAKmH,KAAKlE,QAAOwP,EAAItL,KAAOnH,KAAKmH,KAAKlE,OACtCjD,KAAKyY,WAAWxV,QAAOwP,EAAIgG,WAAazY,KAAKyY,WAAWxV,OACxDjD,KAAK2Y,eAAe1V,QAAOwP,EAAIkG,eAAiB3Y,KAAK2Y,eAAe1V,OACpEjD,KAAK0Y,eAAezV,QAAOwP,EAAIiG,eAAiB1Y,KAAK0Y,eAAezV,OACpEjD,KAAK6Y,mBAAmB5V,QAAOwP,EAAIoG,mBAAqB7Y,KAAK6Y,mBAAmB5V,OAChFjD,KAAK4Y,mBAAmB3V,QAAOwP,EAAImG,mBAAqB5Y,KAAK4Y,mBAAmB3V,OAChFjD,KAAK8Y,YAAY7V,QAAOwP,EAAIqG,YAAc9Y,KAAK8Y,YAAY7V,OAC3DjD,KAAK+Y,gBAAgB9V,QAAOwP,EAAIsG,gBAAkB/Y,KAAK+Y,gBAAgB9V,OACvEjD,KAAKgZ,gBAAgB/V,QAAOwP,EAAIuG,gBAAkBhZ,KAAKgZ,gBAAgB/V,OACvEjD,KAAKiZ,oBAAoBhW,QAAOwP,EAAIwG,oBAAsBjZ,KAAKiZ,oBAAoBhW,OACnFjD,KAAKkZ,oBAAoBjW,QAAOwP,EAAIyG,oBAAsBlZ,KAAKkZ,oBAAoBjW,OAEhFwP,GAuBF4E,EAAA7V,UAAAuN,SAAP,SAAgB8P,EACdC,EACAC,EACAC,EACAC,EACAC,EACAC,OANc,KAAAN,MAAA,aACd,KAAAC,OAAA,OACA,KAAAC,OAAA,OACA,KAAAC,OAAA,OACA,KAAAC,OAAA,OACA,KAAAC,OAAA,OACA,KAAAC,OAAA,EAEA,IAAI1M,GAAc,EA6DlB,IA3DIqM,IAEE9e,KAAK2H,OAEP8K,GAAO,eAAiBzS,KAAK2H,MAAM0D,OAAO,iBAEtCrL,KAAK4H,MAEP6K,GAAO,kBAAoBzS,KAAK4H,IAAIyD,OAAO,mBAGtCrL,KAAK4H,MAEZ6K,GAAO,YAAczS,KAAK4H,IAAIyD,OAAO,mBAMvCoH,GAFEA,EAEK,QAAUoM,EAAQ,cAIlB,OAASA,EAAQ,cAG1BpM,GAAOzS,KAAKof,aAAcpf,KAAK0K,UAAUzH,MAAO,kBAAmB,SAAAG,GAAK,MAAA+T,GAAA,WAAkB/T,IAAI,GAAG,GACjGqP,GAAOzS,KAAKof,aAAcpf,KAAKmZ,eAAelW,MAAO,wBAAyB,SAAAG,GAAK,MAAAqN,GAAO4O,MAAMjc,KAChGqP,GAAOzS,KAAKof,aAAcpf,KAAK0O,WAAWzL,MAAO,mBAAoB,SAAAG,GAAK,MAAAqN,GAAO4O,MAAMjc,KACvFqP,GAAOzS,KAAKof,aAAcpf,KAAKoZ,UAAUnW,MAAO,kBAAmB,SAAAG,GAAK,MAAAqN,GAAO4O,MAAMjc,IAAI,GACzFqP,GAAOzS,KAAKof,aAAcpf,KAAK6L,KAAK5I,MAAO,OAAQ,SAAAG,GAAK,MAAAA,IAAG,GAAG,EAAO,QACrEqP,GAAOzS,KAAKof,aAAcpf,KAAKqH,MAAMpE,MAAO,QAAS,SAAAG,GAAK,MAAA+T,GAAA,SAAgB/T,IAAI,GAAG,EAAO,QACxFqP,GAAOzS,KAAKof,aAAcpf,KAAKyY,WAAWxV,MAAO,mBAAoB,SAAAG,GAAK,MAAAqN,GAAO4O,MAAMjc,KACvFqP,GAAOzS,KAAKof,aAAcpf,KAAK2Y,eAAe1V,MAAO,uBAAwB,SAAAG,GAAK,MAAAqN,GAAO4O,MAAMjc,EAAI,IAAI,GACvGqP,GAAOzS,KAAKof,aAAcpf,KAAK0Y,eAAezV,MAAO,wBAAyB,SAAAG,GAAK,MAAAqN,GAAO4O,MAAMjc,KAChGqP,GAAOzS,KAAKof,aAAcpf,KAAK6Y,mBAAmB5V,MAAO,4BAA6B,SAAAG,GAAK,MAAAqN,GAAO4O,MAAMjc,EAAI,IAAI,GAChHqP,GAAOzS,KAAKof,aAAcpf,KAAK4Y,mBAAmB3V,MAAO,6BAA8B,SAAAG,GAAK,MAAAqN,GAAO4O,MAAMjc,KACzGqP,GAAOzS,KAAKof,aAAcpf,KAAK8Y,YAAY7V,MAAO,oBAAqB,SAAAG,GAAK,MAAAqN,GAAO4O,MAAMjc,KACzFqP,GAAOzS,KAAKof,aAAcpf,KAAKgZ,gBAAgB/V,MAAO,yBAA0B,SAAAG,GAAK,MAAAqN,GAAO4O,MAAMjc,KAClGqP,GAAOzS,KAAKof,aAAcpf,KAAK+Y,gBAAgB9V,MAAO,wBAAyB,SAAAG,GAAK,MAAAqN,GAAO4O,MAAMjc,EAAI,IAAI,GACzGqP,GAAOzS,KAAKof,aAAcpf,KAAKkZ,oBAAoBjW,MAAO,8BAA+B,SAAAG,GAAK,MAAAqN,GAAO4O,MAAMjc,KAC3GqP,GAAOzS,KAAKof,aAAcpf,KAAKiZ,oBAAoBhW,MAAO,6BAA8B,SAAAG,GAAK,MAAAqN,GAAO4O,MAAMjc,EAAI,IAAI,GAE9G2b,GAAgB/e,KAAK8X,MAAMxU,SAE7BmP,GAAO,OACPA,GAAOzS,KAAKsf,cAAetf,KAAK8X,MAAO,SAAA1U,GAAK,MAAAA,GAAEiI,OAAO,cAGnD2T,GAAmBhf,KAAKmY,WAAarT,EAAUyB,mBAEjDkM,GAAO,YAAczS,KAAKmY,SAAW,IAEjCnY,KAAKoY,eAEP3F,GAAOzS,KAAKoY,aAAe,MAI3B6G,EACJ,CACE,GAAIM,GAA4Cvf,KAAKsX,QAAQL,QAAQzE,MAEjE+M,GAASjc,SAEXmP,GAAO,cACPA,GAAOzS,KAAKsf,cAAeC,EAAU,SAAAnc,GAAK,MAAAA,GAAEmI,KAAKf,QAAQ5F,EAAMgH,QAInE,GAAIsT,EACJ,CACE,GAAIM,GAA4Cxf,KAAKuX,QAAQN,QAAQzE,MAEjEgN,GAASlc,SAEXmP,GAAO,cACPA,GAAOzS,KAAKsf,cAAeE,EAAU,SAAApc,GAAK,MAAAA,GAAEmI,KAAKf,QAAQ5F,EAAMgH,QAInE,GAAIuT,EACJ,CACE,GAAIT,GAA2C1e,KAAKwX,OAAOP,QAAQzE,MAE/DkM,GAAQpb,SAEVmP,GAAO,0BACPA,GAAOzS,KAAKsf,cAAeZ,EAAS,SAAAtb,GAAK,MAAAA,GAAEmI,KAAKf,QAAQ5F,EAAMgH,QAIlE,MAAO6G,IAkBD4E,EAAA7V,UAAA4d,aAAR,SAAqBtd,EAAuB2d,EAAcvL,EAAyBwL,EAAyBC,EAAqBC,EAAqBC,OAAnE,KAAAH,MAAA,OAAyB,KAAAC,OAAA,OAAqB,KAAAC,MAAA,YAAqB,KAAAC,OAAA,EAEpJ,IAAIpN,GAAc,GACd1B,EAAiB4O,EAAM,IAAMF,EAAO,EAExC,IAAI1c,EAAGa,sBAAsB9B,GAC7B,CACE,GAAIge,GAAuDhe,CAE3D2Q,IAAO,UAAYhC,EAAO4O,MAAOS,EAAWjc,OAAU,IAAM4b,EAExDK,EAAWhC,SAEbrL,GAAO,gBAAkByB,EAAK4L,EAAWhC,OAAS4B,GAAgB3O,OAGjE,IAAIhO,EAAGe,sBAAsBhC,GAClC,CACE,GAAIie,GAAqDje,CAErDie,GAASzc,SAEXmP,GAAOmN,GAAMD,EAAM,OAAS,IAC5BlN,GAAOzS,KAAKsf,cAAeS,EAAU7L,GACrCzB,GAAO1B,OAGF8O,KAEPpN,GAAQmN,EAAK,OAASH,EAGxB,OAAOhN,IAWD4E,EAAA7V,UAAA8d,cAAR,SAAyBU,EAAY9L,GAEnC,GAAIzB,GAAc,GACdoL,EAAemC,EAAM1c,OAAS,CAElCmP,IAAOyB,EAAK8L,EAAO,GAEnB,KAAK,GAAI1f,GAAI,EAAGA,EAAIud,EAAMvd,IAExBmS,GAAO,KAAOyB,EAAK8L,EAAO1f,GAQ5B,OALIud,GAAO,IAETpL,GAAO,QAAUyB,EAAK8L,EAAOnC,KAGxBpL,GAWK4E,EAAA4I,OAAd,SAAwBhd,EAAiBiE,OAAA,KAAAA,MAAA,EAEvC,IAAID,GAAWiE,EAAIgV,MAAOjd,EAE1B,OAAKgE,GAKE,GAAIoQ,IACTxL,MAAQ5E,EAAI4E,MACZxE,OAASJ,EAAII,OACbqH,YAAczH,EAAIyH,YAClByJ,SAAUjR,EACVkR,aAAc,SARP,MAsBGf,EAAA8I,QAAd,SAAyBld,EAAiB4E,EAAiBsQ,EAAsBC,OAAtB,KAAAD,MAAA,OAAsB,KAAAC,MAAA,QAE/E,IAAInR,GAAWiE,EAAIgV,MAAOjd,EAE1B,OAAKgE,GAKE,GAAIoQ,IACTxL,MAAQ5E,EAAI4E,MACZxE,OAASJ,EAAII,OACbqH,YAAczH,EAAIyH,YAClBoJ,OAASjQ,GACTsQ,SAAUA,EACVC,aAAcA,IATP,MAmBGf,EAAA+I,QAAd,SAAyB7U,GAEvB,GAAI5D,GAAQ4D,EAAK5D,MACbb,EAAUyE,EAAKzE,UACfuZ,EAAQvZ,EAAUhC,EAAUO,gBAAmB,EAC/Cib,EAASxZ,EAAUhC,EAAUM,iBAAoB,EACjD+S,EAAWkI,EAAQvZ,EAAUhC,EAAUO,eAAkBib,EAASxZ,EAAUhC,EAAUM,gBAAkB0B,EACxGsR,EAA8BiI,EAAQ,OAAUC,EAAS,QAAU,SAEvE,OAAOtgB,MAAKmgB,QAAYxY,EAAOA,EAAMiV,SAAUzE,EAAUC,IAG7Df,MCrzDAkJ,EAAA,WA+BE,QAAAA,GAAmB3I,EAAuB4I,EAAU7T,EAAU8T,OAAA,KAAAA,OAAA,GAE5DzgB,KAAK4X,SAAWA,EAChB5X,KAAKwgB,KAAOA,EACZxgB,KAAK2M,GAAKA,EACV3M,KAAKygB,QAAUA,EAGnB,MAAAF,MC9CAG,EAAA,WA2CE,QAAA/S,GAAmB5G,EAAcF,EAAuC8Z,EAAuCC,OAA9E,KAAA/Z,MAAiB/B,EAAUiB,gBAAY,KAAA4a,MAAiB7b,EAAUmB,gBAAY,KAAA2a,MAAsB9b,EAAUqB,YAE7InG,KAAK+G,KAAOA,EACZ/G,KAAK6G,OAASA,EACd7G,KAAK2gB,OAASA,EACd3gB,KAAK4gB,YAAcA,EA2SvB,MA7QSjT,GAAAnM,UAAA6J,OAAP,SAAcA,GAKZ,IAAK,GAHDwV,GAAmBlT,EAAKmT,WACxBrO,EAAc,GAETnS,EAAI,EAAGA,EAAI+K,EAAO/H,OAAQhD,IACnC,CAGE,IAAK,GAFDygB,IAAmB,EAEdC,EAAI,EAAGA,EAAIH,EAAiBvd,SAAWyd,EAASC,IACzD,CACE,GAAIC,GAAQJ,EAAkBG,GAC1BE,EAAe7V,EAAO1G,UAAWrE,EAAGA,EAAI2gB,EAAME,KAElD,IAAID,EAAK5d,SAAW2d,EAAME,KAC1B,CACE,GAAIC,GAAYH,EAAMlW,QAASmW,EAE3BE,KAEF3O,GAAO2O,EAAUphB,MACjBM,GAAK2gB,EAAME,KAAO,EAClBJ,GAAU,IAKXA,IAEHtO,GAAOpH,EAAOgW,OAAO/gB,IAIzB,MAAOmS,IASF9E,EAAAnM,UAAA0N,QAAP,SAAerH,GAEb,MAAO7H,MAAK+G,OAASc,EAAKd,MACxB/G,KAAK6G,SAAWgB,EAAKhB,QACrB7G,KAAK2gB,SAAW9Y,EAAK8Y,QACrB3gB,KAAK4gB,cAAgB/Y,EAAK+Y,aASvBjT,EAAAnM,UAAA8f,YAAP,SAAmBzZ,GAEjB,MAAO7H,MAAK+G,OAASc,EAAKd,MASrB4G,EAAAnM,UAAA+f,cAAP,SAAqB1Z,GAEnB,MAAO7H,MAAK+G,OAASc,EAAKd,MACxB/G,KAAK6G,SAAWgB,EAAKhB,QAWlB8G,EAAAnM,UAAAggB,cAAP,SAAqB3Z,GAEnB,MAAO7H,MAAK+G,OAASc,EAAKd,MACxB/G,KAAK6G,SAAWgB,EAAKhB,QACrB7G,KAAK2gB,SAAW9Y,EAAK8Y,QASlBhT,EAAAnM,UAAAkV,IAAP,SAAWzT,GAET,GAAIwe,GAAe9T,EAAKuS,MAAOjd,GAC3Bye,IAAmBD,CAUvB,OARIC,KAEF1hB,KAAK+G,KAAO0a,EAAO1a,KACnB/G,KAAK6G,OAAS4a,EAAO5a,OACrB7G,KAAK2gB,OAASc,EAAOd,OACrB3gB,KAAK4gB,YAAca,EAAOb,aAGrBc,GAOF/T,EAAAnM,UAAA0W,eAAP,WAEE,MAAOlY,MAAK+G,KAAOjC,EAAUG,eAC3BjF,KAAK6G,OAAS/B,EAAUE,iBACxBhF,KAAK2gB,OAAS7b,EAAUC,iBACxB/E,KAAK4gB,aAOFjT,EAAAnM,UAAAod,SAAP,WAEE,MAAI5e,MAAK4gB,YAAoB5gB,KAAKqL,OAAO,gBACrCrL,KAAK2gB,OAAe3gB,KAAKqL,OAAO,YAChCrL,KAAK6G,OAAe7G,KAAKqL,OAAO,SAE7BrL,KAAKqL,OAAO,OAOdsC,EAAAnM,UAAAoU,aAAP,WAEE,MAAO5V,MAAK+G,KACI,IAAd/G,KAAK6G,OACS,IAAd7G,KAAK2gB,OACc,IAAnB3gB,KAAK4gB,aAOFjT,EAAAnM,UAAAmgB,SAAP,WAEE,GAAIlP,IACF1L,KAAM/G,KAAK+G,KAOb,OAJI/G,MAAK6G,SAAQ4L,EAAI5L,OAAS7G,KAAK6G,QAC/B7G,KAAK2gB,SAAQlO,EAAIkO,OAAS3gB,KAAK2gB,QAC/B3gB,KAAK4gB,cAAanO,EAAImO,YAAc5gB,KAAK4gB,aAEtCnO,GAUK9E,EAAAuS,MAAd,SAAoBjd,GAElB,MAAO0U,GAAM9P,KAAK5E,IAWN0K,EAAAiU,WAAd,SAAyB/Z,GAEvB,GAAIqH,GAAoBlP,KAAK6hB,MAAMC,KAAMja,EAEzC,KAAKqH,EAEH,MAAO,KAGT,IAAI6S,GAAY1U,SAAS6B,EAAQ,KAAO,EACpCzO,EAAY4M,SAAS6B,EAAQ,KAAO,EACpCvN,EAAY0L,SAAS6B,EAAQ,KAAO,EACpC3O,EAAY8M,SAAS6B,EAAQ,KAAO,CAExC,OAAOlP,MAAK4O,MAAMmT,EAAGthB,EAAGkB,EAAGpB,IAUfoN,EAAAgI,eAAd,SAA6B9N,GAE3B,GAAIka,GAAYla,EAAO,IACnBpH,EAAYyB,KAAKK,MAAMsF,EAAO,KAAO,IACrClG,EAAYO,KAAKK,MAAMsF,EAAO,KAAS,IACvCtH,EAAY2B,KAAKK,MAAMsF,EAAO,KAAY,GAE9C,OAAO7H,MAAK4O,MAAMmT,EAAGthB,EAAGkB,EAAGpB,IAafoN,EAAAiB,MAAd,SAAoB7H,EAAcF,EAAuC8Z,EAAuCC,GAE9G,WAFgC,KAAA/Z,MAAiB/B,EAAUiB,gBAAY,KAAA4a,MAAiB7b,EAAUmB,gBAAY,KAAA2a,MAAsB9b,EAAUqB,YAEvI,GAAIwH,GAAK5G,EAAMF,EAAQ8Z,EAAQC,IAzS1BjT,EAAAkU,MAAQ,0CA+SRlU,EAAAmT,aAEVK,KAAM,EACNpW,SACEiX,IAAK,SAACC,GAAY,MAAAlf,GAAG0B,UAAUwd,EAAErB,YAAa,OAIhDO,KAAM,EACNpW,SACEmX,GAAI,SAACD,GAAY,MAAAlf,GAAG0B,UAAUwd,EAAElb,KAAM,IACtCob,GAAI,SAACF,GAAY,MAAAlf,GAAG0B,UAAWwd,EAAElb,KAAO,IAAO,GAAI,IACnDqb,GAAI,SAACH,GAAY,MAAAlf,GAAG0B,UAAUwd,EAAElb,KAAO,EAAG,IAC1Csb,GAAI,SAACJ,GAAY,MAAAlf,GAAG0B,UAAUwd,EAAEpb,OAAQ,IACxCyb,GAAI,SAACL,GAAY,MAAAlf,GAAG0B,UAAUwd,EAAEtB,OAAQ,IACxC4B,GAAI,SAACN,GAAY,MAAAlf,GAAG0B,UAAUwd,EAAErB,YAAa,EAAG,OAIlDO,KAAM,EACNpW,SACEyX,EAAG,SAACP,GAAY,MAAAA,GAAElb,KAAO,GAAK,KAAO,MACrC/C,EAAG,SAACie,GAAY,MAAAA,GAAElb,KAAO,GAAK,KAAO,MACrC0b,EAAG,SAACR,GAAY,MAAAA,GAAElb,KAAO,IACzBgb,EAAG,SAACE,GAAY,OAAEA,EAAElb,KAAO,IAAO,IAAM,IACxCia,EAAG,SAACiB,GAAY,MAACA,GAAElb,KAAO,EAAK,IAC/BtG,EAAG,SAACwhB,GAAY,MAAAA,GAAEpb,OAAS,IAC3BlF,EAAG,SAACsgB,GAAY,MAAAA,GAAEtB,OAAS,IAC3B+B,EAAG,SAACT,GAAY,MAAAlf,GAAG0B,UAAUwd,EAAErB,YAAa,EAAG,OAKvDjT,KC7VAgK,EAAA,mBAAAgL,MAyVA,MA9UgBA,GAAA3G,UAAd,SAAwB/Y,EAAY1B,GAElC,GAAIkZ,GAAwB,SAAC3Y,GAC3B,OAAO,EAKT,IAFA2Y,EAAMmI,OAAQ,EAEV7f,EAAGa,sBAAsBX,GAC7B,CACE,GAAI4f,GAAgB5f,EAAMY,MACtBif,GAAkB7f,EAAM6a,QAAU,GAAK+E,CAE3CpI,GAAQ,SAAC3Y,GACP,MAAOA,GAAQ+gB,IAAUC,GAE3BrI,EAAMmI,OAAQ,EAGhB,GAAI7f,EAAGe,sBAAsBb,GAC7B,CAGE,IAAK,GAFD8f,MAEKziB,EAAI,EAAGA,EAAI2C,EAAMK,OAAQhD,IAChCyiB,EAAK9f,EAAO3C,KAAQ,CAGtBma,GAAQ,SAAC3Y,GACP,QAASihB,EAAKjhB,IAEhB2Y,EAAMmI,OAAQ,EAMhB,MAHAnI,GAAMxX,MAAQF,EAAGgB,SAAUd,EAAO,MAClCwX,EAAMlZ,SAAWA,EAEVkZ,GAkBKkI,EAAA1b,IAAd,SAAkBhE,GAEhB,MAAIF,GAAGS,SAASP,GAEPiI,EAAI8X,KAAc/f,GAElBF,EAAGQ,SAASN,GAEZiI,EAAI0W,WAAoB3e,GAExBA,YAAiBiI,GAEjBjI,EAEAF,EAAGC,QAASC,GAEZiI,EAAI+X,UAAqBhgB,GAEzBF,EAAGU,SAAUR,GAEbiI,EAAIgY,WAAoBjgB,IAEd,IAAVA,EAEAiI,EAAID,QAGN,MAsBK0X,EAAA9a,KAAd,SAAmB5E,GAEjB,MAAIA,aAAiByd,GAEZzd,EAELF,EAAGS,SAASP,GAEPyd,EAAK/K,eAAwB1S,GAElCF,EAAGQ,SAASN,GAEPyd,EAAKkB,WAAoB3e,GAE9BF,EAAGU,SAASR,IAAUF,EAAGS,SAASP,EAAM8D,MAEnC,GAAI2Z,GAAKzd,EAAM8D,KAAM9D,EAAM4D,OAAQ5D,EAAM0d,OAAQ1d,EAAM2d,aAGzD,MAYK+B,EAAA7K,MAAd,SAAoB7U,GAElB,GAAI6U,KAEJ,IAAI/U,EAAGC,QAAQC,GACf,CACE,IAAsB,GAAA8J,GAAA,EAAAoW,EAAAlgB,EAAA8J,EAAAoW,EAAA7f,OAAAyJ,IAAK,CAAtB,GAAIqW,GAASD,EAAApW,GAEZlF,EAAO7H,KAAK6H,KAAMub,EAElBvb,IAEFiQ,EAAMrK,KAAM5F,GAKhBiQ,EAAMuL,KAAK,SAACrf,EAAGC,GAEb,MAAOD,GAAEkU,iBAAmBjU,EAAEiU,mBAIlC,MAAOJ,IAmBK6K,EAAAW,SAAd,SAA0BrgB,EAAYnB,EACpC4V,EACAjF,OADA,KAAAiF,MAAA,SAAgCtU,GAAK,MAAGA,SACxC,KAAAqP,MAAA,GAA+BuC,GAE/B,IAAId,KAEJ,IAAInR,EAAGC,QAAQC,GAEb,IAAuB,GAAA8J,GAAA,EAAAwW,EAAAtgB,EAAA8J,EAAAwW,EAAAjgB,OAAAyJ,IAAK,CAAvB,GAAIyW,GAAUD,EAAAxW,EAEbyW,aAAsBtY,GAExBgJ,EAAKsP,EAAWlU,eAAkBxN,EAE3BiB,EAAGS,SAASggB,GAEnBtP,EAAasP,GAAe1hB,EAErBiB,EAAGQ,SAASigB,KAEnBtP,EAAasP,GAAe1hB,GAKlC,GAAIiB,EAAGU,SAASR,GAEd,IAAK,GAAIugB,KAAcvgB,GAErBiR,EAAKsP,GAAe9L,EAAWzU,EAAOugB,GAM1C,OAFA/Q,GAAIyB,IAAMA,EAEHzB,GAYKkQ,EAAA/K,SAAd,SAA0B3U,EACxByU,EACAjF,GAEA,OAHA,KAAAiF,MAAA,SAAgCtU,GAAK,MAAGA,SACxC,KAAAqP,MAAA,GAAuB2E,IAEnBnU,YAAiBmU,GAEnB,MAAOnU,EAGT,IAAI2c,GAAU5f,KAAKiH,IAAKhE,EAAM2c,IAC1B9H,EAAgB9X,KAAK8X,MAAO7U,EAAM6U,OAClCiC,EAAoC,IAAjBjC,EAAMxU,MAwC7B,OAtCIsc,KAEF3c,EAAM0E,MAAQiY,EAAGjY,QACjB1E,EAAM2E,IAAMgY,EAAGhY,MACf3E,EAAM4I,MAAQ+T,EAAG/T,MACjB5I,EAAMoE,OAASuY,EAAGvY,OAClBpE,EAAMyL,YAAckR,EAAGlR,aAGzB+D,EAAIqF,MAAQA,EACZrF,EAAI0F,SAAWpV,EAAGgB,SAAUd,EAAMkV,SAAUrT,EAAUyB,kBACtDkM,EAAI2F,aAA8BrV,EAAGgB,SAAUd,EAAMmV,aAActT,EAAU4B,sBAAuBqT,IACpGtH,EAAI9K,MAAQ3H,KAAKiH,IAAKhE,EAAM0E,OAC5B8K,EAAI7K,IAAM5H,KAAKiH,IAAKhE,EAAM2E,KAC1B6K,EAAI6E,QAAUtX,KAAKsjB,SAAUrgB,EAAMqU,SAAS,MAAMhD,GAAW7B,EAAI6E,SACjE7E,EAAI8E,QAAUvX,KAAKsjB,SAAUrgB,EAAMsU,SAAS,MAAMjD,GAAW7B,EAAI8E,SACjE9E,EAAI+E,OAASxX,KAAKsjB,SAAUrgB,EAAMuU,QAAQ,MAAMlD,GAAW7B,EAAI+E,QAC/D/E,EAAIgF,KAAOzX,KAAKsjB,SAAUrgB,EAAMwU,KAAM,KAAMC,EAAWjF,EAAIgF,MAC3DhF,EAAI5G,KAAO7L,KAAKgc,UAAW/Y,EAAM4I,KAAM,QACvC4G,EAAIpL,MAAQrH,KAAKgc,UAAW/Y,EAAMoE,MAAO,SACzCoL,EAAItL,KAAOnH,KAAKgc,UAAW/Y,EAAMkE,KAAM,QACvCsL,EAAIgG,WAAazY,KAAKgc,UAAW/Y,EAAMwV,WAAY,cACnDhG,EAAIkG,eAAiB3Y,KAAKgc,UAAW/Y,EAAM0V,eAAgB,kBAC3DlG,EAAIiG,eAAiB1Y,KAAKgc,UAAW/Y,EAAMyV,eAAgB,kBAC3DjG,EAAIoG,mBAAqB7Y,KAAKgc,UAAW/Y,EAAM4V,mBAAoB,sBACnEpG,EAAImG,mBAAqB5Y,KAAKgc,UAAW/Y,EAAM2V,mBAAoB,sBACnEnG,EAAIqG,YAAc9Y,KAAKgc,UAAW/Y,EAAM6V,YAAa,eACrDrG,EAAIsG,gBAAkB/Y,KAAKgc,UAAW/Y,EAAM8V,gBAAiB,mBAC7DtG,EAAIuG,gBAAkBhZ,KAAKgc,UAAW/Y,EAAM+V,gBAAiB,mBAC7DvG,EAAIwG,oBAAsBjZ,KAAKgc,UAAW/Y,EAAMgW,oBAAqB,uBACrExG,EAAIyG,oBAAsBlZ,KAAKgc,UAAW/Y,EAAMiW,oBAAqB,uBACrEzG,EAAI/H,UAAY1K,KAAKgc,UAAW/Y,EAAMyH,UAAW,aACjD+H,EAAI/D,WAAa1O,KAAKgc,UAAW/Y,EAAMyL,WAAY,cACnD+D,EAAI0G,eAAiBnZ,KAAKgc,UAAW/Y,EAAMkW,eAAgB,kBAC3D1G,EAAI2G,UAAYpZ,KAAKgc,UAAW/Y,EAAMmW,UAAW,aACjD3G,EAAIuF,uBACJvF,EAAI6F,eAEG7F,GAUKkQ,EAAAnK,eAAd,SAA6BD,GAI3B,IAAkB,GAFd9F,MAEc1F,EAAA,EAAA0W,EAAAlL,EAAAxL,EAAA0W,EAAAngB,OAAAyJ,IAAM,CAAnB,GAAI0N,GAAKgJ,EAAA1W,EAER0N,GAAMmI,OAERnQ,EAAIhF,KAAMgN,GAId,MAAOhI,IAWKkQ,EAAAe,MAAd,SAA0BzgB,EACxB0gB,EACAjM,GAEA,OAHA,KAAAiM,MAAA,SAAgCvgB,GAAK,MAAGA,SACxC,KAAAsU,MAAA,SAAgCtU,GAAK,MAAGA,KAEpCH,YAAiBsd,GAEnB,MAAOtd,EAGT,KAAKA,EAAM2U,SAET,MAAO,KAGT,IAAIA,GAAwB5X,KAAK4X,SAAa3U,EAAM2U,SAAUF,EAE9D,OAAO,IAAI6I,GAAO3I,EAAU+L,EAAW1gB,EAAMud,MAAQvd,EAAM0J,GAAI1J,EAAMwd,UAMzDkC,EAAAiB,KAAd,SAAsBC,EAAiBpR,GAErC,WAFqC,KAAAA,MAAA,GAAuB2E,IAErD3E,GAGXkQ,KhBu2HyBmB,EAAuC3jB,EAAoB,GiB1qIpF+K,GjB2qIwE/K,EAAoBiB,EAAE0iB,GiB3qI9F,WA6JE,QAAAlW,GAAmBmW,GAEjB/jB,KAAK+jB,KAAuBA,EAC5B/jB,KAAK6H,KAAuBkc,EAAKC,UACjChkB,KAAKwI,OAAuBub,EAAKnD,cACjC5gB,KAAK0I,QAAuBqb,EAAKpD,SACjC3gB,KAAK6G,OAAuBkd,EAAKld,SACjC7G,KAAK+G,KAAuBgd,EAAKhd,OACjC/G,KAAKqH,MAAuB0c,EAAK1c,QACjCrH,KAAK6L,KAAuBkY,EAAKlY,OACjC7L,KAAKkQ,QAAuB6T,EAAK7T,UACjClQ,KAAK0K,UAAuBqZ,EAAK9c,MACjCjH,KAAK0O,WAAuBqV,EAAKA,OACjC/jB,KAAKoZ,UAAuB2K,EAAK3K,YACjCpZ,KAAKmH,KAAuB4c,EAAK5c,OAEjCnH,KAAKmZ,eAAuBvL,EAAIqW,kBAAmBF,GACnD/jB,KAAKyY,WAAuB7K,EAAIsW,cAAeH,GAC/C/jB,KAAK2Y,eAAuB/K,EAAIuW,kBAAmBJ,GACnD/jB,KAAK0Y,eAAuB9K,EAAIwW,kBAAmBL,GACnD/jB,KAAK6Y,mBAAuBjL,EAAIyW,sBAAuBN,GACvD/jB,KAAK4Y,mBAAuBhL,EAAI0W,sBAAuBP,GAEvD/jB,KAAK8Y,YAAuBlL,EAAI2W,eAAgBR,GAChD/jB,KAAK+Y,gBAAuBnL,EAAI4W,mBAAoBT,GACpD/jB,KAAKgZ,gBAAuBpL,EAAI6W,mBAAoBV,GACpD/jB,KAAKiZ,oBAAuBrL,EAAI8W,uBAAwBX,GACxD/jB,KAAKkZ,oBAAuBtL,EAAI+W,uBAAwBZ,GAExD/jB,KAAKmP,eAAuB3C,EAAWmB,KAAKxM,IAAKnB,MACjDA,KAAKsP,cAAuB9C,EAAWoB,IAAIzM,IAAKnB,MAChDA,KAAK2P,eAAuBnD,EAAWqB,KAAK1M,IAAKnB,MACjDA,KAAK+P,gBAAuBvD,EAAWsB,MAAM3M,IAAKnB,MAClDA,KAAKoQ,kBAAuB5D,EAAW2B,QAAQhN,IAAKnB,MAgnBxD,MAxmBS4N,GAAApM,UAAAyG,QAAP,SAAehB,GAEb,MAAOjH,MAAKsP,gBAAkBrI,EAAIqI,eAM7B1B,EAAApM,UAAA6G,UAAP,SAAiBpB,GAEf,MAAOjH,MAAK+P,kBAAoB9I,EAAI8I,iBAM/BnC,EAAApM,UAAA2G,SAAP,SAAgBlB,GAEd,MAAOjH,MAAK2P,iBAAmB1I,EAAI0I,gBAM9B/B,EAAApM,UAAA+G,SAAP,SAAgBtB,GAEd,MAAOjH,MAAK6L,OAAS5E,EAAI4E,MAMpB+B,EAAApM,UAAAojB,YAAP,SAAmB3d,GAEjB,MAAOjH,MAAKoQ,oBAAsBnJ,EAAImJ,mBAMjCxC,EAAApM,UAAAqjB,SAAP,SAAgB5d,GACd,MAAOjH,MAAKsP,gBAAkBrI,EAAIqI,eAAiBtP,KAAK+G,OAASE,EAAIF,MAMhE6G,EAAApM,UAAAoa,WAAP,SAAkB3U,GAChB,MAAOjH,MAAKmP,iBAAmBlI,EAAIkI,gBAM9BvB,EAAApM,UAAA0U,SAAP,SAAgBrO,GACd,MAAO7H,MAAK+G,OAASc,EAAKd,MAAQ/G,KAAK6G,SAAWgB,EAAKhB,QAAU7G,KAAK0I,UAAYb,EAAK8Y,QAAU3gB,KAAKwI,SAAWX,EAAK+Y,aAQjHhT,EAAApM,UAAA+X,SAAP,SAAgBtS,EAAU6d,GACxB,MAAO9kB,MAAK+jB,KAAKxK,SAAUtS,EAAI8c,KAAMe,IAMhClX,EAAApM,UAAAujB,eAAP,SAAsB9d,EAAU6d,GAC9B,MAAO9kB,MAAK+jB,KAAKgB,eAAgB9d,EAAI8c,KAAMe,IAMtClX,EAAApM,UAAAiK,QAAP,SAAexE,EAAU6d,GACvB,MAAO9kB,MAAK+jB,KAAKtY,QAASxE,EAAI8c,KAAMe,IAM/BlX,EAAApM,UAAA8X,cAAP,SAAqBrS,EAAU6d,GAC7B,MAAO9kB,MAAK+jB,KAAKzK,cAAerS,EAAI8c,KAAMe,IAMrClX,EAAApM,UAAAwI,IAAP,SAAW/C,GACT,MAAOjH,MAAK+jB,KAAKtY,QAASxE,EAAI8c,MAAS/jB,KAAOiH,GAMzC2G,EAAApM,UAAAyI,IAAP,SAAWhD,GACT,MAAOjH,MAAK+jB,KAAKxK,SAAUtS,EAAI8c,MAAS/jB,KAAOiH,GAK1C2G,EAAApM,UAAAiH,cAAP,SAAqBxB,EAAUlF,EAAkBC,GAC/C,WAD6B,KAAAD,MAASK,EAAGS,UAAM,KAAAb,OAAA,GACxCH,EAAS7B,KAAK+jB,KAAKiB,KAAM/d,EAAI8c,KAAM,gBAAgB,GAAQhiB,EAAIC,IAGjE4L,EAAApM,UAAAmH,eAAP,SAAsB1B,EAAUlF,EAAkBC,GAChD,WAD8B,KAAAD,MAASK,EAAGS,UAAM,KAAAb,OAAA,GACzCH,EAAS7B,KAAK+jB,KAAKiB,KAAM/d,EAAI8c,KAAM,WAAW,GAAQhiB,EAAIC,IAG5D4L,EAAApM,UAAAoH,eAAP,SAAsB3B,EAAUlF,EAAkBC,GAChD,WAD8B,KAAAD,MAASK,EAAGS,UAAM,KAAAb,OAAA,GACzCH,EAAS7B,KAAK+jB,KAAKiB,KAAM/d,EAAI8c,KAAM,WAAW,GAAQhiB,EAAIC,IAG5D4L,EAAApM,UAAAqH,aAAP,SAAoB5B,EAAUlF,EAAkBC,GAC9C,WAD4B,KAAAD,MAASK,EAAGS,UAAM,KAAAb,OAAA,GACvCH,EAAS7B,KAAK+jB,KAAKiB,KAAM/d,EAAI8c,KAAM,SAAS,GAAQhiB,EAAIC,IAG1D4L,EAAApM,UAAAsH,YAAP,SAAmB7B,EAAUlF,EAAkBC,GAC7C,WAD2B,KAAAD,MAASK,EAAGS,UAAM,KAAAb,OAAA,GACtCH,EAAS7B,KAAK+jB,KAAKiB,KAAM/d,EAAI8c,KAAM,QAAQ,GAAQhiB,EAAIC,IAGzD4L,EAAApM,UAAAuH,aAAP,SAAoB9B,EAAUlF,EAAkBC,GAC9C,WAD4B,KAAAD,MAASK,EAAGS,UAAM,KAAAb,OAAA,GACvCH,EAAS7B,KAAK+jB,KAAKiB,KAAM/d,EAAI8c,KAAM,SAAS,GAAQhiB,EAAIC,IAG1D4L,EAAApM,UAAAwH,cAAP,SAAqB/B,EAAUlF,EAAkBC,GAC/C,WAD6B,KAAAD,MAASK,EAAGS,UAAM,KAAAb,OAAA,GACxCH,EAAS7B,KAAK+jB,KAAKiB,KAAM/d,EAAI8c,KAAM,UAAU,GAAQhiB,EAAIC,IAG3D4L,EAAApM,UAAA0H,aAAP,SAAoBjC,EAAUlF,EAAkBC,GAC9C,WAD4B,KAAAD,MAASK,EAAGS,UAAM,KAAAb,OAAA,GACvCH,EAAS7B,KAAK+jB,KAAKiB,KAAM/d,EAAI8c,KAAM,SAAS,GAAQhiB,EAAIC,IAG1D4L,EAAApM,UAAAyjB,UAAP,SAAiBtd,EAAYC,EAAUsd,GACrC,WADqC,KAAAA,OAAA,GAC9BllB,KAAK+jB,KAAKkB,UAAUtd,EAAMoc,KAAMnc,EAAImc,KAAM,KAAMmB,EAAY,KAAO,OAGrEtX,EAAApM,UAAA2jB,OAAP,SAAcC,GACZ,GAAIzkB,GAAIX,KAAKqlB,UAEb,OADAD,GAASzkB,GACF,GAAIiN,GAAKjN,IAGXiN,EAAApM,UAAA8Y,IAAP,SAAWzH,EAAgB4M,GACzB,MAAOzf,MAAKmlB,OAAO,SAAAxkB,GAAK,MAAAA,GAAE2Z,IAAIzH,EAAuB4M,MAGhD7R,EAAApM,UAAA8jB,SAAP,SAAgB9c,GACd,MAAOxI,MAAKmlB,OAAO,SAAAxkB,GAAK,MAAAA,GAAE2Z,IAAI9R,EAAQ,mBAKjCoF,EAAApM,UAAA+jB,aAAP,SAAoBre,GAClB,MAAOlH,MAAKmlB,OAAO,SAAAxkB,GAAK,MAAAA,GAAE2Z,IAAIpT,EAAM,WAG/B0G,EAAApM,UAAAuR,KAAP,SAAY7L,GACV,WADU,KAAAA,MAAA,GACHlH,KAAKulB,cAAere,IAGtB0G,EAAApM,UAAA+L,KAAP,SAAYrG,GACV,WADU,KAAAA,MAAA,GACHlH,KAAKulB,aAAcre,IAGrB0G,EAAApM,UAAAgkB,eAAP,SAAsBve,GACpB,MAAOjH,MAAKmlB,OAAO,SAAAxkB,GAAK,MAAAA,GAAEojB,KAAK9c,MAG1B2G,EAAApM,UAAAikB,cAAP,SAAqB/a,GACnB,MAAO1K,MAAKmlB,OAAO,SAAAxkB,GAAK,MAAAA,GAAEsG,IAAIyD,MAGzBkD,EAAApM,UAAAkkB,cAAP,SAAqBtM,GACnB,MAAOpZ,MAAKmlB,OAAO,SAAAxkB,GAAK,MAAAA,GAAEyY,UAAUA,MAK/BxL,EAAApM,UAAAmkB,UAAP,SAAiBte,GACf,MAAOrH,MAAKmlB,OAAO,SAAAxkB,GAAK,MAAAA,GAAE0G,MAAMA,MAG3BuG,EAAApM,UAAA2O,eAAP,SAAsB7I,GACpB,MAAOtH,MAAKmlB,OAAO,SAAAxkB,GAAK,MAAAA,GAAE2Z,IAAIhT,EAAQ,aAGjCsG,EAAApM,UAAAokB,UAAP,SAAiBte,GACf,WADe,KAAAA,MAAA,GACRtH,KAAKmQ,gBAAiB7I,IAGxBsG,EAAApM,UAAAqkB,UAAP,SAAiBve,GACf,WADe,KAAAA,MAAA,GACRtH,KAAKmQ,eAAgB7I,IAKvBsG,EAAApM,UAAAiO,SAAP,SAAgBtI,EAAc2e,GAC5B,WAD4B,KAAAA,MAAuB9lB,KAAKmH,MACjDnH,KAAKmlB,OAAO,SAAAxkB,GAAK,MAAAA,GAAE2Z,KAAKnT,EAAO2e,GAAgBhhB,EAAUQ,aAAc,WAGzEsI,EAAApM,UAAAukB,eAAP,SAAsB5e,GACpB,MAAOnH,MAAKyP,SAAStI,EAAMnH,KAAKyY,aAG3B7K,EAAApM,UAAAwkB,mBAAP,SAA0B7e,GACxB,MAAOnH,MAAKyP,SAAStI,EAAMnH,KAAK0Y,iBAG3B9K,EAAApM,UAAAykB,mBAAP,SAA0B9e,GACxB,MAAOnH,MAAKyP,SAAStI,EAAMnH,KAAK2Y,iBAG3B/K,EAAApM,UAAA0kB,gBAAP,SAAuB/e,GACrB,MAAOnH,MAAKyP,SAAStI,EAAMnH,KAAK8Y,cAG3BlL,EAAApM,UAAA2kB,oBAAP,SAA2Bhf,GACzB,MAAOnH,MAAKyP,SAAStI,EAAMnH,KAAK+Y,kBAG3BnL,EAAApM,UAAA4kB,oBAAP,SAA2Bjf,GACzB,MAAOnH,MAAKyP,SAAStI,EAAMnH,KAAKgZ,kBAG3BpL,EAAApM,UAAA6kB,cAAP,SAAqBjf,GACnB,MAAOpH,MAAKmlB,OAAO,SAAAxkB,GAAK,MAAAA,GAAE2Z,IAAIlT,EAAO,YAGhCwG,EAAApM,UAAA8kB,SAAP,SAAgBlf,GACd,WADc,KAAAA,MAAA,GACPpH,KAAKqmB,eAAgBjf,IAGvBwG,EAAApM,UAAA+kB,SAAP,SAAgBnf,GACd,WADc,KAAAA,MAAA,GACPpH,KAAKqmB,cAAejf,IAKtBwG,EAAApM,UAAAglB,SAAP,SAAgB3a,GACd,MAAO7L,MAAKmlB,OAAO,SAAAxkB,GAAK,MAAAA,GAAEkL,KAAKA,MAG1B+B,EAAApM,UAAAilB,cAAP,SAAqBxd,GACnB,MAAOjJ,MAAKmlB,OAAO,SAAAxkB,GAAK,MAAAA,GAAE2Z,IAAIrR,EAAO,WAGhC2E,EAAApM,UAAAklB,SAAP,SAAgBzd,GACd,WADc,KAAAA,MAAA,GACPjJ,KAAKymB,eAAgBxd,IAGvB2E,EAAApM,UAAAmlB,SAAP,SAAgB1d,GACd,WADc,KAAAA,MAAA,GACPjJ,KAAKymB,cAAexd,IAKtB2E,EAAApM,UAAAolB,SAAP,SAAgB7f,GACd,MAAO/G,MAAKmlB,OAAO,SAAAxkB,GAAK,MAAAA,GAAEoG,KAAKA,MAG1B6G,EAAApM,UAAAqlB,cAAP,SAAqB7f,GACnB,MAAOhH,MAAKmlB,OAAO,SAAAxkB,GAAK,MAAAA,GAAE2Z,IAAItT,EAAO,YAGhC4G,EAAApM,UAAAslB,SAAP,SAAgB9f,GACd,WADc,KAAAA,MAAA,GACPhH,KAAK6mB,eAAgB7f,IAGvB4G,EAAApM,UAAAulB,SAAP,SAAgB/f,GACd,WADc,KAAAA,MAAA,GACPhH,KAAK6mB,cAAe7f,IAKtB4G,EAAApM,UAAAwlB,UAAP,SACIjgB,EACAF,EACA8Z,EACAC,GACF,WAJE,KAAA7Z,MAAejC,EAAUe,cACzB,KAAAgB,MAAiB/B,EAAUiB,gBAC3B,KAAA4a,MAAiB7b,EAAUmB,gBAC3B,KAAA2a,MAAsB9b,EAAUqB,YAC3BnG,KAAKmlB,OAAO,SAAAxkB,GAAK,MAAAA,GAAE+V,KAAK3P,KAAIA,EAAEF,OAAMA,EAAE8Z,OAAMA,EAAEC,YAAWA,OAG3DhT,EAAApM,UAAA8U,SAAP,SAAgBzO,GACd,MAAO7H,MAAKgnB,UAAUnf,EAAKd,KAAMc,EAAKhB,OAAQgB,EAAK8Y,OAAQ9Y,EAAK+Y,cAG3DhT,EAAApM,UAAAob,OAAP,WACE,MAAO,IAAI8D,GAAK1gB,KAAK+G,KAAM/G,KAAK6G,OAAQ7G,KAAK0I,QAAS1I,KAAKwI,SAOtDoF,EAAApM,UAAAmG,MAAP,WACE,MAAO3H,MAAKmlB,OAAO,SAAAxkB,GAAK,MAAAA,GAAEsmB,QAAQ,UAG7BrZ,EAAApM,UAAA0lB,QAAP,WACE,MAAOlnB,MAAK+G,OAASjC,EAAUe,UAC7B7F,KAAK6G,SAAW/B,EAAUiB,YAC1B/F,KAAK0I,UAAY5D,EAAUmB,YAC3BjG,KAAKwI,SAAW1D,EAAUqB,YAGvByH,EAAApM,UAAAoG,IAAP,SAAWsd,GACT,WADS,KAAAA,OAAA,GACFA,EACLllB,KAAKmlB,OAAO,SAAAxkB,GAAK,MAAAA,GAAEwmB,MAAM,SACzBnnB,KAAKmlB,OAAO,SAAAxkB,GAAK,MAAAA,GAAEsmB,QAAQ,OAAO3M,IAAI,EAAG,UAGtC1M,EAAApM,UAAA4lB,MAAP,WACE,MAAOpnB,MAAK+G,OAASjC,EAAUgB,UAC7B9F,KAAK6G,SAAW/B,EAAUkB,YAC1BhG,KAAK0I,UAAY5D,EAAUoB,YAC3BlG,KAAKwI,SAAW1D,EAAUsB,YAKvBwH,EAAApM,UAAA6lB,YAAP,WACE,MAAOrnB,MAAKmlB,OAAO,SAAAxkB,GAAK,MAAAA,GAAEsmB,QAAQ,WAG7BrZ,EAAApM,UAAA8lB,cAAP,WACE,MAAOtnB,MAAK6G,SAAW/B,EAAUiB,YAC/B/F,KAAK0I,UAAY5D,EAAUmB,YAC3BjG,KAAKwI,SAAW1D,EAAUqB,YAGvByH,EAAApM,UAAAsN,UAAP,SAAiBoW,GACf,WADe,KAAAA,OAAA,GACRA,EACLllB,KAAKmlB,OAAO,SAAAxkB,GAAK,MAAAA,GAAEwmB,MAAM,UACzBnnB,KAAKmlB,OAAO,SAAAxkB,GAAK,MAAAA,GAAEsmB,QAAQ,QAAQ3M,IAAI,EAAG,WAGvC1M,EAAApM,UAAA+lB,YAAP,WACE,MAAOvnB,MAAK6G,SAAW/B,EAAUkB,YAC/BhG,KAAK0I,UAAY5D,EAAUoB,YAC3BlG,KAAKwI,SAAW1D,EAAUsB,YAKvBwH,EAAApM,UAAAgmB,YAAP,WACE,MAAOxnB,MAAKmlB,OAAO,SAAAxkB,GAAK,MAAAA,GAAEsmB,QAAQ,WAG7BrZ,EAAApM,UAAAimB,cAAP,WACE,MAAOznB,MAAK0K,YAAc5F,EAAUuB,aAG/BuH,EAAApM,UAAAkO,UAAP,SAAiBwV,GACf,WADe,KAAAA,OAAA,GACRA,EACLllB,KAAKmlB,OAAO,SAAAxkB,GAAK,MAAAA,GAAEwmB,MAAM,UACzBnnB,KAAKmlB,OAAO,SAAAxkB,GAAK,MAAAA,GAAEsmB,QAAQ,QAAQ3M,IAAI,EAAG,WAGvC1M,EAAApM,UAAAkmB,YAAP,WACE,MAAO1nB,MAAK0K,YAAc5F,EAAUwB,aAK/BsH,EAAApM,UAAAmmB,aAAP,WACE,MAAO3nB,MAAKmlB,OAAO,SAAAxkB,GAAK,MAAAA,GAAEsmB,QAAQ,YAG7BrZ,EAAApM,UAAAomB,eAAP,WACE,MAAO5nB,MAAK0O,aAAe5J,EAAUa,SAGhCiI,EAAApM,UAAAsO,WAAP,SAAkBoV,GAChB,WADgB,KAAAA,OAAA,GACTA,EACLllB,KAAKmlB,OAAO,SAAAxkB,GAAK,MAAAA,GAAEwmB,MAAM,WACzBnnB,KAAKmlB,OAAO,SAAAxkB,GAAK,MAAAA,GAAEsmB,QAAQ,SAAS3M,IAAI,EAAG,YAGxC1M,EAAApM,UAAAqmB,aAAP,WACE,MAAO7nB,MAAK0O,aAAe1O,KAAK8nB,eAK3Bla,EAAApM,UAAAqb,YAAP,WACE,MAAO7c,MAAKmlB,OAAO,SAAAxkB,GAAK,MAAAA,GAAEsmB,QAAQ,WAG7BrZ,EAAApM,UAAAumB,cAAP,WACE,MAAO/nB,MAAKqH,QAAUvC,EAAUW,WAAazF,KAAK0O,aAAe5J,EAAUa,SAGtEiI,EAAApM,UAAA+O,UAAP,SAAiB2U,GACf,WADe,KAAAA,OAAA,GACRA,EACLllB,KAAKmlB,OAAO,SAAAxkB,GAAK,MAAAA,GAAEwmB,MAAM,UACzBnnB,KAAKmlB,OAAO,SAAAxkB,GAAK,MAAAA,GAAEsmB,QAAQ,QAAQ3M,IAAI,EAAG,WAGvC1M,EAAApM,UAAAwmB,YAAP,WACE,MAAOhoB,MAAKqH,QAAUvC,EAAUY,WAAa1F,KAAK0O,aAAe5J,EAAUc,SAKtEgI,EAAApM,UAAAsmB,YAAP,WACE,MAAO9nB,MAAK+jB,KAAK+D,eAGZla,EAAApM,UAAAymB,WAAP,WACE,MAAOjoB,MAAKuQ,YAAY6I,WAGnBxL,EAAApM,UAAA0mB,YAAP,WACE,MAAOloB,MAAK+jB,KAAKmE,eAKZta,EAAApM,UAAA6J,OAAP,SAAcA,GACZ,MAAOrL,MAAK+jB,KAAK1Y,OAAQA,IAGpBuC,EAAApM,UAAA2mB,IAAP,SAAWC,GACT,MAAOpoB,MAAKmlB,OAAO,SAAAxkB,GAAK,MAAAA,GAAEwnB,IAAIC,MAGzBxa,EAAApM,UAAA6jB,SAAP,WACE,MAAOrlB,MAAK+jB,KAAK1S,SAGZzD,EAAApM,UAAA6mB,OAAP,WACE,MAAOroB,MAAK+jB,KAAKsE,UAGZza,EAAApM,UAAA8mB,QAAP,WACE,MAAOtoB,MAAK+jB,KAAKuE,WAGZ1a,EAAApM,UAAA+mB,OAAP,WACE,MAAOvoB,MAAK+jB,KAAKwE,UAGZ3a,EAAApM,UAAAgnB,YAAP,SAAmBC,GACjB,WADiB,KAAAA,OAAA,GACVzoB,KAAK+jB,KAAKyE,YAAaC,IAGzB7a,EAAApM,UAAAmgB,SAAP,WACE,MAAO3hB,MAAK+jB,KAAKpC,YAGZ/T,EAAApM,UAAAod,SAAP,WACE,MAAO5e,MAAK+jB,KAAKnF,YAKZhR,EAAApM,UAAAknB,MAAP,WACE,MAAO1oB,MAAK+jB,KAAK2E,SAGZ9a,EAAApM,UAAAmnB,WAAP,WACE,MAAO3oB,MAAK+jB,KAAK4E,cAKL/a,EAAAgb,IAAd,WACE,MAAO,IAAIhb,GAAIkW,MAGHlW,EAAA3C,MAAd,WACE,MAAOjL,MAAK4oB,MAAMjhB,SAGNiG,EAAAib,SAAd,WACE,MAAO7oB,MAAKiL,QAAQsC,QAGRK,EAAAkb,WAAd,SAAyBC,GACvB,MAAOA,IAAUA,EAAOC,UAAY,GAAIpb,GAAKmb,GAAW,MAG5Cnb,EAAAoV,KAAd,SAAmBxa,GACjB,MAAOxI,MAAK8oB,WAAWhF,EAAOtb,KAGlBoF,EAAAqb,YAAd,SAA0BzgB,GACxB,MAAOxI,MAAK8oB,WAAWhF,EAAA,KAAYtb,KAGvBoF,EAAAsS,MAAd,SAAoBjd,GAClB,MAAO0U,GAAM1Q,IAAIhE,IAGL2K,EAAAgU,WAAd,SAAyB3e,GACvB,MAAOjD,MAAK8oB,WAAWhF,EAAO7gB,KAGlB2K,EAAAsb,WAAd,SAAyBjmB,EAAe8H,GACtC,MAAO/K,MAAK8oB,WAAWhF,EAAO7gB,EAAO8H,KAGzB6C,EAAAsV,WAAd,SAAyBjgB,GACvB,MAAOjD,MAAK8oB,WAAWhF,EAAO7gB,KAGlB2K,EAAAub,SAAd,SAAuBlmB,GACrB,MAAOjD,MAAK8oB,WAAWhF,EAAO7gB,KAGlB2K,EAAAqV,UAAd,SAAwBhgB,GACtB,MAAOjD,MAAK8oB,WAAWhF,EAAO7gB,KAGlB2K,EAAAwb,kBAAd,SAAgCzc,GAC9B,GAAIoX,GAAepX,EAAK,IACpBtF,EAAiBnF,KAAKK,MAAMoK,EAAK,KAAO,IAAO,EAC/Cd,EAAe3J,KAAKK,MAAMoK,EAAK,IAEnC,OAAO3M,MAAK4O,MAAM/C,EAAMxE,EAAO0c,IAGnBnW,EAAAgB,MAAd,SAAoB/C,EAAcxE,EAChC0c,EACAhd,EACAF,EACA8Z,EACAC,GAEA,WANA,KAAAmD,MAAejf,EAAUa,aACzB,KAAAoB,MAAejC,EAAUe,cACzB,KAAAgB,MAAiB/B,EAAUiB,gBAC3B,KAAA4a,MAAiB7b,EAAUmB,gBAC3B,KAAA2a,MAAsB9b,EAAUqB,YAEzB,GAAIyH,GAAKkW,GAAQjY,KAAIA,EAAExE,MAAKA,EAAE0c,KAAIA,EAAEhd,KAAIA,EAAEF,OAAMA,EAAE8Z,OAAMA,EAAEC,YAAWA,MAUhEhT,EAAAuW,kBAAd,SAAgCJ,GAE9B,MAAO7hB,MAAKK,OAAQwhB,EAAK3K,YAAc,GAAKtU,EAAUQ,eAG1CsI,EAAAyW,sBAAd,SAAoCN,GAElC,GAAIsF,GAAatF,EAAK1S,QAAQ8V,MAAM,QAChCc,EAAqBoB,EAAWjQ,WAEpC,OAAOlX,MAAKK,OAAQ0lB,EAAalE,EAAK3K,aAAetU,EAAUQ,eAGnDsI,EAAAsW,cAAd,SAA4BH,GAE1B,GAAIuF,GAAcvF,EAAK1S,QAAQ4V,QAAQ,QACnC7f,EAAgB2c,EAAK5c,MAEzB,OAAOmiB,GAAYriB,MAAQnC,EAAU0C,8BAAgCJ,EAAQ,EAAIA,GAGrEwG,EAAAwW,kBAAd,SAAgCL,GAE9B,GAAIuF,GAAcvF,EAAK1S,QAAQ4V,QAAQ,QACnC7f,EAAgB2c,EAAK5c,MAEzB,OAAOmiB,GAAYriB,QAAUnC,EAAUuB,YAAce,EAAQA,EAAQ,GAGzDwG,EAAA0W,sBAAd,SAAoCP,GAElC,GAAIuF,GAAcvF,EAAK1S,QAAQ4V,QAAQ,QACnC7f,EAAgB2c,EAAK5c,OACrBoiB,EAAmBxF,EAAKmE,cACxBsB,EAAmBD,EAAWniB,CAElC,OAAOkiB,GAAYriB,QAAUnC,EAAUuB,YAAcmjB,EAAW,EAAIA,GAGxD5b,EAAA4W,mBAAd,SAAiCT,GAE/B,MAAO7hB,MAAKK,OAAOwhB,EAAKA,OAAS,GAAKjf,EAAUQ,eAGpCsI,EAAA8W,uBAAd,SAAqCX,GAEnC,MAAO7hB,MAAKK,OAAOwhB,EAAK+D,cAAgB/D,EAAKA,QAAUjf,EAAUQ,eAGrDsI,EAAA6W,mBAAd,SAAiCV,GAE/B,MAAO7hB,MAAKK,OAAOwhB,EAAKA,OAAS,EAAIA,EAAK9c,MAAQnC,EAAUQ,cAAgBR,EAAUQ,eAG1EsI,EAAA+W,uBAAd,SAAqCZ,GAEnC,MAAO7hB,MAAKK,OAAOwhB,EAAK+D,cAAgB/D,EAAKA,QAAUjf,EAAUwB,YAAcyd,EAAK9c,OAASnC,EAAUQ,cAAgBR,EAAUQ,eAGrHsI,EAAA2W,eAAd,SAA6BR,GAE3B,GAAI0F,GAAM1F,EAAKA,OACX2F,EAAM3F,EAAK9c,MACX0iB,EAAaF,EAAMC,CAEvB,OAAOxnB,MAAKK,OAASonB,EAAa7kB,EAAU0C,8BAAgC,GAAM1C,EAAUQ,eAGhFsI,EAAAqW,kBAAd,SAAgCF,GAE9B,MAAOA,GAAK+D,cAAgB/D,EAAKA,OAAS,GAG9CnW,MjB45HIgc,EAAyB5pB,MAAQA,KAAKiM,WAAc,WACpD,GAAIC,GAAgBnL,OAAOoL,iBACpBC,uBAA2BlJ,QAAS,SAAUvC,EAAGsD,GAAKtD,EAAEyL,UAAYnI,IACvE,SAAUtD,EAAGsD,GAAK,IAAK,GAAIvC,KAAKuC,GAAOA,EAAExC,eAAeC,KAAIf,EAAEe,GAAKuC,EAAEvC,IACzE,OAAO,UAAUf,EAAGsD,GAEhB,QAASoI,KAAOrM,KAAKsM,YAAc3L,EADnCuL,EAAcvL,EAAGsD,GAEjBtD,EAAEa,UAAkB,OAANyC,EAAalD,OAAOwL,OAAOtI,IAAMoI,EAAG7K,UAAYyC,EAAEzC,UAAW,GAAI6K,QkBtuJvFwd,EAAA,SAAAxb,GAAA,QAAAyb,KAAA,GAAAhX,GAAA,OAAAzE,KAAAE,MAAAvO,KAAAgN,YAAAhN,IlByyJQ,OkBnyJC8S,GAAAiX,YAAsB,EAKtBjX,EAAAkX,aAAuB,EAKvBlX,EAAAmX,cAAwB,EAKxBnX,EAAAoX,aAAuB,EAQvBpX,EAAAqX,cAAwB,EAKxBrX,EAAAsX,aAAuB,EAKvBtX,EAAAuX,cAAwB,EAKxBvX,EAAAwX,eAAyB,EAKzBxX,EAAAyX,cAAwB,EAOxBzX,EAAA0X,YAAsB,EAMtB1X,EAAA2X,UlB2uJM3X,EkBlrJf,MAvHuC8W,GAAAE,EAAAzb,GAsE9Byb,EAAAtoB,UAAAkpB,cAAP,WAEE,MAAOzZ,GAASwD,SAAUzU,KAAKyqB,SAS1BX,EAAAtoB,UAAAmpB,cAAP,SAAqBnP,GAQnB,MANAxb,MAAK+pB,WAAa/pB,KAAKiI,QAAQuT,GAC/Bxb,KAAKgqB,YAAchqB,KAAKmI,SAASqT,GACjCxb,KAAKiqB,aAAejqB,KAAKqI,UAAUmT,GACnCxb,KAAKkqB,YAAclqB,KAAKuI,SAASiT,GACjCxb,KAAKmqB,cAAgBnqB,KAAK8I,YAAY0S,EAASpZ,EAAGS,MAAM,GAEjD7C,MASF8pB,EAAAtoB,UAAAopB,eAAP,SAAsBC,GAOpB,MALA7qB,MAAKoqB,YAAcS,EAAS7iB,WAAWhI,MACvCA,KAAKqqB,aAAeQ,EAAS3iB,YAAYlI,MACzCA,KAAKsqB,cAAgBO,EAASziB,aAAapI,MAC3CA,KAAKuqB,aAAeM,EAASviB,YAAYtI,MAElCA,MAOF8pB,EAAAtoB,UAAAspB,cAAP,WAIE,MAFA9qB,MAAKoqB,YAAcpqB,KAAKqqB,aAAerqB,KAAKsqB,cAAgBtqB,KAAKuqB,cAAe,EAEzEvqB,MAGX8pB,GAvHuC5e,GCCvC6f,EAAA,WAkGE,QAAAC,GAAmBre,EAAY+W,EAAoB7b,EAAeojB,GA3B3DjrB,KAAAkrB,IAAc,EASdlrB,KAAAmrB,IAAc,EAMdnrB,KAAAorB,SAAmB,EAcxBprB,KAAK2M,GAAKA,EACV3M,KAAK0jB,MAAQA,EACb1jB,KAAK6H,KAAOA,EACZ7H,KAAKiH,IAAMgkB,EACXjrB,KAAK+Z,QAAU2J,EAAM9L,SAASG,YAC9B/X,KAAKyX,KAAOiM,EAAM9L,SAASgC,QAAS/R,EAAKF,OACzC3H,KAAKqc,UAAYqH,EAAM9L,SAAS+B,YAAa9R,EAAKF,OAClD3H,KAAKqrB,SAAWxjB,EAAKyjB,SAAWzjB,EAAKF,MAAMM,QAASgjB,GACpDjrB,KAAKurB,OAAS1jB,EAAKyjB,SAAWzjB,EAAKD,IAAI0d,UAAU,GAAGrd,QAASgjB,GAqJjE,MA/IElqB,QAAAC,eAAWgqB,EAAAxpB,UAAA,cnB+xJLL,ImB/xJN,WAEE,MAAOe,MAAKK,MAAOvC,KAAK2M,GAAK7H,EAAUyC,qBnBgyJnCrG,YAAY,EACZD,cAAc,ImB3xJpBF,OAAAC,eAAWgqB,EAAAxpB,UAAA,SnBiyJLL,ImBjyJN,WAEE,MAAOnB,MAAK6H,KAAKF,OnBkyJbzG,YAAY,EACZD,cAAc,ImB7xJpBF,OAAAC,eAAWgqB,EAAAxpB,UAAA,OnBmyJLL,ImBnyJN,WAEE,MAAOnB,MAAK6H,KAAKD,KnBoyJb1G,YAAY,EACZD,cAAc,ImB/xJpBF,OAAAC,eAAWgqB,EAAAxpB,UAAA,YnBqyJLL,ImBryJN,WAEE,MAAOnB,MAAK0jB,MAAM9L,UnBsyJd1W,YAAY,EACZD,cAAc,ImBjyJpBF,OAAAC,eAAWgqB,EAAAxpB,UAAA,QnBuyJLL,ImBvyJN,WAEE,MAAOnB,MAAK0jB,MAAMlD,MnBwyJdtf,YAAY,EACZD,cAAc,ImBnyJpBF,OAAAC,eAAWgqB,EAAAxpB,UAAA,cnByyJLL,ImBzyJN,WAEE,MAAOnB,MAAKmc,eAAehb,IAAKnB,KAAK2H,QnB0yJjCzG,YAAY,EACZD,cAAc,ImBpyJpBF,OAAAC,eAAWgqB,EAAAxpB,UAAA,kBnB2yJLL,ImB3yJN,WAEE,MAAOnB,MAAK4X,SAASuE,gBnB4yJjBjb,YAAY,EACZD,cAAc,ImBpyJpBF,OAAAC,eAAWgqB,EAAAxpB,UAAA,cnB6yJLL,ImB7yJN,WAEE,MAAOnB,MAAK6H,KAAKsB,WAAYnJ,KAAKiH,MnB8yJ9B/F,YAAY,EACZD,cAAc,ImBtyJpBF,OAAAC,eAAWgqB,EAAAxpB,UAAA,YnB+yJLL,ImB/yJN,WAEE,MAAOnB,MAAK6H,KAAKwB,SAAUrJ,KAAKiH,MnBgzJ5B/F,YAAY,EACZD,cAAc,ImB3xJb+pB,EAAAxpB,UAAAgqB,cAAP,SAAqBjiB,EAAuBC,EAAsBC,EAA4BE,EAAsBC,EAAqBC,GAEvI,WAFmB,KAAAN,MAAA,OAAuB,KAAAC,MAAA,OAAsB,KAAAC,MAAA,QAA4B,KAAAE,OAAA,OAAsB,KAAAC,MAAA,OAAqB,KAAAC,MAAA,GAEhI7J,KAAK6H,KAAKyB,UAAWtJ,KAAKiH,IAAKsC,EAAWC,EAAUxJ,KAAKmrB,IAAKnrB,KAAKorB,SAAUzhB,EAAMC,EAASC,IAS9FmhB,EAAAxpB,UAAAgW,OAAP,SAAc6E,GAKZ,WALY,KAAAA,OAAA,GAEZrc,KAAK4X,SAASwE,aAAcpc,KAAK2H,MAAO0U,GACxCrc,KAAKqc,UAAYA,EAEVrc,MASFgrB,EAAAxpB,UAAA8V,QAAP,SAAe4E,GAIb,WAJa,KAAAA,OAAA,GAEblc,KAAK4X,SAASqE,YAAajc,KAAK2H,MAAOuU,GAEhClc,MAcFgrB,EAAAxpB,UAAA+T,KAAP,SAAYQ,GAEV,MAAO/V,MAAK4X,SAASrC,KAAMQ,EAAQ/V,KAAK2H,QAG5CqjB,KCxIAS,GAAA,WA+JE,QAAAC,GAAmB/jB,EAAYC,EAAU6C,EAAa0W,EAAcwK,EAA0BC,EAAwB3oB,GA3G/GjD,KAAA6rB,MAAgB,EAOhB7rB,KAAA8rB,YAAsB,EAMtB9rB,KAAA+rB,cAAwB,EAQxB/rB,KAAAgsB,WAAqB,EAQrBhsB,KAAAisB,eAAyB,EAMzBjsB,KAAAksB,YAAsB,EAOtBlsB,KAAAmsB,eAAyB,EAKzBnsB,KAAAosB,YAA+B,KAQ/BpsB,KAAA0X,UAA+B,SAACtU,GAAK,MAAGA,IAQxCpD,KAAA2jB,UAA+B,SAACvgB,GAAK,MAAGA,IAOxCpD,KAAAqsB,UAAqB,KAKrBrsB,KAAAkH,QAKAlH,KAAAyqB,UAMAzqB,KAAAygB,WAsBLzgB,KAAKuL,KAAO,GAAI9D,GAAQE,EAAOC,GAC/B5H,KAAKssB,OAAS,GAAI7kB,GAAQE,EAAOC,GACjC5H,KAAKyK,KAAOA,EACZzK,KAAKmhB,KAAOA,EACZnhB,KAAK2rB,UAAYA,EACjB3rB,KAAK4rB,QAAUA,EAEX7oB,EAAGW,UAAUT,GACfjD,KAAK0W,IAAIzT,GAGTjD,KAAKusB,UAwjCX,MA7hCSb,GAAAlqB,UAAAkV,IAAP,SAAWzT,GAGT,GAAMupB,GAAsBzpB,EAAGW,UAAUT,EAAMwH,OAASxH,EAAMwH,OAASzK,KAAKyK,KACtEgiB,EAAsB1pB,EAAGW,UAAUT,EAAMke,OAASle,EAAMke,OAASnhB,KAAKmhB,IAE5E,IAAIqL,GAAcC,EAAY,CAC5B,GAAMC,GAAgB3pB,EAAGgB,SAASd,EAAM0pB,eAAgB,OAClDC,EAAkB7pB,EAAGgB,SAASd,EAAM4pB,aAAa,GACjD1L,EAAepe,EAAGgB,SAASd,EAAMke,KAAMnhB,KAAKmhB,MAC5C1W,EAAc1H,EAAGgB,SAASd,EAAMwH,KAAMzK,KAAKyK,MAC7C8S,EAAmBxa,EAAGgB,SAASd,EAAMsa,OAAQvd,KAAKkH,KAAKhF,KAAKK,OAAOvC,KAAKkH,KAAK5D,OAAS,GAAKopB,KACzFzhB,EAAaC,EAAID,UAElBsS,GAAWqP,GAAU5sB,KAAKuL,KAAKvD,WAAWiD,MAC7CsS,EAAStS,EAGX,IAAMwM,GAAYiU,EAASoB,MAAMriB,GAC3B9C,EAAa8P,EAAKsV,SAAS7hB,EAAIgV,MAAM3C,GAAS4D,EAAMuL,GACpD9kB,EAAW6P,EAAKuV,OAAOrlB,EAAOwZ,EAAMuL,EAE1C1sB,MAAKuL,KAAK5D,MAAQA,EAClB3H,KAAKuL,KAAK3D,IAAMA,EAChB5H,KAAKyK,KAAOA,EACZzK,KAAKmhB,KAAOA,EACZnhB,KAAK2rB,UAAYlU,EAAKkU,UACtB3rB,KAAK4rB,QAAUnU,EAAKmU,YAEjB,IAAI3oB,EAAMsa,OAAQ,CACrB,GAAM0P,GAAgBlqB,EAAGgB,SAASd,EAAM0pB,eAAgB,OAClDpP,EAAcrS,EAAIgV,MAAMjd,EAAMsa,QAC9B9S,EAAczK,KAAKyK,KACnB0W,EAAenhB,KAAKmhB,KACpB1J,EAAYiU,EAASoB,MAAMriB,GAC3B9C,EAAa8P,EAAKsV,SAASxP,EAAQ4D,EAAM8L,GACzCrlB,EAAW6P,EAAKuV,OAAOrlB,EAAOwZ,EAAM8L,EAE1CjtB,MAAKuL,KAAK5D,MAAQA,EAClB3H,KAAKuL,KAAK3D,IAAMA,EAsBlB,MAnBA5H,MAAK6rB,KAAO9oB,EAAGgB,SAASd,EAAM4oB,KAAM7rB,KAAK6rB,MACzC7rB,KAAK8rB,YAAc/oB,EAAGgB,SAASd,EAAM6oB,YAAa9rB,KAAK8rB,aACvD9rB,KAAK+rB,aAAehpB,EAAGgB,SAASd,EAAM8oB,aAAc/rB,KAAK+rB,cACzD/rB,KAAKgsB,UAAYjpB,EAAGgB,SAASd,EAAM+oB,UAAWhsB,KAAKgsB,WACnDhsB,KAAKisB,cAAgBlpB,EAAGgB,SAASd,EAAMgpB,cAAejsB,KAAKisB,eAC3DjsB,KAAKksB,WAAanpB,EAAGgB,SAASd,EAAMipB,WAAYlsB,KAAKksB,YACrDlsB,KAAKmsB,cAAgBppB,EAAGgB,SAASd,EAAMkpB,cAAensB,KAAKmsB,eAC3DnsB,KAAKosB,YAAcrpB,EAAGgB,SAASd,EAAMmpB,YAAapsB,KAAKosB,aACvDpsB,KAAK0X,UAAY3U,EAAGgB,SAASd,EAAMyU,UAAW1X,KAAK0X,WACnD1X,KAAK2jB,UAAY5gB,EAAGgB,SAASd,EAAM0gB,UAAW3jB,KAAK2jB,WAE/C5gB,EAAGC,QAAQC,EAAMwnB,SACnBzqB,KAAKktB,UAAUjqB,EAAMwnB,QAAQ,GAG1BxnB,EAAMkqB,cACTntB,KAAKusB,UAGAvsB,MASF0rB,EAAAlqB,UAAA4rB,gBAAP,SAAuBtB,GAIrB,MAHA9rB,MAAK8rB,YAAcA,EACnB9rB,KAAKusB,UAEEvsB,MASF0rB,EAAAlqB,UAAA6rB,iBAAP,SAAwBtB,GAItB,MAHA/rB,MAAK+rB,aAAeA,EACpB/rB,KAAKstB,gBAEEttB,MASF0rB,EAAAlqB,UAAA+rB,cAAP,SAAqBvB,GAInB,MAHAhsB,MAAKgsB,UAAYA,EACjBhsB,KAAKstB,gBAEEttB,MASF0rB,EAAAlqB,UAAAgsB,kBAAP,SAAyBvB,GAIvB,MAHAjsB,MAAKisB,cAAgBA,EACrBjsB,KAAKstB,gBAEEttB,MAUF0rB,EAAAlqB,UAAAisB,eAAP,SAAsBvB,EAAqBK,GAOzC,WAPyC,KAAAA,OAAA,GACzCvsB,KAAKksB,WAAaA,EAEdK,GAAWL,GACblsB,KAAK0tB,cAGA1tB,MAWF0rB,EAAAlqB,UAAAmsB,kBAAP,SAAyBxB,EAAwBI,GAO/C,WAP+C,KAAAA,OAAA,GAC/CvsB,KAAKmsB,cAAgBA,EAEjBI,GAAWJ,GACbnsB,KAAK4tB,iBAGA5tB,MAOTe,OAAAC,eAAW0qB,EAAAlqB,UAAA,SpBs3JLL,IoBt3JN,WACE,MAAOnB,MAAKuL,KAAK5D,OpBw3JbzG,YAAY,EACZD,cAAc,IoBl3JpBF,OAAAC,eAAW0qB,EAAAlqB,UAAA,OpBy3JLL,IoBz3JN,WACE,MAAOnB,MAAKuL,KAAK3D,KpB23Jb1G,YAAY,EACZD,cAAc,IoB/2JbyqB,EAAAlqB,UAAAgJ,QAAP,SAAeE,EAA2BC,EAAwBC,EAAyBC,EAA4BC,GACrH,WADa,KAAAJ,OAAA,OAA2B,KAAAC,OAAA,OAAwB,KAAAC,OAAA,OAAyB,KAAAC,OAAA,OAA4B,KAAAC,MAAA,OAC9G9K,KAAKuL,KAAKf,QAAQxK,KAAKyK,KAAMC,EAAWC,EAAOC,EAAQC,EAAYC,IAYrE4gB,EAAAlqB,UAAAqsB,MAAP,SAAaC,GAAb,GAAAhb,GAAA9S,IACE,YADW,KAAA8tB,MAAA,GACJ,GAAI7c,GAAyB,SAAAqB,GAIlC,IAAK,GAHD3K,GAAamL,EAAKnL,MAClBC,EAAWkL,EAAK8Y,QAAQ9Y,EAAKlL,IAAKkmB,EAAKhb,EAAKqO,MAEvC7gB,EAAI,EAAGA,EAAIwS,EAAKqO,KAAM7gB,IAAK,CAClC,GAAIytB,GAAW,GAAIrC,GAAS/jB,EAAOC,EAAKkL,EAAKrI,KAAMqjB,EAAIhb,EAAK6Y,UAAW7Y,EAAK8Y,QAAS9Y,EAErF,IAAIR,EAAShB,IAAIyc,KAAcvd,EAAeqB,KAC5C,MAGFlK,GAAQmL,EAAK6Y,UAAUhkB,EAAOmmB,GAC9BlmB,EAAMkL,EAAK8Y,QAAQhkB,EAAKkmB,OAYvBpC,EAAAlqB,UAAA+qB,QAAP,SAAethB,GAQb,WARa,KAAAA,MAAaC,EAAID,SAC9BjL,KAAKsD,OAAStD,KAAKuL,KAAKrE,KAAK9E,EAAGU,IAAI,GACpC9C,KAAKguB,YACLhuB,KAAKiuB,eAAehjB,GACpBjL,KAAKkuB,mBACLluB,KAAKmuB,iBACLnuB,KAAKstB,gBAEEttB,MAOF0rB,EAAAlqB,UAAA4sB,YAAP,WAIE,MAHApuB,MAAKssB,OAAO3kB,MAAQ3H,KAAK6rB,KAAO7rB,KAAK2H,MAAM6f,cAAgBxnB,KAAK2H,MAChE3H,KAAKssB,OAAO1kB,IAAM5H,KAAK6rB,KAAO7rB,KAAK4H,IAAI8H,YAAc1P,KAAK4H,IAEnD5H,MAMF0rB,EAAAlqB,UAAAwsB,UAAP,WACEhuB,KAAKouB,aAQL,KAAK,GANClnB,GAA4BlH,KAAKkH,KACjColB,EAAkBtsB,KAAKssB,OACzB9Q,EAAe8Q,EAAO3kB,MACpBmB,EAAsBwjB,EAAOplB,KAAK9E,EAAGU,IACrCqK,EAAgBjL,KAAK8H,IAAIhK,KAAK8rB,YAAahjB,GAExCxI,EAAI,EAAGA,EAAI6M,EAAO7M,IAAK,CAC9B,GAAI2G,GAAyBC,EAAK5G,EAE7B2G,IAAQA,EAAIgB,QAAQuT,KACvBvU,EAAM,GAAI4iB,GAAkBrO,EAAQuI,MAEhCzjB,EAAI4G,EAAK5D,OACX4D,EAAKwN,OAAOpU,EAAG,EAAG2G,GAGlBC,EAAKuG,KAAKxG,IAIdA,EAAIujB,WAAaxqB,KAAKuL,KAAKzD,SAASb,GAEpCuU,EAAUA,EAAQjO,OAOpB,MAJIrG,GAAK5D,OAAS6J,GAChBjG,EAAKwN,OAAOvH,EAAOjG,EAAK5D,OAAS6J,GAG5BnN,MAMF0rB,EAAAlqB,UAAA2sB,eAAP,WACE,GAAMxmB,GAAa3H,KAAKssB,OAAO3kB,MACzBC,EAAW5H,KAAKssB,OAAO1kB,GAM7B,OAJA5H,MAAKygB,QAAUzgB,KAAKyqB,OAAOtY,OAAO,SAAAkc,GAChC,MAAOA,GAAE5N,SAAW4N,EAAEzW,SAAS4B,aAAa7R,EAAOC,KAG9C5H,MAQF0rB,EAAAlqB,UAAAysB,eAAP,SAAsBhjB,GAKpB,WALoB,KAAAA,MAAaC,EAAID,SACrCjL,KAAKsuB,cAAcjc,QAAQ,SAAA1R,GACzBA,EAAEgqB,cAAc1f,KAGXjL,MAOF0rB,EAAAlqB,UAAA0sB,iBAAP,cAAApb,GAAA9S,IAUE,OATAA,MAAKsuB,cAAcjc,QAAQ,SAAA1R,GACrBmS,EAAKuZ,UACP1rB,EAAEiqB,eAAe9X,EAAKuZ,WAGtB1rB,EAAEmqB,kBAIC9qB,MAcF0rB,EAAAlqB,UAAA8rB,cAAP,cAAAxa,GAAA9S,IAeE,OAdAA,MAAKsuB,cAAcjc,QAAQ,SAAA1R,IACrBA,EAAE6pB,YAAc1X,EAAKmZ,iBACvBtrB,EAAE8pB,OAAS3X,EAAKyb,aAAa5tB,EAAGmS,EAAKkZ,UAAWlZ,EAAKiZ,iBAIrD/rB,KAAKksB,YACPlsB,KAAK0tB,cAGH1tB,KAAKmsB,eACPnsB,KAAK4tB,iBAGA5tB,MAMF0rB,EAAAlqB,UAAAksB,YAAP,WAIE,GAAIc,MACEC,EAAuBzuB,KAAKgsB,SAoClC,OAlCAhsB,MAAKsuB,cAAcjc,QAAQ,SAAA1R,GACL,IAAhBA,EAAE+J,YACJ8jB,KAKF,KAAoB,GAFdE,MAEc3hB,EAAA,EAAAkJ,EAAAtV,EAAE8pB,OAAF1d,EAAAkJ,EAAA3S,OAAAyJ,IAAQ,CAAvB,GAAM4hB,GAAK1Y,EAAAlJ,EACV0hB,KAAgBE,EAAM5U,SAItB4U,EAAMhiB,KAAM6hB,KACdE,EAAKC,EAAMzD,IAAMsD,EAAWG,EAAMhiB,MAAO,GAM7C,IAAoB,GAFhBiiB,GAAmB,EAEHC,EAAA,EAAAC,EAAAnuB,EAAE8pB,OAAFoE,EAAAC,EAAAxrB,OAAAurB,IAAQ,CAAvB,GAAME,GAAKD,EAAAD,EACd,MAAKJ,IAAgBM,EAAMhV,SAAYgV,EAAMpiB,KAAM6hB,IAAnD,CAIA,KAAOE,EAAKE,IACVA,GAGFJ,GAAWO,EAAMpiB,IAAMoiB,EAAM7D,IAAM0D,EAEnCA,QAIG5uB,MAaF0rB,EAAAlqB,UAAAosB,eAAP,WA8DE,QAAAoB,GAAoBC,GAClB,GAAMC,GAAgBD,EAAQ3rB,MAE9B2rB,GAAQE,QAAQ,SAAChE,EAAKiE,GACpBjE,EAAIgE,QAAQ,SAAAzL,GACV,GAAM2L,GAAUC,EAAY5L,EAAO0L,EAAUH,EAC7CvL,GAAMyH,IAAMiE,EAAWF,EACvBxL,EAAM0H,SAAWiE,EAAUH,MAQjC,QAAAK,GAAsBC,EAAyBC,GAC7C,MAAOD,GAAG3nB,KAAKD,IAAIC,KAAO4nB,EAAG5nB,KAAKF,MAAME,MAAQ2nB,EAAG3nB,KAAKF,MAAME,KAAO4nB,EAAG5nB,KAAKD,IAAIC,KASnF,QAAAynB,GAAqBE,EAAyBJ,EAAkBH,GAG9D,IAAK,GAFDI,GAAU,EAEL/uB,EAAI8uB,EAAW,EAAG9uB,EAAI2uB,EAAQ3rB,OAAQhD,IAAK,CAGlD,IAAK,GAFC6qB,GAAM8D,EAAQ3uB,GAEXovB,EAAI,EAAGA,EAAIvE,EAAI7nB,OAAQosB,IAAK,CAGnC,GAAIH,EAAaC,EAFNrE,EAAIuE,IAGb,MAAOL,GAGXA,IAGF,MAAOA,GAGT,MAzGArvB,MAAKsuB,cAAcjc,QAAQ,SAAA1R,GACzB,GAAIsuB,MACAU,EAA0B,KAExBlF,EAAS9pB,EAAE8pB,MAEjBA,GAAOpH,KAAK,SAACmM,EAAIC,GACf,MAAID,GAAG3nB,KAAKF,MAAME,KAAO4nB,EAAG5nB,KAAKF,MAAME,MAAc,EACjD2nB,EAAG3nB,KAAKF,MAAME,KAAO4nB,EAAG5nB,KAAKF,MAAME,KAAa,EAChD2nB,EAAG3nB,KAAKD,IAAIC,KAAO4nB,EAAG5nB,KAAKD,IAAIC,MAAc,EAC7C2nB,EAAG3nB,KAAKD,IAAIC,KAAO4nB,EAAG5nB,KAAKD,IAAIC,KAAa,EAEzC,GAGT,KAAoB,GAAAkF,GAAA,EAAA6iB,EAAAnF,EAAA1d,EAAA6iB,EAAAtsB,OAAAyJ,IAAM,CAArB,GAAM8iB,GAAKD,EAAA7iB,EAGU,QAApB4iB,GAA4BE,EAAMhoB,KAAKF,MAAME,MAAQ8nB,IAIvDX,EAAWC,GACXA,KACAU,EAAkB,KAIpB,KAAK,GADDG,IAAS,EACJxvB,EAAI,EAAGA,EAAI2uB,EAAQ3rB,OAAQhD,IAAK,CACvC,GAAM6qB,GAAM8D,EAAQ3uB,EAEpB,KAAKivB,EAAapE,EAAIA,EAAI7nB,OAAS,GAAIusB,GAAQ,CAC7C1E,EAAI1d,KAAKoiB,GACTC,GAAS,CACT,QAMCA,GACHb,EAAQxhB,MAAMoiB,KAKQ,OAApBF,GAA4BE,EAAMhoB,KAAKD,IAAIC,KAAO8nB,KACpDA,EAAkBE,EAAMhoB,KAAKD,IAAIC,MAIjConB,EAAQ3rB,OAAS,GACnB0rB,EAAWC,KAqDRjvB,MAUF0rB,EAAAlqB,UAAAuuB,OAAP,SAAc9sB,GACZ,GAAMwe,GAAcvW,EAAIgV,MAAMjd,EAE9B,IAAIwe,EAAQ,CACV,GAAMuO,GAAmBvO,EAAO9Z,QAAQmB,YAAY9I,KAAKkH,KAAK,GAAI9E,EAAGS,MAAM,EAE3E,OAAO7C,MAAKkH,KAAK8oB,GAGnB,MAAO,OAQFtE,EAAAlqB,UAAA8sB,YAAP,cAAAxb,GAAA9S,IACE,OAAO,IAAIiR,GAA4B,SAAAqB,GAGrC,IAAK,GAFCpL,GAA4B4L,EAAK5L,KAE9B5G,EAAI,EAAGA,EAAI4G,EAAK5D,OAAQhD,IAC/B,OAAQgS,EAAShB,IAAIpK,EAAK5G,KACxB,IAAKkQ,GAAeqB,KAClB,WAmBH6Z,EAAAlqB,UAAA+sB,aAAP,SAAoBtnB,EAAUgpB,EAA0B1U,EAAwB2U,OAAlD,KAAAD,OAAA,OAA0B,KAAA1U,OAAA,OAAwB,KAAA2U,MAA0BlwB,KAAKosB,YAI7G,KAAK,GAHC3B,MACA0F,EAAyBnwB,KAAKygB,QAE3B2P,EAAa,EAAGA,EAAaD,EAAQ7sB,OAAQ8sB,KpB20JpC,SoB30JTA,GACP,GAAMnP,GAAqBkP,EAAQC,GAC7BxY,EAAwBqJ,EAAMrJ,SAC9ByY,EAAkBD,EAAatrB,EAAUyC,mBAC3C+oB,EAAoB,CAExB1Y,GAAS0D,aAAarU,EAAKsU,GAAQlJ,QAAQ,SAAC9G,EAAM+G,GAChDmY,EAAOhd,KAAK,GAAIsd,GAAcsF,EAAUC,IAAarP,EAAO1V,EAAMtE,IAE7DgpB,GACH3d,EAASV,UAVNwe,EAmBT,OAJIF,IACFzF,EAAOpH,KAAK6M,GAGPzF,GASFiB,EAAAlqB,UAAA+uB,UAAP,SAAiB5jB,GACf,IAAoB,GAAAI,GAAA,EAAAkJ,EAAAjW,KAAKyqB,OAAL1d,EAAAkJ,EAAA3S,OAAAyJ,IAAW,CAA1B,GAAMyjB,GAAKva,EAAAlJ,EACd,IAAIyjB,IAAU7jB,GAAM6jB,EAAM5Y,WAAajL,GAAM6jB,EAAMhQ,OAAS7T,GAAM6jB,EAAM7jB,KAAOA,EAC7E,MAAO6jB,GAIX,MAAO,OAcF9E,EAAAlqB,UAAAivB,aAAP,SAAoBhG,EAAsB0C,GACxC,OADkB,KAAA1C,MAAA,UAAsB,KAAA0C,OAAA,GACpC1C,EACF,IAAoB,GAAA1d,GAAA,EAAA2jB,EAAAjG,EAAA1d,EAAA2jB,EAAAptB,OAAAyJ,IAAM,CAArB,GAAM4jB,GAAKD,EAAA3jB,EACd/M,MAAK4wB,YAAYD,GAAO,OAI1B3wB,MAAKyqB,SASP,OANAzqB,MAAKmuB,iBAEAhB,GACHntB,KAAKstB,gBAGAttB,MAWF0rB,EAAAlqB,UAAAovB,YAAP,SAAmBlN,EAAYyJ,OAAA,KAAAA,OAAA,EAC7B,IAAM5Q,GAAqBvc,KAAKuwB,UAAU7M,EAY1C,OAVInH,KACFvc,KAAKyqB,OAAO/V,OAAO1U,KAAKyqB,OAAOoG,QAAQtU,GAAQ,GAE/Cvc,KAAKmuB,iBAEAhB,GACHntB,KAAKstB,iBAIFttB,MAaF0rB,EAAAlqB,UAAAsvB,SAAP,SAAgBpN,EAAyBqN,EAAkC5D,OAAlC,KAAA4D,OAAA,OAAkC,KAAA5D,OAAA,EACzE,IAAM1L,GAAsB9J,EAAM+L,MAAYA,EAAO1jB,KAAK2jB,UAAW3jB,KAAK0X,UAE1E,KAAKqZ,EAAiB,CAGpB,GAFiB/wB,KAAKuwB,UAAU9O,GAG9B,MAAOzhB,MAYX,MARAA,MAAKyqB,OAAOhd,KAAKgU,GAEjBzhB,KAAKmuB,iBAEAhB,GACHntB,KAAKstB,gBAGAttB,MAaF0rB,EAAAlqB,UAAAwvB,UAAP,SAAiBvG,EAA4BsG,EAAkC5D,OAAlC,KAAA4D,OAAA,OAAkC,KAAA5D,OAAA,EAC7E,KAAoB,GAAApgB,GAAA,EAAAkkB,EAAAxG,EAAA1d,EAAAkkB,EAAA3tB,OAAAyJ,IAAM,CAArB,GAAMmkB,GAAKD,EAAAlkB,EACd/M,MAAK8wB,SAASI,EAAOH,GAAiB,GAOxC,MAJK5D,IACHntB,KAAKstB,gBAGAttB,MAYF0rB,EAAAlqB,UAAA0rB,UAAP,SAAiBzC,EAA4B0C,OAAA,KAAAA,OAAA,EAG3C,KAAK,GAFCgE,MAEG7wB,EAAI,EAAGA,EAAImqB,EAAOnnB,OAAQhD,IAAK,CACtC,GAAImhB,GAAsB9J,EAAM+L,MAAY+G,EAAOnqB,GAAIN,KAAK2jB,UAAW3jB,KAAK0X,UAExE+J,IACF0P,EAAa1jB,KAAKgU,GAYtB,MARAzhB,MAAKyqB,OAAS0G,EAEdnxB,KAAKmuB,iBAEAhB,GACHntB,KAAKstB,gBAGAttB,MAWF0rB,EAAAlqB,UAAA4vB,OAAP,SAAczpB,EAAYC,GAIxB,WAJwB,KAAAA,MAAAD,GACxB3H,KAAKqsB,UAAY,GAAI5kB,GAAQE,EAAOC,GACpC5H,KAAKkuB,mBAEEluB,MAQF0rB,EAAAlqB,UAAA6vB,SAAP,WAIE,MAHArxB,MAAKqsB,UAAY,KACjBrsB,KAAKkuB,mBAEEluB,MAUF0rB,EAAAlqB,UAAA+T,KAAP,SAAY+b,EAA0BnE,GAQpC,WARU,KAAAmE,MAAetxB,KAAKmhB,UAAM,KAAAgM,OAAA,GACpCntB,KAAKuL,KAAK5D,MAAQ3H,KAAK2rB,UAAU3rB,KAAK2H,MAAO2pB,GAC7CtxB,KAAKuL,KAAK3D,IAAM5H,KAAK4rB,QAAQ5rB,KAAK4H,IAAK0pB,GAElCnE,GACHntB,KAAKusB,UAGAvsB,MAUF0rB,EAAAlqB,UAAA+L,KAAP,SAAY+jB,EAA0BnE,GACpC,WADU,KAAAmE,MAAetxB,KAAKmhB,UAAM,KAAAgM,OAAA,GAC7BntB,KAAKuV,KAAK+b,EAAMnE,IAUlBzB,EAAAlqB,UAAAuR,KAAP,SAAYue,EAA0BnE,GACpC,WADU,KAAAmE,MAAetxB,KAAKmhB,UAAM,KAAAgM,OAAA,GAC7BntB,KAAKuV,MAAM+b,EAAMnE,IAgBnBzB,EAAAlqB,UAAAqW,QAAP,SAAe0Z,EACAC,EACAC,OAFA,KAAAF,OAAA,OACA,KAAAC,MAAA,SAA8B7wB,GAAK,MAAAA,SACnC,KAAA8wB,MAAA,SAA8BhxB,GAAK,MAAAA,IAChD,IAAMgS,KAENA,GAAIhI,KAAOzK,KAAKyK,KAChBgI,EAAI0O,KAAOnhB,KAAKmhB,KAChB1O,EAAIoZ,KAAO7rB,KAAK6rB,KAChBpZ,EAAIqZ,YAAc9rB,KAAK8rB,YACvBrZ,EAAIsZ,aAAe/rB,KAAK+rB,aACxBtZ,EAAIuZ,UAAYhsB,KAAKgsB,UACrBvZ,EAAIwZ,cAAgBjsB,KAAKisB,cACzBxZ,EAAIyZ,WAAalsB,KAAKksB,WACtBzZ,EAAI0Z,cAAgBnsB,KAAKmsB,cACzB1Z,EAAI8K,OAASgU,EAAQvxB,KAAKuL,KAAK5D,MAAME,KAAO7H,KAAKuL,KAAK5D,MACtD8K,EAAIgY,SAEJ,KAAkB,GAAA1d,GAAA,EAAAkJ,EAAAjW,KAAKyqB,OAAL1d,EAAAkJ,EAAA3S,OAAAyJ,IAAW,CAAxB,GAAI2kB,GAAKzb,EAAAlJ,EACZ,IAAIwkB,EAAO,CACT,GAAMI,KAEF5uB,GAAGW,UAAUguB,EAAM/kB,MACrBglB,EAAWhlB,GAAK+kB,EAAM/kB,IAGpB5J,EAAGW,UAAUguB,EAAMlR,QACrBmR,EAAWnR,KAAOgR,EAAUE,EAAMlR,OAG/BkR,EAAMjR,UACTkR,EAAWlR,QAAUiR,EAAMjR,SAG7BkR,EAAW/Z,SAAW8Z,EAAM9Z,SAASC,SAErC,IAAMJ,GAAOka,EAAW/Z,SAASH,IAEjC,IAAIA,EACF,IAAK,GAAM+L,KAAc/L,GACvBA,EAAK+L,GAAciO,EAAUha,EAAK+L,GAItC/Q,GAAIgY,OAAOhd,KAAKkkB,OAGhBlf,GAAIgY,OAAOhd,KAAKikB,GAIpB,MAAOjf,IASKiZ,EAAAkG,UAAd,SAA8B3uB,GAC5B,GAAI6Q,GAAe5I,EAAID,OAEvB,OAAO,IAAIygB,GAAS5X,EAASA,EAAS,KAAM,EAAG,KAAM,KAAM7Q,IAiB/CyoB,EAAAmG,QAAd,SAA4BpnB,EAAa0W,EAAkB5D,EAA2BuU,EAAyB7uB,OAAtE,KAAAke,MAAA,OAAkB,KAAA5D,MAAcrS,EAAID,aAAS,KAAA6mB,MAAA,OACpF,IAAIra,GAA+BzX,KAAK8sB,MAAMriB,GAC1C9C,EAAa8P,EAAKsV,SAASxP,EAAQ4D,EAAM2Q,EAG7C,OAAO,IAAIpG,GAAe/jB,EAFX8P,EAAKuV,OAAOrlB,EAAOwZ,EAAM2Q,GAEFrnB,EAAM0W,EAAM1J,EAAKkU,UAAWlU,EAAKmU,QAAS3oB,GAASwU,EAAKsa,eAiBlFrG,EAAAxkB,KAAd,SAAyBA,EAAkBqW,EAA2BuU,EAAwB7uB,GAC5F,WADuB,KAAAiE,MAAA,OAAkB,KAAAqW,MAAcrS,EAAID,aAAS,KAAA6mB,MAAA,OAC7D9xB,KAAK6xB,QAAQjtB,EAAMgH,IAAK1E,EAAMqW,EAAQuU,EAAO7uB,IAgBxCyoB,EAAAtkB,MAAd,SAA0BA,EAAmBmW,EAA2BuU,EAAwB7uB,GAC9F,WADwB,KAAAmE,MAAA,OAAmB,KAAAmW,MAAcrS,EAAID,aAAS,KAAA6mB,MAAA,OAC/D9xB,KAAK6xB,QAAQjtB,EAAMkH,KAAM1E,EAAOmW,EAAQuU,EAAO7uB,IAgB1CyoB,EAAApkB,OAAd,SAA2BA,EAAoBiW,EAA2BuU,EAAwB7uB,GAChG,WADyB,KAAAqE,MAAA,OAAoB,KAAAiW,MAAcrS,EAAID,aAAS,KAAA6mB,MAAA,OACjE9xB,KAAK6xB,QAAQjtB,EAAMmH,MAAOzE,EAAQiW,EAAQuU,EAAO7uB,IAgB5CyoB,EAAAziB,MAAd,SAA0BA,EAAmBsU,EAA2BuU,EAAwB7uB,GAC9F,WADwB,KAAAgG,MAAA,OAAmB,KAAAsU,MAAcrS,EAAID,aAAS,KAAA6mB,MAAA,OAC/D9xB,KAAK6xB,QAAQjtB,EAAMoH,KAAM/C,EAAOsU,EAAQuU,EAAO7uB,IAO1CyoB,EAAAoB,OAAK9b,KAEfA,EAACpM,EAAMgH,MAEHmhB,SAAA,SAASxP,EAAa4D,EAAc2Q,GAClC,MAAOvU,GAAO5V,QAAQ4d,cAAcrjB,KAAKK,MAAM4e,EAAO2Q,KAExD9E,OAAA,SAAOrlB,EAAYwZ,EAAc2Q,GAC/B,MAAOnqB,GAAM4d,aAAapE,EAAO,GAAGvZ,OAEtC+jB,UAAA,SAAU1kB,EAAU4L,GAClB,MAAO5L,GAAIse,aAAa1S,IAE1B+Y,QAAA,SAAQ3kB,EAAU4L,GAChB,MAAO5L,GAAIse,aAAa1S,IAE1Bkf,iBAAmBzd,IAEvBtD,EAACpM,EAAMkH,OAEHihB,SAAA,SAASxP,EAAa4D,EAAc2Q,GAClC,MAAOvU,GAAO5V,QAAQ6f,cAAcnB,eAAenkB,KAAKK,MAAM4e,EAAO2Q,KAEvE9E,OAAA,SAAOrlB,EAAYwZ,EAAc2Q,GAC/B,MAAOnqB,GAAM0e,cAAclF,EAAO,GAAGzR,aAEvCic,UAAA,SAAU1kB,EAAU4L,GAClB,MAAO5L,GAAIof,cAAcxT,IAE3B+Y,QAAA,SAAQ3kB,EAAU4L,GAChB,MAAO5L,GAAIof,cAAcxT,IAE3Bkf,iBAAmBzd,IAEvBtD,EAACpM,EAAMmH,QAEHghB,SAAA,SAASxP,EAAa4D,EAAc2Q,GAClC,MAAOvU,GAAO5V,QAAQggB,eAAexX,gBAAgBjO,KAAKK,MAAM4e,EAAO2Q,KAEzE9E,OAAA,SAAOrlB,EAAYwZ,EAAc2Q,GAC/B,MAAOnqB,GAAMwI,eAAegR,EAAO,GAAGrR,cAExC6b,UAAA,SAAU1kB,EAAU4L,GAClB,MAAO5L,GAAIkJ,eAAe0C,IAE5B+Y,QAAA,SAAQ3kB,EAAU4L,GAChB,MAAO5L,GAAI0gB,eAAexX,eAAe0C,GAAQ/C,cAEnDiiB,cAAgBlG,MAAM,IAE1B7a,EAACpM,EAAMoH,OAEH+gB,SAAA,SAASxP,EAAa4D,EAAc2Q,GAClC,MAAOvU,GAAO5V,QAAQkV,cAAc4J,eAAevkB,KAAKK,MAAM4e,EAAO2Q,KAEvE9E,OAAA,SAAOrlB,EAAYwZ,EAAc2Q,GAC/B,MAAOnqB,GAAM8e,cAActF,EAAO,GAAG5Q,aAEvCob,UAAA,SAAU1kB,EAAU4L,GAClB,MAAO5L,GAAIwf,cAAc5T,IAE3B+Y,QAAA,SAAQ3kB,EAAU4L,GAChB,MAAO5L,GAAIwf,cAAc5T,IAE3Bkf,cAAgBlG,MAAM,IpBgzJxB7a,GoB5yJR0a,MCx2CA5d,EAAA,mBAAAA,MAkCA,MA/BgBA,GAAAkkB,QAAkB,EAClBlkB,EAAAmkB,SAAmB,EACnBnkB,EAAAokB,MAAgB,EAChBpkB,EAAAqkB,MAAgB,EAChBrkB,EAAAskB,IAAc,EACdtkB,EAAAukB,KAAe,EACfvkB,EAAAwkB,KAAe,EACfxkB,EAAAykB,OAAiB,EACjBzkB,EAAA0kB,UAAoB,EACpB1kB,EAAA2kB,QAAkB,EAClB3kB,EAAA4kB,SAAmB,GACnB5kB,EAAA6kB,SAAmB,GAKnB7kB,EAAA8kB,MACZ9kB,EAAMkkB,QACNlkB,EAAMmkB,SACNnkB,EAAMokB,MACNpkB,EAAMqkB,MACNrkB,EAAMskB,IACNtkB,EAAMukB,KACNvkB,EAAMwkB,KACNxkB,EAAMykB,OACNzkB,EAAM0kB,UACN1kB,EAAM2kB,QACN3kB,EAAM4kB,SACN5kB,EAAM6kB,UAGV7kB,KCjCA+kB,EAAA,mBAAAA,MA2CA,MAxCgBA,GAAAC,OAAiB,EACjBD,EAAAE,OAAiB,EACjBF,EAAAG,QAAkB,EAClBH,EAAAI,UAAoB,EACpBJ,EAAAK,SAAmB,EACnBL,EAAAM,OAAiB,EACjBN,EAAAO,SAAmB,EAKnBP,EAAAD,MACZC,EAAQC,OACRD,EAAQE,OACRF,EAAQG,QACRH,EAAQI,UACRJ,EAAQK,SACRL,EAAQM,OACRN,EAAQO,UAMIP,EAAA/mB,MACZ+mB,EAAQE,OACRF,EAAQG,QACRH,EAAQI,UACRJ,EAAQK,SACRL,EAAQM,QAMIN,EAAAQ,MACZR,EAAQO,SACRP,EAAQC,QAGZD,KXeAS,EAAA,WAkDE,QAAAC,GAAmB3yB,EAAc4yB,EAAiBzkB,EAA2B0kB,GAE3EzzB,KAAKY,KAAOA,EACZZ,KAAKwzB,OAASA,EACdxzB,KAAK+O,SAAWA,EAChB/O,KAAKyzB,MAAQA,EAyOjB,MA7NSF,GAAA/xB,UAAA+M,MAAP,SAA0DqJ,EAAa3Q,GAmBrE,MAjBI2Q,aAAoBR,IAEtBpX,KAAK0zB,aAAazsB,EAChB,SAAC5C,EAAM2X,GAAc,MAAApE,GAASmE,aAAc1X,EAAM2X,IAClD,SAAC3X,GAAS,MAAAuT,GAASmE,aAAc1X,KAGnCuT,EAASU,gBAITtY,KAAK0zB,aAAazsB,EAChB,SAAC5C,EAAM2X,GAAc,MAAApE,GAAUvT,GAAS2X,GACxC,SAAC3X,GAAS,aAAOuT,GAAUvT,KAIxBuT,GAWF2b,EAAA/xB,UAAAkyB,aAAP,SAAoBzsB,EAClB8U,EACA4X,GAEA,IAAiB,GAAA5mB,GAAA,EAAAkJ,EAAAsd,EAAQK,MAAR7mB,EAAAkJ,EAAA3S,OAAAyJ,IAAa,CAAzB,GAAI1I,GAAI4R,EAAAlJ,GAEP8mB,EAAO7zB,KAAKyzB,MAAOpvB,EAGV,KAATwvB,GAEF9X,EAAc1X,GAAO4C,EAAK5C,KAIxBtB,EAAGC,QAAQ6wB,IAEb9X,EAAc1X,EAAMwvB,GAIjB9wB,EAAGW,UAAUmwB,IAEhBF,EAAiBtvB,KAehBkvB,EAAA/xB,UAAAsyB,QAAP,SAA4Dlc,EAAamc,GAEvE,MAAInc,aAAoBR,GAEfpX,KAAKg0B,eAAe,SAAC3vB,GAAS,MAAAuT,GAAUvT,GAAOpB,OAAO8wB,GAItD/zB,KAAKg0B,eAAe,SAAC3vB,GAAS,MAAAuT,GAAUvT,IAAQ0vB,IAcpDR,EAAA/xB,UAAAwyB,eAAP,SAAsBC,EAAyDF,GAI7E,IAAiB,GAFbG,GAAmBnxB,EAAGW,UAAWqwB,GAEpBhnB,EAAA,EAAAkJ,EAAAsd,EAAQK,MAAR7mB,EAAAkJ,EAAA3S,OAAAyJ,IAAa,CAAzB,GAAI1I,GAAI4R,EAAAlJ,GAEP8mB,EAAO7zB,KAAKyzB,MAAOpvB,GACnBiJ,EAAO2mB,EAAc5vB,EAGzB,KAAa,IAATwvB,EAAJ,CAMA,IAAa,IAATA,IAAkBvmB,EAEpB,OAAO,CAIT,KAAKvK,EAAGW,UAAUmwB,IAASvmB,EAEzB,OAAO,CAIT,IAAIvK,EAAGS,SAASqwB,GAChB,CACE,IAAI9wB,EAAGC,QAAQsK,IAAoBA,EAAMhK,SAAWuwB,EASlD,OAAO,CAPP,IAAIK,IAAwE,IAAlD5mB,EAAMujB,QAAiBkD,EAAa1vB,IAE5D,OAAO,EAUb,GAAItB,EAAGC,QAAQ6wB,GACf,CACE,IAAK9wB,EAAGC,QAAQsK,GAEd,OAAO,CAGT,IAAIumB,EAAKvwB,SAAsBgK,EAAMhK,OAEnC,OAAO,CAGT,KAAK,GAAIhD,GAAI,EAAGA,EAAIuzB,EAAKvwB,OAAQhD,IAE/B,GAAIuzB,EAAMvzB,KAAQgN,EAAMhN,GAEtB,OAAO,CAIX,IAAI4zB,IAAoD,IAAzCL,EAAKhD,QAASkD,EAAa1vB,IAExC,OAAO,EAKX,GAAItB,EAAGU,SAASowB,GAChB,CACE,IAAK9wB,EAAGU,SAAS6J,GAEf,OAAO,CAGT,IAAI6mB,GAAaN,EAAK/V,QAAU,CAGhC,KAFuCxQ,EAAMwQ,QAAU,KAEpCqW,GAAc7mB,EAAKzJ,QAAUgwB,EAAKhwB,MAEnD,OAAO,CAGT,IAAIqwB,GAAoBH,EAAa1vB,GAASwvB,EAAKhwB,QAAWswB,EAE5D,OAAO,IAKb,OAAO,GAUKZ,EAAAa,SAAd,SAAuBxzB,GAErB,MAAOyzB,GAAYzzB,IAaP2yB,EAAAe,UAAd,SAAqErxB,EAAUsxB,EAA4BR,OAA5B,KAAAQ,OAAA,EAE7E,KAAoB,GAAAxnB,GAAA,EAAAynB,EAAAC,EAAA1nB,EAAAynB,EAAAlxB,OAAAyJ,IAAQ,CAAvB,GAAI8W,GAAO2Q,EAAAznB,EAEd,KAAK8W,EAAQ2P,SAAWe,IAAe1Q,EAAQiQ,QAAe7wB,EAAO8wB,GAEnE,MAAOlQ,GAIX,MAAO,OAtRK0P,EAAAK,OAEZ,YAAa,aAAc,iBAAkB,YAC7C,QAAS,OAAQ,OACjB,aAAc,iBAAkB,iBAAkB,qBAAsB,qBACxE,cAAe,kBAAmB,kBAAmB,sBAAuB,uBAoRhFL,KASWkB,GACT,GAAInB,GACF,QAAQ,EACR,SAACrsB,GAAa,0BAEZ4E,KAAM,EACNxE,MAAO,EACPqH,WAAY,IAGhB,GAAI4kB,GACF,SAAS,EACT,SAACrsB,GAAa,mBAKhB,GAAIqsB,GACF,UAAU,EACV,SAACrsB,GAAc,mBAAeA,EAAIoE,OAAO,UAEvCX,UAAW,IAGf,GAAI4oB,GACF,eAAe,EACf,SAACrsB,GAAa,wBAAoBwJ,EAAO4O,MAAMpY,EAAI8R,gBAAkB,GAAK,IAAM9R,EAAIoE,OAAO,UAEzFX,UAAW,EACXqO,gBAAiB,IAGrB,GAAIua,GACF,YAAY,EACZ,SAACrsB,GAAa,qBAAiBA,EAAIoE,OAAO,aAExChE,MAAO,EACPqH,WAAY,IAGhB,GAAI4kB,GACF,qBAAqB,EACrB,SAACrsB,GAAa,yBAAqBwJ,EAAO4O,MAAMpY,EAAI8R,gBAAkB,GAAK,IAAM9R,EAAIoE,OAAO,QAAU,OAASpE,EAAIoE,OAAO,UAExHhE,MAAO,EACPqD,UAAW,EACXqO,gBAAiB,IAGrB,GAAIua,GACF,WAAW,EACX,SAACrsB,GAAa,2CAEZyD,WAAYmoB,EAAQE,OAAQF,EAAQG,QAASH,EAAQI,UAAWJ,EAAQK,SAAUL,EAAQM,UAG9F,GAAIG,GACF,WAAW,EACX,SAACrsB,GAAa,wBAAoBA,EAAIoE,OAAO,MAAQ,SAEnDqD,WAAY,IAGhB,GAAI4kB,GACF,UAAU,EACV,SAACrsB,GAAa,oBAEZyD,WAAW,EACXgE,YAAY,EACZyK,gBAAgB,EAChBC,WAAW,EACXvN,MAAM,EACNxE,OAAO,EACPF,MAAM,EACNsR,YAAY,EACZE,gBAAgB,EAChBD,gBAAgB,EAChBG,oBAAoB,EACpBD,oBAAoB,EACpBE,aAAa,EACbC,iBAAiB,EACjBC,iBAAiB,EACjBC,qBAAqB,EACrBC,qBAAqB,KAUhBmb,KAESK,EAAA,EAAAC,EAAAF,EAAAC,EAAAC,EAAArxB,OAAAoxB,IAAQ,CAAvB,GAAIE,GAAOD,EAAAD,EAEdL,GAAYO,EAAQh0B,MAASg0B,EY9a/B,GAAAC,GAAA,mBAAAA,MA+IA,MAnIgBA,GAAAC,MAAd,SAA0B9wB,EAAwBC,GAEhD,MAAOD,GAAE6D,KAAKF,MAAME,KAAO5D,EAAE4D,KAAKF,MAAME,MAY5BgtB,EAAAE,IAAd,SAAwB/wB,EAAwBC,GAE9C,MAAOD,GAAE6D,KAAKD,IAAIC,KAAO5D,EAAE4D,KAAKD,IAAIC,MAaxBgtB,EAAAG,QAAd,SAA4BhxB,EAAwBC,GAKlD,OAHiBD,EAAE+V,QAAU,EAAI,IAChB9V,EAAE8V,QAAU,EAAI,IAgBrB8a,EAAAI,SAAd,SAA6BjxB,EAAwBC,GAEnD,MAAOD,GAAE6D,KAAKW,SAAWvE,EAAE4D,KAAKW,UAUpBqsB,EAAAK,KAAd,SAAyBhF,GAEvB,MAAO,UAAClsB,EAAGC,GAET,MAAOisB,GAAQjsB,EAAGD,KAYR6wB,EAAAM,aAAd,SAAiCC,GAE/B,MAAO,UAACpxB,EAAGC,GAET,GAAIoxB,GAAaD,EAAWpxB,EAAE0f,QAAW,GACrC4R,EAAaF,EAAWnxB,EAAEyf,QAAW,EAEzC,OAAO2R,GAAGE,cAAeD,KAYfT,EAAAW,QAAd,SAA4BC,GAE1B,MAAO,UAACzxB,EAAGC,GAKT,MAHiBwxB,GAAUzxB,EAAE0f,OACZ+R,EAAUxxB,EAAEyf,SAanBmR,EAAAa,KAAd,SAAyBC,GAEvB,MAAO,UAAC3xB,EAAGC,GAET,IAAmB,GAAA8I,GAAA,EAAA6oB,EAAAD,EAAA5oB,EAAA6oB,EAAAtyB,OAAAyJ,IAAO,CAArB,GAAImjB,GAAM0F,EAAA7oB,GAET8oB,EAAkB3F,EAAOlsB,EAAGC,EAEhC,IAAgB,IAAZ4xB,EAEF,MAAOA,GAIX,MAAO,KAIbhB,IvBg+M+B10B,GAAoBQ,EAAEiB,EAAqB,WAAY,WAAa,MAAO6pB,KAC3EtrB,EAAoBQ,EAAEiB,EAAqB,cAAe,WAAa,MAAOioB,KAC9E1pB,EAAoBQ,EAAEiB,EAAqB,gBAAiB,WAAa,MAAOmpB,KAChF5qB,EAAoBQ,EAAEiB,EAAqB,QAAS,WAAa,MAAO2e,KACxEpgB,EAAoBQ,EAAEiB,EAAqB,YAAa,WAAa,MAAOkD,KAC5E3E,EAAoBQ,EAAEiB,EAAqB,MAAO,WAAa,MAAOsJ,KACtE/K,EAAoBQ,EAAEiB,EAAqB,UAAW,WAAa,MAAO6F,KAC1EtH,EAAoBQ,EAAEiB,EAAqB,YAAa,WAAa,MAAOmB,KAC5E5C,EAAoBQ,EAAEiB,EAAqB,aAAc,WAAa,MAAO4K,KAC7ErM,EAAoBQ,EAAEiB,EAAqB,iBAAkB,WAAa,MAAO4O,KACjFrQ,EAAoBQ,EAAEiB,EAAqB,WAAY,WAAa,MAAOqP,KAC3E9Q,EAAoBQ,EAAEiB,EAAqB,QAAS,WAAa,MAAOkM,KACxE3N,EAAoBQ,EAAEiB,EAAqB,KAAM,WAAa,MAAOQ,KACrEjC,EAAoBQ,EAAEiB,EAAqB,UAAW,WAAa,MAAOC,KAC1E1B,EAAoBQ,EAAEiB,EAAqB,QAAS,WAAa,MAAO+V,KACxExX,EAAoBQ,EAAEiB,EAAqB,UAAW,WAAa,MAAO0xB,KAC1EnzB,EAAoBQ,EAAEiB,EAAqB,WAAY,WAAa,MAAO6yB,KAC3Et0B,EAAoBQ,EAAEiB,EAAqB,aAAc,WAAa,MAAOyyB,KAC7El0B,EAAoBQ,EAAEiB,EAAqB,WAAY,WAAa,MAAOwV,KAC3EjX,EAAoBQ,EAAEiB,EAAqB,mBAAoB,WAAa,MAAOoT,KACnF7U,EAAoBQ,EAAEiB,EAAqB,QAAS,WAAa,MAAOizB,KACxE10B,EAAoBQ,EAAEiB,EAAqB,SAAU,WAAa,MAAO6O,KACzEtQ,EAAoBQ,EAAEiB,EAAqB,OAAQ,WAAa,MAAO8e,KACvEvgB,EAAoBQ,EAAEiB,EAAqB,QAAS,WAAa,MAAOgD,KACxEzE,EAAoBQ,EAAEiB,EAAqB,UAAW,WAAa,MAAOixB","file":"dayspan.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"moment\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"ds\", [\"moment\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ds\"] = factory(require(\"moment\"));\n\telse\n\t\troot[\"ds\"] = factory(root[\"moment\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_0__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"moment\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"ds\", [\"moment\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ds\"] = factory(require(\"moment\"));\n\telse\n\t\troot[\"ds\"] = factory(root[\"moment\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_0__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 1);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_0__;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(2);\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n\n// CONCATENATED MODULE: ./src/Functions.ts\n\r\n/**\r\n * The class which contains commonly used functions by the library. These\r\n * functions and variables exist in a class so they may be overridden if\r\n * desired.\r\n */\r\nvar Functions = (function () {\r\n    function Functions() {\r\n    }\r\n    /**\r\n     * Determines whether the given input is an array.\r\n     *\r\n     * @param input The variable to test.\r\n     * @returns `true` if the variable is an array, otherwise `false`.\r\n     */\r\n    Functions.isArray = function (input) {\r\n        return input instanceof Array;\r\n    };\r\n    /**\r\n     * Determines whether the two arrays given are stricly equivalent. If the\r\n     * arrays are not the same length or contain the same values in the same order\r\n     * then `false` is returned.\r\n     *\r\n     * @param x The first array to test.\r\n     * @param y The second array to test.\r\n     * @returns `true` if they have the same exact values, otherwise `false`.\r\n     */\r\n    Functions.isArrayEquals = function (x, y) {\r\n        if (x === y)\r\n            return true;\r\n        if (x.length !== y.length)\r\n            return false;\r\n        for (var i = 0; i < x.length; i++) {\r\n            if (x[i] !== y[i]) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    };\r\n    /**\r\n     * Determines whether the given input is a string.\r\n     *\r\n     * @param input The variable to test.\r\n     * @returns `true` if the variable is a string, otherwise `false`.\r\n     */\r\n    Functions.isString = function (input) {\r\n        return typeof (input) === 'string';\r\n    };\r\n    /**\r\n     * Determines whether the given input is a finite number (a number which is\r\n     * not infinite or not the result of a divide-by-zero operation).\r\n     *\r\n     * @param input The variable to test.\r\n     * @returns `true` if the variable is a finite number, otherwise `false`.\r\n     */\r\n    Functions.isNumber = function (input) {\r\n        return isFinite(input) && typeof input === 'number';\r\n    };\r\n    /**\r\n     * Determines whether the given input is an object and NOT an array.\r\n     *\r\n     * @param input The variable to test.\r\n     * @returns `true` if the variable is a plain object, otherwise `false`.\r\n     */\r\n    Functions.isObject = function (input) {\r\n        return input !== null && !this.isArray(input) && typeof (input) === 'object';\r\n    };\r\n    /**\r\n     * Determines whether the given input is defined.\r\n     *\r\n     * @param input The variable to test.\r\n     * @return `true` if the variable is defined, otherwise `false`.\r\n     */\r\n    Functions.isDefined = function (input) {\r\n        return typeof (input) !== 'undefined';\r\n    };\r\n    /**\r\n     * Determines whether the given input is defined and not null.\r\n     *\r\n     * @param input The variable to test.\r\n     * @return `true` if the variable is defined and not null, otherwise `false`.\r\n     */\r\n    Functions.isValue = function (input) {\r\n        return input !== null && typeof (input) !== 'undefined';\r\n    };\r\n    /**\r\n     * Determines whether the given input appears to be a valid\r\n     * [[FrequencyValueEvery]].\r\n     *\r\n     * ```typescript\r\n     * Functions.isFrequencyValueEvery({});                   // false\r\n     * Functions.isFrequencyValueEvery([]);                   // false\r\n     * Functions.isFrequencyValueEvery([1]);                  // false\r\n     * Functions.isFrequencyValueEvery(null);                 // false\r\n     * Functions.isFrequencyValueEvery({every:2});            // true\r\n     * Functions.isFrequencyValueEvery({offset:1});           // false\r\n     * Functions.isFrequencyValueEvery({every:2, offset:1});  // true\r\n     * ```\r\n     *\r\n     * @param input The variable to test.\r\n     * @returns `true` if the variable appears to be a [[FrequencyValueEvery]],\r\n     *    otherwise false.\r\n     */\r\n    Functions.isFrequencyValueEvery = function (input) {\r\n        return this.isObject(input) && this.isNumber(input.every);\r\n    };\r\n    /**\r\n     * Determines whether the given input appears to be a valid\r\n     * [[FrequencyValueOneOf]].\r\n     *\r\n     * ```typescript\r\n     * Functions.isFrequencyValueOneOf({});    // false\r\n     * Functions.isFrequencyValueOneOf([]);    // false\r\n     * Functions.isFrequencyValueOneOf([1]);   // true\r\n     * Functions.isFrequencyValueOneOf(null);  // false\r\n     * ```\r\n     *\r\n     * @param input The variable to test.\r\n     * @returns `true` if the variable appears to be a [[FrequencyValueOneOf]],\r\n     *    otherwise false.\r\n     */\r\n    Functions.isFrequencyValueOneOf = function (input) {\r\n        return this.isArray(input) && input.length > 0;\r\n    };\r\n    /**\r\n     * Returns the first argument which is defined.\r\n     *\r\n     * ```typescript\r\n     * Functions.coalesce(3, 4);                // 3\r\n     * Functions.coalesce(undefined, 4);        // 4\r\n     * Functions.coalesce(null, 4);             // null\r\n     * Functions.coalesce(void 0, void 0, 5);   // 5\r\n     * ```\r\n     *\r\n     * @param a The first argument to look at.\r\n     * @param b The second argument to look at.\r\n     * @returns The first defined argument.\r\n     * @see [[Functions.isDefined]]\r\n     */\r\n    Functions.coalesce = function (a, b, c) {\r\n        return this.isDefined(a) ? a : (this.isDefined(b) ? b : c);\r\n    };\r\n    /**\r\n     * Copies values from `from` object and sets them to the `target` object.\r\n     *\r\n     * @param target The object to set values to.\r\n     * @param from The object to copy value references from.\r\n     * @returns The reference to `target`.\r\n     */\r\n    Functions.extend = function (target, from) {\r\n        for (var prop in from) {\r\n            target[prop] = from[prop];\r\n        }\r\n        return target;\r\n    };\r\n    /**\r\n     * Pads the string `x` up to `length` characters with the given `padding`\r\n     * optionally placing the `padding` `before` `x`.\r\n     *\r\n     * ```typescript\r\n     * Functions.pad('hey', 5, '_', false);   // 'hey__'\r\n     * Functions.pad('hey', 5, '_', true);    // '__hey'\r\n     * Functions.pad('heyman', 5, '_', true); // 'heyman'\r\n     * ```\r\n     *\r\n     * @param x The string to pad.\r\n     * @param length The length to pad to.\r\n     * @param padding The string to pad with.\r\n     * @param before If the padding should go before the string to pad.\r\n     * @returns The padded string if any padding needed be added.\r\n     */\r\n    Functions.pad = function (x, length, padding, before) {\r\n        while (x.length < length) {\r\n            before ? x = padding + x : x = x + padding;\r\n        }\r\n        return x;\r\n    };\r\n    /**\r\n     * Pads the number `x` up to `length` digits where the padding is `0` and it\r\n     * goes before `x`. This function will only return the first `length`\r\n     * characters of the padding string representation of the number but can return\r\n     * an alternative number of `first` characters.\r\n     *\r\n     * ```typescript\r\n     * Functions.padNumber(29, 3);      // '029'\r\n     * Functions.padNumber(29, 3, 2);   // '02'\r\n     * Functions.padNumber(9573, 3);    // '957'\r\n     * ```\r\n     *\r\n     * @param x The number to pad with zeros in the beginning.\r\n     * @param length The number of digits the number should be padded to.\r\n     * @param first The number of digits to return from the start of the string.\r\n     * @returns A padded number.\r\n     */\r\n    Functions.padNumber = function (x, length, first) {\r\n        if (first === void 0) { first = length; }\r\n        return this.pad(x + '', length, '0', true).substring(0, first);\r\n    };\r\n    return Functions;\r\n}());\r\n\r\n\n// CONCATENATED MODULE: ./src/Operation.ts\n\r\n/**\r\n * An operation that can be performed on a single number.\r\n */\r\nvar Op;\r\n(function (Op) {\r\n    /**\r\n     * The number is returned unmodified.\r\n     */\r\n    Op[Op[\"NONE\"] = 0] = \"NONE\";\r\n    /**\r\n     * The number is rounded down to the nearest whole number.\r\n     */\r\n    Op[Op[\"FLOOR\"] = 1] = \"FLOOR\";\r\n    /**\r\n     * The number is rounded up to the nearest whole number.\r\n     */\r\n    Op[Op[\"CEIL\"] = 2] = \"CEIL\";\r\n    /**\r\n     * The number is rounded up or down depending on if the fractional value is\r\n     * greater than or less than 0.5 respectively.\r\n     */\r\n    Op[Op[\"ROUND\"] = 3] = \"ROUND\";\r\n    /**\r\n     * The fractional part of the number is dropped.\r\n     */\r\n    Op[Op[\"TRUNCATE\"] = 4] = \"TRUNCATE\";\r\n    /**\r\n     * The number is rounded up when positive and down when negative. This is\r\n     * effectively ceiling the absolute value where the result preserves the sign.\r\n     */\r\n    Op[Op[\"UP\"] = 5] = \"UP\";\r\n    /**\r\n     * The number is rounded down when positive and up when negative. This is\r\n     * effectively floor the absolute value where the result preserves the sign.\r\n     */\r\n    Op[Op[\"DOWN\"] = 6] = \"DOWN\";\r\n})(Op = Op || (Op = {}));\r\n/**\r\n * Performs the requested operation on the given number, optionally taking\r\n * the absolute value of the number before the operation.\r\n *\r\n * @param value The number to operate on.\r\n * @param op The operation to perform.\r\n * @param absolute If the number should be positive before the operation.\r\n * @return The operated result, or the original value if its not a valid number.\r\n */\r\nfunction operate(value, op, absolute) {\r\n    if (absolute === void 0) { absolute = false; }\r\n    if (isFinite(value)) {\r\n        if (absolute) {\r\n            value = Math.abs(value);\r\n        }\r\n        switch (op) {\r\n            case Op.NONE:\r\n                return value;\r\n            case Op.FLOOR:\r\n                return Math.floor(value);\r\n            case Op.CEIL:\r\n                return Math.ceil(value);\r\n            case Op.ROUND:\r\n                return Math.round(value);\r\n            case Op.TRUNCATE:\r\n            case Op.DOWN:\r\n                return value < 0 ? Math.ceil(value) : Math.floor(value);\r\n            case Op.UP:\r\n                return value < 0 ? Math.floor(value) : Math.ceil(value);\r\n        }\r\n    }\r\n    return value;\r\n}\r\n\n// CONCATENATED MODULE: ./src/Units.ts\n\r\n/**\r\n * Units of time that are compromised of 1 or more days for the [[Calendar]] class.\r\n */\r\nvar Units;\r\n(function (Units) {\r\n    Units[Units[\"DAY\"] = 0] = \"DAY\";\r\n    Units[Units[\"WEEK\"] = 1] = \"WEEK\";\r\n    Units[Units[\"MONTH\"] = 2] = \"MONTH\";\r\n    Units[Units[\"YEAR\"] = 3] = \"YEAR\";\r\n})(Units = Units || (Units = {}));\r\n\n// CONCATENATED MODULE: ./src/Constants.ts\n\r\n/**\r\n * A class that stores commonly used values.\r\n */\r\nvar Constants = (function () {\r\n    function Constants() {\r\n    }\r\n    /**\r\n     * The number of milliseconds in a second.\r\n     */\r\n    Constants.MILLIS_IN_SECOND = 1000;\r\n    /**\r\n     * The number of milliseconds in a minute.\r\n     */\r\n    Constants.MILLIS_IN_MINUTE = Constants.MILLIS_IN_SECOND * 60;\r\n    /**\r\n     * The number of milliseconds in an hour.\r\n     */\r\n    Constants.MILLIS_IN_HOUR = Constants.MILLIS_IN_MINUTE * 60;\r\n    /**\r\n     * The number of milliseconds in a day (not including DST days).\r\n     */\r\n    Constants.MILLIS_IN_DAY = Constants.MILLIS_IN_HOUR * 24;\r\n    /**\r\n     * The number of milliseconds in a week (not including ones that include DST).\r\n     */\r\n    Constants.MILLIS_IN_WEEK = Constants.MILLIS_IN_DAY * 7;\r\n    /**\r\n     * The number of minutes in an hour.\r\n     */\r\n    Constants.MINUTES_IN_HOUR = 60;\r\n    /**\r\n     * The number of minutes in a day (not including DST days).\r\n     */\r\n    Constants.MINUTES_IN_DAY = 60 * 24;\r\n    /**\r\n     * The number of days in a week.\r\n     */\r\n    Constants.DAYS_IN_WEEK = 7;\r\n    /**\r\n     * The number of months in a year.\r\n     */\r\n    Constants.MONTHS_IN_YEAR = 12;\r\n    /**\r\n     * The number of hours in a day (not including DST days).\r\n     */\r\n    Constants.HOURS_IN_DAY = 24;\r\n    /**\r\n     * The first month of the year.\r\n     */\r\n    Constants.MONTH_MIN = 0;\r\n    /**\r\n     * The last month of the year.\r\n     */\r\n    Constants.MONTH_MAX = 11;\r\n    /**\r\n     * The first day of a month.\r\n     */\r\n    Constants.DAY_MIN = 1;\r\n    /**\r\n     * The last day of the longest month.\r\n     */\r\n    Constants.DAY_MAX = 31;\r\n    /**\r\n     * The first hour of the day.\r\n     */\r\n    Constants.HOUR_MIN = 0;\r\n    /**\r\n     * The last hour of the day.\r\n     */\r\n    Constants.HOUR_MAX = 23;\r\n    /**\r\n     * The first minute of the hour.\r\n     */\r\n    Constants.MINUTE_MIN = 0;\r\n    /**\r\n     * The last minute of the hour.\r\n     */\r\n    Constants.MINUTE_MAX = 59;\r\n    /**\r\n     * The first second of the minute.\r\n     */\r\n    Constants.SECOND_MIN = 0;\r\n    /**\r\n     * The last second of the minute.\r\n     */\r\n    Constants.SECOND_MAX = 59;\r\n    /**\r\n     * The first millisecond of the second.\r\n     */\r\n    Constants.MILLIS_MIN = 0;\r\n    /**\r\n     * The last millisecond of the second.\r\n     */\r\n    Constants.MILLIS_MAX = 999;\r\n    /**\r\n     * The first day of the week.\r\n     */\r\n    Constants.WEEKDAY_MIN = 0;\r\n    /**\r\n     * The last day of the week.\r\n     */\r\n    Constants.WEEKDAY_MAX = 6;\r\n    /**\r\n     * The default duration for an event.\r\n     */\r\n    Constants.DURATION_DEFAULT = 1;\r\n    /**\r\n     * The default duration unit for an all day event.\r\n     */\r\n    Constants.DURATION_DEFAULT_UNIT_ALL = 'days';\r\n    /**\r\n     * The default duration unit for an event at a given time.\r\n     */\r\n    Constants.DURATION_DEFAULT_UNIT_TIMES = 'hours';\r\n    /**\r\n     * Computes the duration unit given its for an all day event.\r\n     *\r\n     * @param all If the event is all day.\r\n     * @return The default unit for the event.\r\n     */\r\n    Constants.DURATION_DEFAULT_UNIT = function (all) { return all ? Constants.DURATION_DEFAULT_UNIT_ALL :\r\n        Constants.DURATION_DEFAULT_UNIT_TIMES; };\r\n    /**\r\n     * The number of milliseconds for various duration units. These are worse case\r\n     * scenario and do not include DST changes.\r\n     */\r\n    Constants.DURATION_TO_MILLIS = {\r\n        minute: Constants.MILLIS_IN_MINUTE,\r\n        minutes: Constants.MILLIS_IN_MINUTE,\r\n        hour: Constants.MILLIS_IN_HOUR,\r\n        hours: Constants.MILLIS_IN_HOUR,\r\n        day: Constants.MILLIS_IN_DAY,\r\n        days: Constants.MILLIS_IN_DAY,\r\n        week: Constants.MILLIS_IN_WEEK,\r\n        weeks: Constants.MILLIS_IN_WEEK,\r\n        month: Constants.MILLIS_IN_DAY * Constants.DAY_MAX,\r\n        months: Constants.MILLIS_IN_DAY * Constants.DAY_MAX\r\n    };\r\n    /**\r\n     * The maximum estimated number of events per day. This is used to calculate\r\n     * [[CalendarEvent.id]] to give each event a unique ID. If you think you will\r\n     * have more events than this per day, you can enlarge the value.\r\n     */\r\n    Constants.MAX_EVENTS_PER_DAY = 24;\r\n    /**\r\n     * The day of the week which determines the first week of the year or month.\r\n     * By default this day is Thursday.\r\n     */\r\n    Constants.WEEK_OF_MONTH_MINIMUM_WEEKDAY = 4;\r\n    return Constants;\r\n}());\r\n\r\n\n// CONCATENATED MODULE: ./src/DaySpan.ts\n\r\n\r\n\r\n\r\n\r\n/**\r\n * A class for a range of time between two [[Day]] timestamps.\r\n */\r\nvar DaySpan_DaySpan = (function () {\r\n    /**\r\n     * Creates a new span of time.\r\n     *\r\n     * @param start The starting timestamp.\r\n     * @param end The ending timestamp.\r\n     */\r\n    function DaySpan(start, end) {\r\n        this.start = start;\r\n        this.end = end;\r\n    }\r\n    Object.defineProperty(DaySpan.prototype, \"isPoint\", {\r\n        /**\r\n         * Whether this span starts and ends on the same timestamp.\r\n         */\r\n        get: function () {\r\n            return this.start.time === this.end.time;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Determines whether the given timestamp lies between the start and end\r\n     * timestamp.\r\n     *\r\n     * @param day The timestamp to test.\r\n     * @returns True if the day is >= the start and <= the end of this span.\r\n     */\r\n    DaySpan.prototype.contains = function (day) {\r\n        return day.time >= this.start.time && day.time <= this.end.time;\r\n    };\r\n    /**\r\n     * Compares the given timestamp to this span. If the timestamp is before this\r\n     * span then `-1` is returned, if the timestamp is after this span then `1`\r\n     * us returned, otherwise `0` is returned when the timestamp is in this span.\r\n     *\r\n     * @param day The timestamp to compare to.\r\n     * @returns `-1`, `0`, or `1` depending on the given timestamp relative to\r\n     *    this span.\r\n     */\r\n    DaySpan.prototype.compareTo = function (day) {\r\n        return day.time < this.start.time ? -1 : (day.time > this.end.time ? 1 : 0);\r\n    };\r\n    /**\r\n     * Determines whether the given timestamp is between the start and end\r\n     * timestamp or lies on the same day as the start or end timestamp.\r\n     *\r\n     * @param day The timestamp to test.\r\n     * @see [[Day.sameDay]]\r\n     */\r\n    DaySpan.prototype.matchesDay = function (day) {\r\n        return this.contains(day) || day.sameDay(this.start) || day.sameDay(this.end);\r\n    };\r\n    /**\r\n     * Determines whether the given timestamp is between the start and end\r\n     * timestamp or lies on the same week as the start or end timestamp.\r\n     *\r\n     * @param day The timestamp to test.\r\n     * @see [[Day.sameWeek]]\r\n     */\r\n    DaySpan.prototype.matchesWeek = function (day) {\r\n        return this.contains(day) || day.sameWeek(this.start) || day.sameWeek(this.end);\r\n    };\r\n    /**\r\n     * Determines whether the given timestamp is between the start and end\r\n     * timestamp or lies on the same month as the start or end timestamp.\r\n     *\r\n     * @param day The timestamp to test.\r\n     * @see [[Day.sameMonth]]\r\n     */\r\n    DaySpan.prototype.matchesMonth = function (day) {\r\n        return this.contains(day) || day.sameMonth(this.start) || day.sameMonth(this.end);\r\n    };\r\n    /**\r\n     * Determines whether the given timestamp is between the start and end\r\n     * timestamp or lies on the same year as the start or end timestamp.\r\n     *\r\n     * @param day The timestamp to test.\r\n     * @see [[Day.sameYear]]\r\n     */\r\n    DaySpan.prototype.matchesYear = function (day) {\r\n        return this.contains(day) || day.sameYear(this.start) || day.sameYear(this.end);\r\n    };\r\n    /**\r\n     * Calculates the number of milliseconds between the start and end timestamp.\r\n     *\r\n     * @param op The operation to perform on the result.\r\n     * @param absolute Whether the result should always be positive.\r\n     * @returns The time between the start and end timestamp.\r\n     * @see [[Day.millisBetween]]\r\n     */\r\n    DaySpan.prototype.millis = function (op, absolute) {\r\n        if (op === void 0) { op = Op.DOWN; }\r\n        if (absolute === void 0) { absolute = true; }\r\n        return this.start.millisBetween(this.end, op, absolute);\r\n    };\r\n    /**\r\n     * Calculates the number of seconds between the start and end timestamp.\r\n     *\r\n     * @param op The operation to perform on the result.\r\n     * @param absolute Whether the result should always be positive.\r\n     * @returns The time between the start and end timestamp.\r\n     * @see [[Day.secondsBetween]]\r\n     */\r\n    DaySpan.prototype.seconds = function (op, absolute) {\r\n        if (op === void 0) { op = Op.DOWN; }\r\n        if (absolute === void 0) { absolute = true; }\r\n        return this.start.secondsBetween(this.end, op, absolute);\r\n    };\r\n    /**\r\n     * Calculates the number of minutes between the start and end timestamp.\r\n     *\r\n     * @param op The operation to perform on the result.\r\n     * @param absolute Whether the result should always be positive.\r\n     * @returns The time between the start and end timestamp.\r\n     * @see [[Day.minutesBetween]]\r\n     */\r\n    DaySpan.prototype.minutes = function (op, absolute) {\r\n        if (op === void 0) { op = Op.DOWN; }\r\n        if (absolute === void 0) { absolute = true; }\r\n        return this.start.minutesBetween(this.end, op, absolute);\r\n    };\r\n    /**\r\n     * Calculates the number of hours between the start and end timestamp.\r\n     *\r\n     * @param op The operation to perform on the result.\r\n     * @param absolute Whether the result should always be positive.\r\n     * @returns The time between the start and end timestamp.\r\n     * @see [[Day.hoursBetween]]\r\n     */\r\n    DaySpan.prototype.hours = function (op, absolute) {\r\n        if (op === void 0) { op = Op.DOWN; }\r\n        if (absolute === void 0) { absolute = true; }\r\n        return this.start.hoursBetween(this.end, op, absolute);\r\n    };\r\n    /**\r\n     * Calculates the number of days between the start and end timestamp.\r\n     *\r\n     * @param op The operation to perform on the result.\r\n     * @param absolute Whether the result should always be positive.\r\n     * @returns The time between the start and end timestamp.\r\n     * @see [[Day.daysBetween]]\r\n     */\r\n    DaySpan.prototype.days = function (op, absolute) {\r\n        if (op === void 0) { op = Op.DOWN; }\r\n        if (absolute === void 0) { absolute = true; }\r\n        return this.start.daysBetween(this.end, op, absolute);\r\n    };\r\n    /**\r\n     * Calculates the number of weeks between the start and end timestamp.\r\n     *\r\n     * @param op The operation to perform on the result.\r\n     * @param absolute Whether the result should always be positive.\r\n     * @returns The time between the start and end timestamp.\r\n     * @see [[Day.weeksBetween]]\r\n     */\r\n    DaySpan.prototype.weeks = function (op, absolute) {\r\n        if (op === void 0) { op = Op.DOWN; }\r\n        if (absolute === void 0) { absolute = true; }\r\n        return this.start.weeksBetween(this.end, op, absolute);\r\n    };\r\n    /**\r\n     * Calculates the number of months between the start and end timestamp.\r\n     *\r\n     * @param op The operation to perform on the result.\r\n     * @param absolute Whether the result should always be positive.\r\n     * @returns The time between the start and end timestamp.\r\n     * @see [[Day.monthsBetween]]\r\n     */\r\n    DaySpan.prototype.months = function (op, absolute) {\r\n        if (op === void 0) { op = Op.DOWN; }\r\n        if (absolute === void 0) { absolute = true; }\r\n        return this.start.monthsBetween(this.end, op, absolute);\r\n    };\r\n    /**\r\n     * Calculates the number of years between the start and end timestamp.\r\n     *\r\n     * @param op The operation to perform on the result.\r\n     * @param absolute Whether the result should always be positive.\r\n     * @returns The time between the start and end timestamp.\r\n     * @see [[Day.yearsBetween]]\r\n     */\r\n    DaySpan.prototype.years = function (op, absolute) {\r\n        if (op === void 0) { op = Op.DOWN; }\r\n        if (absolute === void 0) { absolute = true; }\r\n        return this.start.yearsBetween(this.end, op, absolute);\r\n    };\r\n    /**\r\n     * Returns a delta value between 0 and 1 which represents where the\r\n     * [[DaySpan.start]] is relative to the given day. The delta value would\r\n     * be less than 0 if the start of the event is before the given day.\r\n     *\r\n     * @param relativeTo The day to find the start delta relative to.\r\n     * @return A number between 0 and 1 if the start of this span is in the\r\n     *    24-hour period starting at the given timestamp, otherwise the value\r\n     *    returned may be less than 0 or greater than 1.\r\n     */\r\n    DaySpan.prototype.startDelta = function (relativeTo) {\r\n        return (this.start.time - relativeTo.time) / Constants.MILLIS_IN_DAY;\r\n    };\r\n    /**\r\n     * Returns a delta value between 0 and 1 which represents where the\r\n     * [[DaySpan.end]] is relative to the given day. The delta value would\r\n     * be greater than 1 if the end of the event is after the given day.\r\n     *\r\n     * @param relativeTo The day to find the end delta relative to.\r\n     * @return A number between 0 and 1 if the end of this span is in the\r\n     *    24-hour period starting at the given timestamp, otherwise the value\r\n     *    returned may be less than 0 or greater than 1.\r\n     */\r\n    DaySpan.prototype.endDelta = function (relativeTo) {\r\n        return (this.end.time - relativeTo.time) / Constants.MILLIS_IN_DAY;\r\n    };\r\n    /**\r\n     * Calculates the bounds for span event if it were placed in a rectangle which\r\n     * represents a day (24 hour period). By default the returned values are\r\n     * between 0 and 1 and can be scaled by the proper rectangle dimensions or the\r\n     * rectangle dimensions can be passed to this function.\r\n     *\r\n     * @param relativeTo The day to find the bounds relative to. If this is not the\r\n     *    start of the day the returned bounds is relative to the given time.\r\n     * @param dayHeight The height of the rectangle of the day.\r\n     * @param dayWidth The width of the rectangle of the day.\r\n     * @param columnOffset The offset in the rectangle of the day to adjust this\r\n     *    span by.\r\n     * @param columnWidth The width of event span\r\n     * @param clip `true` if the bounds should stay in the day rectangle, `false`\r\n     *    and the bounds may go outside the rectangle of the day for multi-day\r\n     *    spans.\r\n     * @param offsetX How much to translate the left & right properties by.\r\n     * @param offsetY How much to translate the top & bottom properties by.\r\n     * @returns The calculated bounds for this span.\r\n     */\r\n    DaySpan.prototype.getBounds = function (relativeTo, dayHeight, dayWidth, columnOffset, columnWidth, clip, offsetX, offsetY) {\r\n        if (dayHeight === void 0) { dayHeight = 1; }\r\n        if (dayWidth === void 0) { dayWidth = 1; }\r\n        if (columnOffset === void 0) { columnOffset = 0; }\r\n        if (columnWidth === void 0) { columnWidth = 1; }\r\n        if (clip === void 0) { clip = true; }\r\n        if (offsetX === void 0) { offsetX = 0; }\r\n        if (offsetY === void 0) { offsetY = 0; }\r\n        var startRaw = this.startDelta(relativeTo);\r\n        var endRaw = this.endDelta(relativeTo);\r\n        var start = clip ? Math.max(0, startRaw) : startRaw;\r\n        var end = clip ? Math.min(1, endRaw) : endRaw;\r\n        var left = columnOffset;\r\n        var right = dayWidth - left;\r\n        var width = columnWidth || 1;\r\n        var top = start * dayHeight;\r\n        var bottom = end * dayHeight;\r\n        return {\r\n            top: top + offsetY,\r\n            bottom: bottom + offsetY,\r\n            height: bottom - top,\r\n            left: left + offsetX,\r\n            right: right + offsetX,\r\n            width: width\r\n        };\r\n    };\r\n    /**\r\n     * Summarizes this span given an approximate unit of time and a few other\r\n     * options. If the start and end are on the same unit, a single value will\r\n     * be returned. Otherwise a start and end will be returned with a `delimiter`.\r\n     *\r\n     * @param type The unit of time this span is for.\r\n     * @param dayOfWeek When `true` the weekday of the start and end are included.\r\n     * @param short When `true` the short form of weekdays and months will be used.\r\n     * @param repeat When `true` the year will be repeated on the start and end\r\n     *  timestamp even if they are the same year.\r\n     * @param contextual When `true` the year will be hidden if it's the current\r\n     *  year.\r\n     * @param delimiter The string to separate the start and end timestamps with.\r\n     * @returns The summary of this span.\r\n     */\r\n    DaySpan.prototype.summary = function (type, dayOfWeek, short, repeat, contextual, delimiter) {\r\n        if (dayOfWeek === void 0) { dayOfWeek = true; }\r\n        if (short === void 0) { short = false; }\r\n        if (repeat === void 0) { repeat = false; }\r\n        if (contextual === void 0) { contextual = true; }\r\n        if (delimiter === void 0) { delimiter = ' - '; }\r\n        var formats = DaySpan.SUMMARY_FORMATS[type];\r\n        var today = Day_Day.today();\r\n        var showStartYear = !contextual || !this.start.sameYear(today);\r\n        var showEndYear = !contextual || !this.end.sameYear(today);\r\n        var start = this.start.format(formats(short, dayOfWeek, showStartYear));\r\n        var end = this.end.format(formats(short, dayOfWeek, showEndYear));\r\n        var summary = start;\r\n        if (start !== end) {\r\n            if (!repeat) {\r\n                summary = this.start.format(formats(short, dayOfWeek, !this.start.sameYear(this.end)));\r\n            }\r\n            summary += delimiter;\r\n            summary += end;\r\n        }\r\n        else {\r\n            summary = start;\r\n        }\r\n        return summary;\r\n    };\r\n    /**\r\n     * Determines whether the gven span intersects with this span.\r\n     *\r\n     * @param span The span to test.\r\n     * @returns `true` if the spans intersect, otherwise `false`.\r\n     */\r\n    DaySpan.prototype.intersects = function (span) {\r\n        return !(this.end.time < span.start.time ||\r\n            this.start.time > span.end.time);\r\n    };\r\n    /**\r\n     * Calculates the intersection between this span and the given span. If there\r\n     * is no intersection between the two spans then `null` is returned.\r\n     *\r\n     * @param span The span to calculate the intersection with.\r\n     * @returns The intersection or `null` if none exists.\r\n     */\r\n    DaySpan.prototype.intersection = function (span) {\r\n        var start = this.start.max(span.start);\r\n        var end = this.end.min(span.end);\r\n        return start.isAfter(end) ? null : new DaySpan(start, end);\r\n    };\r\n    /**\r\n     * Calculates the union between this span and the given span.\r\n     *\r\n     * @param span The span to calculate the union with.\r\n     * @returns The union of the two spans.\r\n     */\r\n    DaySpan.prototype.union = function (span) {\r\n        var start = this.start.min(span.start);\r\n        var end = this.end.max(span.end);\r\n        return new DaySpan(start, end);\r\n    };\r\n    /**\r\n     * Returns a point [[DaySpan]] with the same start and end timestamp.\r\n     *\r\n     * @param day The timestamp which will be the start and end.\r\n     * @returns The new instance.\r\n     * @see [[DaySpan.isPoint]]\r\n     */\r\n    DaySpan.point = function (day) {\r\n        return new DaySpan(day, day);\r\n    };\r\n    /**\r\n     * Formatting functions which assist the [[DaySpan.summary]] function.\r\n     */\r\n    DaySpan.SUMMARY_FORMATS = (DaySpan__a = {},\r\n        DaySpan__a[Units.DAY] = function (short, dayOfWeek, year) {\r\n            return (dayOfWeek ? (short ? 'ddd, ' : 'dddd, ') : '') + (short ? 'MMM ' : 'MMMM ') + 'Do' + (year ? ' YYYY' : '');\r\n        },\r\n        DaySpan__a[Units.WEEK] = function (short, dayOfWeek, year) {\r\n            return (dayOfWeek ? (short ? 'ddd, ' : 'dddd, ') : '') + (short ? 'MMM ' : 'MMMM ') + 'Do' + (year ? ' YYYY' : '');\r\n        },\r\n        DaySpan__a[Units.MONTH] = function (short, dayOfWeek, year) {\r\n            return (short ? 'MMM' : 'MMMM') + (year ? ' YYYY' : '');\r\n        },\r\n        DaySpan__a[Units.YEAR] = function (short, dayOfWeek, year) {\r\n            return (year ? 'YYYY' : '');\r\n        },\r\n        DaySpan__a);\r\n    return DaySpan;\r\n}());\r\n\r\nvar DaySpan__a;\r\n\n// CONCATENATED MODULE: ./src/Identifier.ts\n\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\n\r\n\r\n\r\n/**\r\n * A class for detecting, parsing, and building identifiers to and from days.\r\n *\r\n * An identifier is a simple value which represents a span of time. It may\r\n * represent an entire year, a quarter (3 months) of a year, a week of a year,\r\n * a month in a year, a specific day of a month of a year, or a specific hour,\r\n * minute, day, and month of a year.\r\n *\r\n * For example:\r\n * - `2018`: The year 2018\r\n * - `201801`: January 2018\r\n * - `2014023`: The 23rd week of 2014\r\n * - `20170311`: March 11th, 2017\r\n * - `201406151651`: June 15th 2016 at 4:51 pm\r\n * - `'0525'`: Year 525 of the first age, Elrond and Elros are born\r\n */\r\nvar Identifier_Identifier = (function () {\r\n    function Identifier() {\r\n    }\r\n    /**\r\n     * Determines whether the given identifier is this type.\r\n     *\r\n     * @param id The identifier to test.\r\n     * @returns `true` if the identifier is this type, otherwise `false`.\r\n     */\r\n    Identifier.prototype.is = function (id) {\r\n        return (id + '').length === this.getLength();\r\n    };\r\n    /**\r\n     * Computes the identifier given values taken from a [[Day]].\r\n     *\r\n     * @param values The values to compute.\r\n     * @returns The computed identifier.\r\n     */\r\n    Identifier.prototype.compute = function () {\r\n        var values = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            values[_i] = arguments[_i];\r\n        }\r\n        var scales = this.getScales();\r\n        var total = 0;\r\n        for (var i = 0; i < values.length; i++) {\r\n            total += values[i] * scales[i];\r\n        }\r\n        return this.is(total) ? total : Functions.padNumber(total, this.getLength());\r\n    };\r\n    /**\r\n     * Decomputes the given identifier and returns values which describe a span\r\n     * of time.\r\n     *\r\n     * @param id The identifier to decompute.\r\n     * @returns The original values which computed the identifier.\r\n     */\r\n    Identifier.prototype.decompute = function (id) {\r\n        var scales = this.getScales();\r\n        var total = Functions.isNumber(id) ? id : parseInt(id);\r\n        var values = [];\r\n        for (var i = 0; i < scales.length - 1; i++) {\r\n            var curr = scales[i + 0];\r\n            var next = scales[i + 1];\r\n            var mod = next / curr;\r\n            var value = total % mod;\r\n            values.push(value);\r\n            total = Math.floor(total / mod);\r\n        }\r\n        values.push(total);\r\n        return values;\r\n    };\r\n    /**\r\n     * Finds which identifier type matches the given identifier, if any.\r\n     *\r\n     * @param id The identifier to find the type of.\r\n     * @returns The found identifier type, otherwise `null` if none exists.\r\n     */\r\n    Identifier.find = function (id) {\r\n        if (this.Time.is(id))\r\n            return this.Time;\r\n        if (this.Day.is(id))\r\n            return this.Day;\r\n        if (this.Week.is(id))\r\n            return this.Week;\r\n        if (this.Month.is(id))\r\n            return this.Month;\r\n        if (this.Year.is(id))\r\n            return this.Year;\r\n        return null;\r\n    };\r\n    /**\r\n     * Determines whether the given time span `outer` contains the time span\r\n     * `inner`.\r\n     *\r\n     * @param outer The potentially larger time span `inner` must be contained in.\r\n     * @param inner The time span to test is contained inside `outer`.\r\n     * @returns `true` if `inner` is equal to or contained in `outer`, otherwise\r\n     *    `false`.\r\n     */\r\n    Identifier.contains = function (outer, inner) {\r\n        var outerString = outer + '';\r\n        return (inner + '').substring(0, outerString.length) === outerString;\r\n    };\r\n    /**\r\n     * The identifier type for an hour of time on a specific day.\r\n     */\r\n    Identifier.Time = null;\r\n    /**\r\n     * The identifier type for a specific day.\r\n     */\r\n    Identifier.Day = null;\r\n    /**\r\n     * The identifier type for a specific week of a year.\r\n     */\r\n    Identifier.Week = null;\r\n    /**\r\n     * The identifier type for a specific month of a year.\r\n     */\r\n    Identifier.Month = null;\r\n    /**\r\n     * The identifier type for a specific quarter of a year.\r\n     */\r\n    Identifier.Quarter = null;\r\n    /**\r\n     * The identifier type for a specific year.\r\n     */\r\n    Identifier.Year = null;\r\n    return Identifier;\r\n}());\r\n\r\n// YYYYMMddHHmm (12)\r\nvar Identifier_IdentifierTime = (function (_super) {\r\n    __extends(IdentifierTime, _super);\r\n    function IdentifierTime() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    IdentifierTime.prototype.getScales = function () {\r\n        return IdentifierTime.SCALES;\r\n    };\r\n    IdentifierTime.prototype.getLength = function () {\r\n        return IdentifierTime.LENGTH;\r\n    };\r\n    IdentifierTime.prototype.get = function (day) {\r\n        return this.compute(day.minute, day.hour, day.dayOfMonth, day.month + 1, day.year);\r\n    };\r\n    IdentifierTime.prototype.object = function (id) {\r\n        var values = this.decompute(id);\r\n        return {\r\n            minute: values[0],\r\n            hour: values[1],\r\n            day: values[2],\r\n            month: values[3] - 1,\r\n            year: values[4]\r\n        };\r\n    };\r\n    IdentifierTime.prototype.start = function (id) {\r\n        var obj = this.object(id);\r\n        var start = Day_Day.build(obj.year, obj.month, obj.day, obj.hour, obj.minute);\r\n        return start;\r\n    };\r\n    IdentifierTime.prototype.span = function (id, endInclusive) {\r\n        if (endInclusive === void 0) { endInclusive = false; }\r\n        var start = this.start(id);\r\n        var end = start.endOfHour(endInclusive);\r\n        return new DaySpan_DaySpan(start, end);\r\n    };\r\n    IdentifierTime.prototype.describe = function (id, short) {\r\n        if (short === void 0) { short = false; }\r\n        var start = this.start(id);\r\n        var format = short ? IdentifierTime.DESCRIBE_FORMAT_SHORT : IdentifierTime.DESCRIBE_FORMAT_LONG;\r\n        return start.format(format);\r\n    };\r\n    IdentifierTime.prototype.matches = function (day, id) {\r\n        return day.timeIdentifier === id;\r\n        /*\r\n        let obj: IdentifierObject = this.object(id);\r\n    \n        return (\r\n          day.year === obj.year &&\r\n          day.month === obj.month &&\r\n          day.dayOfMonth === obj.day &&\r\n          day.hour === obj.hour &&\r\n          day.minute === obj.minute\r\n        );\r\n        */\r\n    };\r\n    IdentifierTime.DESCRIBE_FORMAT_LONG = 'LLL';\r\n    IdentifierTime.DESCRIBE_FORMAT_SHORT = 'lll';\r\n    IdentifierTime.SCALES = [\r\n        1 /* minute */,\r\n        100 /* hour   */,\r\n        10000 /* day    */,\r\n        1000000 /* month  */,\r\n        100000000 /* year   */\r\n    ];\r\n    IdentifierTime.LENGTH = 12;\r\n    return IdentifierTime;\r\n}(Identifier_Identifier));\r\n// YYYYMMdd (8)\r\nvar Identifier_IdentifierDay = (function (_super) {\r\n    __extends(IdentifierDay, _super);\r\n    function IdentifierDay() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    IdentifierDay.prototype.getScales = function () {\r\n        return IdentifierDay.SCALES;\r\n    };\r\n    IdentifierDay.prototype.getLength = function () {\r\n        return IdentifierDay.LENGTH;\r\n    };\r\n    IdentifierDay.prototype.get = function (day) {\r\n        return this.compute(day.dayOfMonth, day.month + 1, day.year);\r\n    };\r\n    IdentifierDay.prototype.object = function (id) {\r\n        var values = this.decompute(id);\r\n        return {\r\n            day: values[0],\r\n            month: values[1] - 1,\r\n            year: values[2]\r\n        };\r\n    };\r\n    IdentifierDay.prototype.start = function (id) {\r\n        var obj = this.object(id);\r\n        var start = Day_Day.build(obj.year, obj.month, obj.day);\r\n        return start;\r\n    };\r\n    IdentifierDay.prototype.span = function (id, endInclusive) {\r\n        if (endInclusive === void 0) { endInclusive = false; }\r\n        var start = this.start(id);\r\n        var end = start.end(endInclusive);\r\n        return new DaySpan_DaySpan(start, end);\r\n    };\r\n    IdentifierDay.prototype.describe = function (id, short) {\r\n        if (short === void 0) { short = false; }\r\n        var start = this.start(id);\r\n        var format = short ? IdentifierDay.DESCRIBE_FORMAT_SHORT : IdentifierDay.DESCRIBE_FORMAT_LONG;\r\n        return start.format(format);\r\n    };\r\n    IdentifierDay.prototype.matches = function (day, id) {\r\n        return day.dayIdentifier === id;\r\n        /*\r\n        let obj: IdentifierObject = this.object(id);\r\n    \n        return (\r\n          day.year === obj.year &&\r\n          day.month === obj.month &&\r\n          day.dayOfMonth === obj.day\r\n        );\r\n        */\r\n    };\r\n    IdentifierDay.DESCRIBE_FORMAT_LONG = 'LL';\r\n    IdentifierDay.DESCRIBE_FORMAT_SHORT = 'll';\r\n    IdentifierDay.SCALES = [\r\n        1 /* day     */,\r\n        100 /* month   */,\r\n        10000 /* year    */\r\n    ];\r\n    IdentifierDay.LENGTH = 8;\r\n    return IdentifierDay;\r\n}(Identifier_Identifier));\r\n// YYYY0ww (7)\r\nvar Identifier_IdentifierWeek = (function (_super) {\r\n    __extends(IdentifierWeek, _super);\r\n    function IdentifierWeek() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    IdentifierWeek.prototype.getScales = function () {\r\n        return IdentifierWeek.SCALES;\r\n    };\r\n    IdentifierWeek.prototype.getLength = function () {\r\n        return IdentifierWeek.LENGTH;\r\n    };\r\n    IdentifierWeek.prototype.get = function (day) {\r\n        return this.compute(day.week, day.year);\r\n    };\r\n    IdentifierWeek.prototype.object = function (id) {\r\n        var values = this.decompute(id);\r\n        return {\r\n            week: values[0],\r\n            year: values[1]\r\n        };\r\n    };\r\n    IdentifierWeek.prototype.start = function (id) {\r\n        var obj = this.object(id);\r\n        var start = Day_Day.build(obj.year, 0).withWeek(obj.week);\r\n        return start;\r\n    };\r\n    IdentifierWeek.prototype.span = function (id, endInclusive) {\r\n        if (endInclusive === void 0) { endInclusive = false; }\r\n        var start = this.start(id);\r\n        var end = start.endOfWeek(endInclusive);\r\n        return new DaySpan_DaySpan(start, end);\r\n    };\r\n    IdentifierWeek.prototype.describe = function (id, short) {\r\n        if (short === void 0) { short = false; }\r\n        var start = this.start(id);\r\n        var format = short ? IdentifierWeek.DESCRIBE_FORMAT_SHORT : IdentifierWeek.DESCRIBE_FORMAT_LONG;\r\n        return start.format(format);\r\n    };\r\n    IdentifierWeek.prototype.matches = function (day, id) {\r\n        return day.weekIdentifier === id;\r\n        /*\r\n        let obj: IdentifierObject = this.object(id);\r\n    \n        return (\r\n          day.year === obj.year &&\r\n          day.week === obj.week\r\n        );\r\n        */\r\n    };\r\n    IdentifierWeek.DESCRIBE_FORMAT_LONG = 'wo [week of] YYYY';\r\n    IdentifierWeek.DESCRIBE_FORMAT_SHORT = 'wo [week of] YYYY';\r\n    IdentifierWeek.SCALES = [\r\n        1 /* week   */,\r\n        1000 /* year   */\r\n    ];\r\n    IdentifierWeek.LENGTH = 7;\r\n    return IdentifierWeek;\r\n}(Identifier_Identifier));\r\n// YYYYMM (6)\r\nvar Identifier_IdentifierMonth = (function (_super) {\r\n    __extends(IdentifierMonth, _super);\r\n    function IdentifierMonth() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    IdentifierMonth.prototype.getScales = function () {\r\n        return IdentifierMonth.SCALES;\r\n    };\r\n    IdentifierMonth.prototype.getLength = function () {\r\n        return IdentifierMonth.LENGTH;\r\n    };\r\n    IdentifierMonth.prototype.get = function (day) {\r\n        return this.compute(day.month + 1, day.year);\r\n    };\r\n    IdentifierMonth.prototype.object = function (id) {\r\n        var values = this.decompute(id);\r\n        return {\r\n            month: values[0] - 1,\r\n            year: values[1]\r\n        };\r\n    };\r\n    IdentifierMonth.prototype.start = function (id) {\r\n        var obj = this.object(id);\r\n        var start = Day_Day.build(obj.year, obj.month);\r\n        return start;\r\n    };\r\n    IdentifierMonth.prototype.span = function (id, endInclusive) {\r\n        if (endInclusive === void 0) { endInclusive = false; }\r\n        var start = this.start(id);\r\n        var end = start.endOfMonth(endInclusive);\r\n        return new DaySpan_DaySpan(start, end);\r\n    };\r\n    IdentifierMonth.prototype.describe = function (id, short) {\r\n        if (short === void 0) { short = false; }\r\n        var start = this.start(id);\r\n        var format = short ? IdentifierMonth.DESCRIBE_FORMAT_SHORT : IdentifierMonth.DESCRIBE_FORMAT_LONG;\r\n        return start.format(format);\r\n    };\r\n    IdentifierMonth.prototype.matches = function (day, id) {\r\n        return day.monthIdentifier === id;\r\n        /*\r\n        let obj: IdentifierObject = this.object(id);\r\n    \n        return (\r\n          day.year === obj.year &&\r\n          day.month === obj.month\r\n        );\r\n        */\r\n    };\r\n    IdentifierMonth.DESCRIBE_FORMAT_LONG = 'MMMM YYYY';\r\n    IdentifierMonth.DESCRIBE_FORMAT_SHORT = 'MMM YYYY';\r\n    IdentifierMonth.SCALES = [\r\n        1 /* month  */,\r\n        100 /* year   */\r\n    ];\r\n    IdentifierMonth.LENGTH = 6;\r\n    return IdentifierMonth;\r\n}(Identifier_Identifier));\r\n// YYYYQ (5)\r\nvar Identifier_IdentifierQuarter = (function (_super) {\r\n    __extends(IdentifierQuarter, _super);\r\n    function IdentifierQuarter() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    IdentifierQuarter.prototype.getScales = function () {\r\n        return IdentifierQuarter.SCALES;\r\n    };\r\n    IdentifierQuarter.prototype.getLength = function () {\r\n        return IdentifierQuarter.LENGTH;\r\n    };\r\n    IdentifierQuarter.prototype.get = function (day) {\r\n        return this.compute(day.quarter, day.year);\r\n    };\r\n    IdentifierQuarter.prototype.object = function (id) {\r\n        var values = this.decompute(id);\r\n        return {\r\n            quarter: values[0],\r\n            year: values[1]\r\n        };\r\n    };\r\n    IdentifierQuarter.prototype.start = function (id) {\r\n        var obj = this.object(id);\r\n        var start = Day_Day.build(obj.year, (obj.quarter - 1) * 3);\r\n        return start;\r\n    };\r\n    IdentifierQuarter.prototype.span = function (id, endInclusive) {\r\n        if (endInclusive === void 0) { endInclusive = false; }\r\n        var start = this.start(id);\r\n        var end = start.relativeMonths(3).endOfMonth(endInclusive);\r\n        return new DaySpan_DaySpan(start, end);\r\n    };\r\n    IdentifierQuarter.prototype.describe = function (id, short) {\r\n        if (short === void 0) { short = false; }\r\n        var start = this.start(id);\r\n        var format = short ? IdentifierQuarter.DESCRIBE_FORMAT_SHORT : IdentifierQuarter.DESCRIBE_FORMAT_LONG;\r\n        return start.format(format);\r\n    };\r\n    IdentifierQuarter.prototype.matches = function (day, id) {\r\n        return day.quarterIdentifier === id;\r\n        /*\r\n        let obj: IdentifierObject = this.object(id);\r\n    \n        return (\r\n          day.year === obj.year &&\r\n          day.quarter === obj.quarter\r\n        );\r\n        */\r\n    };\r\n    IdentifierQuarter.DESCRIBE_FORMAT_LONG = 'Qo [quarter] YYYY';\r\n    IdentifierQuarter.DESCRIBE_FORMAT_SHORT = 'Qo [quarter] YYYY';\r\n    IdentifierQuarter.SCALES = [\r\n        1 /* quarter  */,\r\n        10 /* year   */\r\n    ];\r\n    IdentifierQuarter.LENGTH = 5;\r\n    return IdentifierQuarter;\r\n}(Identifier_Identifier));\r\n// YYYY (4)\r\nvar Identifier_IdentifierYear = (function (_super) {\r\n    __extends(IdentifierYear, _super);\r\n    function IdentifierYear() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    IdentifierYear.prototype.getScales = function () {\r\n        return IdentifierYear.SCALES;\r\n    };\r\n    IdentifierYear.prototype.getLength = function () {\r\n        return IdentifierYear.LENGTH;\r\n    };\r\n    IdentifierYear.prototype.get = function (day) {\r\n        return this.compute(day.year);\r\n    };\r\n    IdentifierYear.prototype.object = function (id) {\r\n        var values = this.decompute(id);\r\n        return {\r\n            year: values[0]\r\n        };\r\n    };\r\n    IdentifierYear.prototype.start = function (id) {\r\n        var obj = this.object(id);\r\n        var start = Day_Day.build(obj.year, 0);\r\n        return start;\r\n    };\r\n    IdentifierYear.prototype.span = function (id, endInclusive) {\r\n        if (endInclusive === void 0) { endInclusive = false; }\r\n        var start = this.start(id);\r\n        var end = start.endOfYear(endInclusive);\r\n        return new DaySpan_DaySpan(start, end);\r\n    };\r\n    IdentifierYear.prototype.describe = function (id, short) {\r\n        if (short === void 0) { short = false; }\r\n        var start = this.start(id);\r\n        var format = short ? IdentifierYear.DESCRIBE_FORMAT_SHORT : IdentifierYear.DESCRIBE_FORMAT_LONG;\r\n        return start.format(format);\r\n    };\r\n    IdentifierYear.prototype.matches = function (day, id) {\r\n        return day.year === id;\r\n        /*\r\n        let obj: IdentifierObject = this.object(id);\r\n    \n        return (\r\n          day.year === obj.year\r\n        );\r\n        */\r\n    };\r\n    IdentifierYear.DESCRIBE_FORMAT_LONG = 'YYYY';\r\n    IdentifierYear.DESCRIBE_FORMAT_SHORT = 'YYYY';\r\n    IdentifierYear.SCALES = [\r\n        1 /* year  */\r\n    ];\r\n    IdentifierYear.LENGTH = 4;\r\n    return IdentifierYear;\r\n}(Identifier_Identifier));\r\n// Sets the Identifier types\r\nIdentifier_Identifier.Time = new Identifier_IdentifierTime();\r\nIdentifier_Identifier.Day = new Identifier_IdentifierDay();\r\nIdentifier_Identifier.Week = new Identifier_IdentifierWeek();\r\nIdentifier_Identifier.Month = new Identifier_IdentifierMonth();\r\nIdentifier_Identifier.Quarter = new Identifier_IdentifierQuarter();\r\nIdentifier_Identifier.Year = new Identifier_IdentifierYear();\r\n\n// CONCATENATED MODULE: ./src/Suffix.ts\n\r\n/**\r\n * A class which takes a number and determines the suffix for that number.\r\n *\r\n * ```typescript\r\n * Suffix.CACHE[ 2 ];         // 2nd\r\n * Suffix.determine( 3 );     // rd\r\n * Suffix.get( 4 );           // th\r\n * Suffix.get( 4, true );     // 4th\r\n * ```\r\n */\r\nvar Suffix = (function () {\r\n    function Suffix() {\r\n    }\r\n    Object.defineProperty(Suffix, \"CACHE\", {\r\n        /**\r\n         * The cache of number & suffix pairs.\r\n         */\r\n        get: function () {\r\n            if (!this._CACHE) {\r\n                this._CACHE = [];\r\n                for (var i = 0; i <= this._CACHE_SIZE; i++) {\r\n                    this._CACHE[i] = this.get(i, true);\r\n                }\r\n            }\r\n            return this._CACHE;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Determines the suffix for a given number.\r\n     *\r\n     * @param value The number to find the suffix for.\r\n     * @returns The suffix determined.\r\n     */\r\n    Suffix.determine = function (value) {\r\n        return value >= 11 && value <= 13 ? 'th' : this.MAP[value % this.MAP.length];\r\n    };\r\n    /**\r\n     * Gets the suffix for a number and optionally appends it before the suffix.\r\n     *\r\n     * @param value The number to get the suffix for.\r\n     * @param prepend When `true` the value is prepended to the suffix.\r\n     * @returns The suffix or value & suffix pair determined.\r\n     */\r\n    Suffix.get = function (value, prepend) {\r\n        if (prepend === void 0) { prepend = false; }\r\n        var suffix = this.determine(value);\r\n        return prepend ? value + suffix : suffix;\r\n    };\r\n    /**\r\n     * The array of suffixes used.\r\n     */\r\n    Suffix.MAP = [\r\n        'th', 'st', 'nd', 'rd', 'th', 'th', 'th', 'th', 'th', 'th'\r\n    ];\r\n    /**\r\n     * The number of values to store in the cache (inclusive).\r\n     */\r\n    Suffix._CACHE_SIZE = 366;\r\n    return Suffix;\r\n}());\r\n\r\n\n// CONCATENATED MODULE: ./src/Iterator.ts\n\r\n\r\n/**\r\n * An action to perform on the source as instructed by the iterator.\r\n */\r\nvar IteratorAction;\r\n(function (IteratorAction) {\r\n    /**\r\n     * Continue iteration.\r\n     */\r\n    IteratorAction[IteratorAction[\"Continue\"] = 0] = \"Continue\";\r\n    /**\r\n     * Stop iteration.\r\n     */\r\n    IteratorAction[IteratorAction[\"Stop\"] = 1] = \"Stop\";\r\n    /**\r\n     * Remove the current item if possible, and continue iteration.\r\n     */\r\n    IteratorAction[IteratorAction[\"Remove\"] = 2] = \"Remove\";\r\n    /**\r\n     * Replace the current item with the provided value.\r\n     */\r\n    IteratorAction[IteratorAction[\"Replace\"] = 3] = \"Replace\";\r\n})(IteratorAction = IteratorAction || (IteratorAction = {}));\r\n/**\r\n * A class that allows an iteratable source to be iterated any number of times\r\n * by providing the following functionality:\r\n *\r\n * - [[Iterator.isEmpty]]: Determines whether the source contains any items.\r\n * - [[Iterator.first]]: Gets the first item in the source.\r\n * - [[Iterator.count]]: Counds the number of items in the source.\r\n * - [[Iterator.list]]: Builds a list of the items in the source.\r\n * - [[Iterator.object]]: Builds an object of the items in the source.\r\n * - [[Iterator.reduce]]: Reduces the items in the source down to a single value.\r\n * - [[Iterator.purge]]: Removes items from the source which meet some criteria.\r\n * - [[Iterator.filter]]: Returns a subset of items that meet some criteria by\r\n *    returning a new Iterator.\r\n * - [[Iterator.map]]: Maps each item in the source to another item by returning\r\n *    a new Iterator.\r\n * - [[Iterator.iterate]]: Invokes a function for each item in the source.\r\n *\r\n * The following static functions exist to help iterate simple sources:\r\n *\r\n * - [[Iterator.forArray]]: Iterates an array, optionally reverse\r\n * - [[Iterator.forObject]]: Iterates the properties of an object, optionally\r\n *    just the properties explicitly set on the object.\r\n *\r\n * ```typescript\r\n * let iter = object.iterateThings();\r\n * iter.isEmpty();              // no items?\r\n * iter.isEmpty(d => d.flag);   // no items that meet some criteria?\r\n * iter.count();                // number of items\r\n * iter.count(d => d.flag);     // number of items that meet some criteria\r\n * iter.first();                // first item\r\n * iter.first(d => d.flag);     // first item that meets some criteria\r\n * iter.list();                 // get all items as array\r\n * iter.list(myArray);          // add all items to given array\r\n * iter.list([], d => d.flag);  // get all items as array that meet some criteria\r\n * iter.object(d => d.id);      // get all items as an object keyed by a value (ex: id)\r\n * iter.object(d => d.id, {},\r\n *    d => d.flag);             // get all items as an object keyed by a value where the item meets some criteria (ex: key id if flag is truthy)\r\n * iter.purge(d => d.flag);     // remove all items from source that meet some criteria\r\n * iter.filter(d => d.flag);    // returns an iterator which iterates a subset of items which meet some criteria\r\n * iter.reduce<number>(0,\r\n *   (d, t) => t + d.size);     // reduces all items to a single value (ex: sums all size)\r\n * iter.reduce<number>(0,\r\n *   (d, t) => t + d.size,\r\n *   d => d.flag);              // reduces all items to a single value (ex: sums all size) where the item meets some criteria\r\n * iter.map<S>(d => d.subitem); // return an iterator for subitems if they exist\r\n * iter.iterate(d => log(d));   // do something for each item\r\n * ```\r\n *\r\n * @typeparam T The type of item being iterated.\r\n */\r\nvar Iterator_Iterator = (function () {\r\n    /**\r\n     * Creates a new Iterator given a source.\r\n     *\r\n     * @param source The source of items to iterator.\r\n     */\r\n    function Iterator(source) {\r\n        /**\r\n         * A result of the iteration passed to [[Iterator.stop]].\r\n         */\r\n        this.result = null;\r\n        this.source = source;\r\n    }\r\n    /**\r\n     * Returns a clone of this iterator with the same source. This is necessary\r\n     * if you want to iterate all or a portion of the source while already\r\n     * iterating it (like a nested loop).\r\n     */\r\n    Iterator.prototype.clone = function () {\r\n        return new Iterator(this.source);\r\n    };\r\n    /**\r\n     * Passes the given item to the iterator callback and returns the action\r\n     * requested at this point in iteration.\r\n     *\r\n     * @param item The current item being iterated.\r\n     */\r\n    Iterator.prototype.act = function (item) {\r\n        this.action = IteratorAction.Continue;\r\n        this.replaceWith = null;\r\n        this.callback(item, this);\r\n        return this.action;\r\n    };\r\n    /**\r\n     * Stops iteration and optionally sets the result of the iteration.\r\n     *\r\n     * @param result The result of the iteration.\r\n     */\r\n    Iterator.prototype.stop = function (result) {\r\n        this.result = result;\r\n        this.action = IteratorAction.Stop;\r\n        return this;\r\n    };\r\n    /**\r\n     * Stops iteration and optionally sets the result of the iteration.\r\n     *\r\n     * @param result The result of the iteration.\r\n     */\r\n    Iterator.prototype.replace = function (replaceWith) {\r\n        this.replaceWith = replaceWith;\r\n        this.action = IteratorAction.Replace;\r\n        return this;\r\n    };\r\n    /**\r\n     * Signals to the iterator source that the current item wants to be removed.\r\n     */\r\n    Iterator.prototype.remove = function () {\r\n        this.action = IteratorAction.Remove;\r\n        return this;\r\n    };\r\n    /**\r\n     * Determines with this iterator is empty. A filter function can be specified\r\n     * to only check for items which match certain criteria.\r\n     *\r\n     * @param filter A function to the checks items for certain criteria.\r\n     * @returns `true` if no valid items exist in the source.\r\n     */\r\n    Iterator.prototype.isEmpty = function (filter) {\r\n        if (filter === void 0) { filter = null; }\r\n        var empty = true;\r\n        this.iterate(function (item, iterator) {\r\n            if (filter && !filter(item)) {\r\n                return;\r\n            }\r\n            empty = false;\r\n            iterator.stop();\r\n        });\r\n        return empty;\r\n    };\r\n    /**\r\n     * Counts the number of items in the iterator. A filter function can be\r\n     * specified to only count items which match certain criteria.\r\n     *\r\n     * @param filter A function to count items for certain criteria.\r\n     * @returns The number of items in the source that optionally match the given\r\n     *    criteria.\r\n     */\r\n    Iterator.prototype.count = function (filter) {\r\n        if (filter === void 0) { filter = null; }\r\n        var total = 0;\r\n        this.iterate(function (item, iterator) {\r\n            if (filter && !filter(item)) {\r\n                return;\r\n            }\r\n            total++;\r\n        });\r\n        return total;\r\n    };\r\n    /**\r\n     * Returns the first item in the iterator. A filter function can be specified\r\n     * to only return the first item which matches certain criteria.\r\n     *\r\n     * @param filter A function to compare items to to match certain criteria.\r\n     * @returns The first item found that optonally matches the given criteria.\r\n     */\r\n    Iterator.prototype.first = function (filter) {\r\n        if (filter === void 0) { filter = null; }\r\n        var first = null;\r\n        this.iterate(function (item, iterator) {\r\n            if (filter && !filter(item)) {\r\n                return;\r\n            }\r\n            first = item;\r\n            iterator.stop();\r\n        });\r\n        return first;\r\n    };\r\n    /**\r\n     * Builds a list of items from the source. A filter function can be specified\r\n     * so the resulting list only contain items that match certain criteria.\r\n     *\r\n     * @param out The array to place the items in.\r\n     * @param filter The function which determines which items are added to the list.\r\n     * @returns The reference to `out` which has had items added to it which\r\n     *    optionally match the given criteria.\r\n     */\r\n    Iterator.prototype.list = function (out, filter) {\r\n        if (out === void 0) { out = []; }\r\n        if (filter === void 0) { filter = null; }\r\n        this.iterate(function (item, iterator) {\r\n            if (filter && !filter(item)) {\r\n                return;\r\n            }\r\n            out.push(item);\r\n        });\r\n        return out;\r\n    };\r\n    /**\r\n     * Builds an object of items from the source keyed by a result returned by\r\n     * a `getKey` function.\r\n     *\r\n     * @param getKey The function which returns the key of the object.\r\n     * @param out The object to place the items in.\r\n     * @param filter The function which determines which items are set on the object.\r\n     * @returns The reference to `out` which has had items set to it which\r\n     *    optionally match the given criteria.\r\n     */\r\n    Iterator.prototype.object = function (getKey, out, filter) {\r\n        if (out === void 0) { out = {}; }\r\n        if (filter === void 0) { filter = null; }\r\n        this.iterate(function (item, iterator) {\r\n            if (filter && !filter(item)) {\r\n                return;\r\n            }\r\n            var key = getKey(item);\r\n            out[key] = item;\r\n        });\r\n        return out;\r\n    };\r\n    /**\r\n     * Returns a new iterator that only returns a maximum number of items.\r\n     *\r\n     * @param amount The maximum number of items to return.\r\n     * @returns A new iterator which returns a maximum number of items.\r\n     */\r\n    Iterator.prototype.take = function (amount) {\r\n        var _this = this;\r\n        return new Iterator(function (next) {\r\n            _this.iterate(function (item, prev) {\r\n                switch (next.act(item)) {\r\n                    case IteratorAction.Stop:\r\n                        prev.stop();\r\n                        break;\r\n                    case IteratorAction.Remove:\r\n                        prev.remove();\r\n                        break;\r\n                    case IteratorAction.Replace:\r\n                        prev.replace(next.replaceWith);\r\n                        break;\r\n                }\r\n                if (--amount <= 0) {\r\n                    prev.stop();\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Returns a new iterator that skips the given number of items from the items\r\n     * in this iterator.\r\n     *\r\n     * @param amount The number of items to skip.\r\n     * @returns A new iterator which skipped the given number of items.\r\n     */\r\n    Iterator.prototype.skip = function (amount) {\r\n        var _this = this;\r\n        return new Iterator(function (next) {\r\n            var skipped = 0;\r\n            _this.iterate(function (item, prev) {\r\n                if (skipped >= amount) {\r\n                    switch (next.act(item)) {\r\n                        case IteratorAction.Stop:\r\n                            prev.stop();\r\n                            break;\r\n                        case IteratorAction.Remove:\r\n                            prev.remove();\r\n                            break;\r\n                        case IteratorAction.Replace:\r\n                            prev.replace(next.replaceWith);\r\n                            break;\r\n                    }\r\n                }\r\n                skipped++;\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Returns a new iterator thats items are the items in this iterator followed\r\n     * by the items in the given iterators.\r\n     *\r\n     * @param iterators The iterators to append after this one.\r\n     * @returns A new iterator based on this iterator followed by the given.\r\n     */\r\n    Iterator.prototype.append = function () {\r\n        var iterators = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            iterators[_i] = arguments[_i];\r\n        }\r\n        return Iterator.join.apply(Iterator, [this].concat(iterators));\r\n    };\r\n    /**\r\n     * Returns a new iterator thats items are the items in the given iterators\r\n     * followed by the items in this iterator.\r\n     *\r\n     * @param iterators The iterators to prepend before this one.\r\n     * @returns A new iterator based on the given iterators followed by this.\r\n     */\r\n    Iterator.prototype.prepend = function () {\r\n        var iterators = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            iterators[_i] = arguments[_i];\r\n        }\r\n        return Iterator.join.apply(Iterator, iterators.concat([this]));\r\n    };\r\n    /**\r\n     * Removes items from the source that match certain criteria.\r\n     *\r\n     * @param filter The function which determines which items to remove.\r\n     */\r\n    Iterator.prototype.purge = function (filter) {\r\n        this.iterate(function (item, iterator) {\r\n            if (filter(item)) {\r\n                iterator.remove();\r\n            }\r\n        });\r\n        return this;\r\n    };\r\n    /**\r\n     * Returns an iterator which takes items from this iterator and presents them\r\n     * in reverse.\r\n     *\r\n     * @returns A new iterator with the items in this iterator in reverse.\r\n     */\r\n    Iterator.prototype.reverse = function () {\r\n        var _this = this;\r\n        return new Iterator(function (iterator) {\r\n            var items = _this.list();\r\n            var modifies = false;\r\n            var actions = [];\r\n            var replaces = [];\r\n            for (var i = items.length - 1; i >= 0; i--) {\r\n                var item = items[i];\r\n                var action = iterator.act(item);\r\n                if (action === IteratorAction.Stop) {\r\n                    break;\r\n                }\r\n                if (action !== IteratorAction.Continue) {\r\n                    modifies = true;\r\n                    actions[i] = action;\r\n                    replaces[i] = iterator.replaceWith;\r\n                }\r\n            }\r\n            if (modifies) {\r\n                var index_1 = 0;\r\n                _this.iterate(function (item, iterator) {\r\n                    switch (actions[index_1]) {\r\n                        case IteratorAction.Remove:\r\n                            iterator.remove();\r\n                            break;\r\n                        case IteratorAction.Replace:\r\n                            iterator.replace(replaces[index_1]);\r\n                            break;\r\n                    }\r\n                    index_1++;\r\n                });\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * Reduces all the items in the source to a single value given the initial\r\n     * value and a function to convert an item and the current reduced value\r\n     */\r\n    Iterator.prototype.reduce = function (initial, reducer, filter) {\r\n        if (filter === void 0) { filter = null; }\r\n        var reduced = initial;\r\n        this.iterate(function (item, iterator) {\r\n            if (filter && !filter(item)) {\r\n                return;\r\n            }\r\n            reduced = reducer(item, reduced);\r\n        });\r\n        return reduced;\r\n    };\r\n    /**\r\n     * Returns an iterator where this iterator is the source and the returned\r\n     * iterator is built on a subset of items which pass a `filter` function.\r\n     *\r\n     * @param filter The function which determines if an item should be iterated.\r\n     * @returns A new iterator for the filtered items from this iterator.\r\n     */\r\n    Iterator.prototype.filter = function (filter) {\r\n        var _this = this;\r\n        return new Iterator(function (next) {\r\n            _this.iterate(function (prevItem, prev) {\r\n                if (filter(prevItem)) {\r\n                    switch (next.act(prevItem)) {\r\n                        case IteratorAction.Stop:\r\n                            prev.stop();\r\n                            break;\r\n                        case IteratorAction.Remove:\r\n                            prev.remove();\r\n                            break;\r\n                        case IteratorAction.Replace:\r\n                            prev.replace(next.replaceWith);\r\n                            break;\r\n                    }\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Returns an iterator where this iterator is the source and the returned\r\n     * iterator is built from mapped items pulled from items in the source\r\n     * of this iterator. If the given callback `outerCallback` does not return\r\n     * a mapped value then the returned iterator will not see the item. A filter\r\n     * function can be specified to only look at mapping items which match\r\n     * certain criteria.\r\n     *\r\n     * @param mapper The function which maps an item to another.\r\n     * @param filter The function which determines if an item should be mapped.\r\n     * @param unmapper The function which unmaps a value when replace is called.\r\n     * @returns A new iterator for the mapped items from this iterator.\r\n     */\r\n    Iterator.prototype.map = function (mapper, filter, unmapper) {\r\n        var _this = this;\r\n        if (filter === void 0) { filter = null; }\r\n        if (unmapper === void 0) { unmapper = null; }\r\n        return new Iterator(function (next) {\r\n            _this.iterate(function (prevItem, prev) {\r\n                if (filter && !filter(prevItem)) {\r\n                    return;\r\n                }\r\n                var nextItem = mapper(prevItem, prev);\r\n                if (Functions.isDefined(nextItem)) {\r\n                    switch (next.act(nextItem)) {\r\n                        case IteratorAction.Stop:\r\n                            prev.stop();\r\n                            break;\r\n                        case IteratorAction.Remove:\r\n                            prev.remove();\r\n                            break;\r\n                        case IteratorAction.Replace:\r\n                            if (unmapper) {\r\n                                prev.replace(unmapper(next.replaceWith, nextItem, prevItem));\r\n                            }\r\n                            break;\r\n                    }\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Invokes the callback for each item in the source of this iterator. The\r\n     * second argument in the callback is the reference to this iterator and\r\n     * [[Iterator.stop]] can be called at anytime to cease iteration.\r\n     *\r\n     * @param callback The function to invoke for each item in this iterator.\r\n     */\r\n    Iterator.prototype.iterate = function (callback) {\r\n        this.result = undefined;\r\n        this.callback = callback;\r\n        this.action = IteratorAction.Continue;\r\n        this.source(this);\r\n        this.callback = null;\r\n        return this;\r\n    };\r\n    /**\r\n     * Passes the result of the iteration to the given function if a truthy\r\n     * result was passed to [[Iterator.stop]].\r\n     *\r\n     * @param getResult The function to pass the result to if it exists.\r\n     */\r\n    Iterator.prototype.withResult = function (getResult) {\r\n        if (this.result) {\r\n            getResult(this.result);\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Returns an iterator for the given array optionally iterating it in reverse.\r\n     *\r\n     * @param items The array of items to iterate.\r\n     * @param reverse If the array should be iterated in reverse.\r\n     * @returns A new iterator for the given array.\r\n     */\r\n    Iterator.forArray = function (items, reverse) {\r\n        if (reverse === void 0) { reverse = false; }\r\n        return new Iterator(function (iterator) {\r\n            if (reverse) {\r\n                for (var i = items.length - 1; i >= 0; i--) {\r\n                    switch (iterator.act(items[i])) {\r\n                        case IteratorAction.Stop:\r\n                            return;\r\n                        case IteratorAction.Remove:\r\n                            items.splice(i, 1);\r\n                            break;\r\n                        case IteratorAction.Replace:\r\n                            items.splice(i, 1, iterator.replaceWith);\r\n                            break;\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                for (var i = 0; i < items.length; i++) {\r\n                    switch (iterator.act(items[i])) {\r\n                        case IteratorAction.Stop:\r\n                            return;\r\n                        case IteratorAction.Remove:\r\n                            items.splice(i, 1);\r\n                            i--;\r\n                            break;\r\n                        case IteratorAction.Replace:\r\n                            items.splice(i, 1, iterator.replaceWith);\r\n                            break;\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * Returns an iterator for the given object optionally checking the\r\n     * `hasOwnProperty` function on the given object.\r\n     *\r\n     * @param items The object to iterate.\r\n     * @param hasOwnProperty If `hasOwnProperty` should be checked.\r\n     * @returns A new iterator for the given object.\r\n     */\r\n    Iterator.forObject = function (items, hasOwnProperty) {\r\n        if (hasOwnProperty === void 0) { hasOwnProperty = true; }\r\n        return new Iterator(function (iterator) {\r\n            for (var key in items) {\r\n                if (hasOwnProperty && !items.hasOwnProperty(key)) {\r\n                    continue;\r\n                }\r\n                switch (iterator.act(items[key])) {\r\n                    case IteratorAction.Stop:\r\n                        return;\r\n                    case IteratorAction.Remove:\r\n                        delete items[key];\r\n                        break;\r\n                    case IteratorAction.Replace:\r\n                        items[key] = iterator.replaceWith;\r\n                        break;\r\n                }\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * Joins all the given iterators into a single iterator where the items\r\n     * returned are in the same order as passed to this function. If any items\r\n     * are removed from the returned iterator they will be removed from the given\r\n     * iterator if it supports removal.\r\n     *\r\n     * @param iterators The array of iterators to join as one.\r\n     * @returns A new iterator for the given iterators.\r\n     */\r\n    Iterator.join = function () {\r\n        var iterators = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            iterators[_i] = arguments[_i];\r\n        }\r\n        return new Iterator(function (parent) {\r\n            for (var _i = 0, iterators_1 = iterators; _i < iterators_1.length; _i++) {\r\n                var child = iterators_1[_i];\r\n                child.iterate(function (item, childIterator) {\r\n                    switch (parent.act(item)) {\r\n                        case IteratorAction.Remove:\r\n                            childIterator.remove();\r\n                            break;\r\n                        case IteratorAction.Stop:\r\n                            childIterator.stop();\r\n                            break;\r\n                        case IteratorAction.Replace:\r\n                            childIterator.replace(parent.replaceWith);\r\n                            break;\r\n                    }\r\n                });\r\n                if (child.action === IteratorAction.Stop) {\r\n                    return;\r\n                }\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * Returns a new iterator with no items.\r\n     *\r\n     * @returns A new iterator with no items.\r\n     */\r\n    Iterator.empty = function () {\r\n        return new Iterator(function (parent) { });\r\n    };\r\n    return Iterator;\r\n}());\r\n\r\n\n// CONCATENATED MODULE: ./src/ScheduleModifier.ts\n\r\n\r\n\r\n\r\n/**\r\n * A class that can modify the events of a schedule by storing [[Identifier]]s\r\n * and an associated value.\r\n *\r\n * @typeparam T The type of data that modifies the schedule.\r\n */\r\nvar ScheduleModifier_ScheduleModifier = (function () {\r\n    /**\r\n     * Creates a new schedule modifier.\r\n     */\r\n    function ScheduleModifier() {\r\n        this.map = {};\r\n    }\r\n    /**\r\n     * Clears the modifier of all modifications.\r\n     */\r\n    ScheduleModifier.prototype.clear = function () {\r\n        this.map = {};\r\n        return this;\r\n    };\r\n    /**\r\n     * Returns `true` if this modifier lacks any modifications, otherwise `false`.\r\n     */\r\n    ScheduleModifier.prototype.isEmpty = function () {\r\n        // @ts-ignore\r\n        for (var id in this.map) {\r\n            return !id;\r\n        }\r\n        return true;\r\n    };\r\n    /**\r\n     * Gets the most specific value in this modifier for the given day, if none\r\n     * exists `otherwise` is returned. A modifier can have multiple values for a\r\n     * given day because [[Identifier]]s represent a span of time.\r\n     *\r\n     * @param day The day to get a value for.\r\n     * @param otherwise What to return if no value exists for the given day.\r\n     * @param lookAtTime If the specific time of the given day should be looked at.\r\n     * @returns The most specific value for the given day, or `otherwise`.\r\n     */\r\n    ScheduleModifier.prototype.get = function (day, otherwise, lookAtTime) {\r\n        if (lookAtTime === void 0) { lookAtTime = true; }\r\n        var map = this.map;\r\n        return (lookAtTime && map[day.timeIdentifier]) ||\r\n            map[day.dayIdentifier] ||\r\n            map[day.monthIdentifier] ||\r\n            map[day.weekIdentifier] ||\r\n            map[day.quarterIdentifier] ||\r\n            otherwise;\r\n    };\r\n    /**\r\n     * Gets the most specific identifier type for the span over the given day.\r\n     * If the day does not have a modification, `null` is returned.\r\n     *\r\n     * @param day The day to get the type for.\r\n     * @param lookAtTime If the specific time of the given day should be looked at.\r\n     * @returns The most specific identifier for the given day, otherwise `null`.\r\n     */\r\n    ScheduleModifier.prototype.getIdentifier = function (day, lookAtTime) {\r\n        if (lookAtTime === void 0) { lookAtTime = true; }\r\n        var map = this.map;\r\n        if (lookAtTime && Functions.isDefined(map[day.timeIdentifier]))\r\n            return Identifier_Identifier.Time;\r\n        if (Functions.isDefined(map[day.dayIdentifier]))\r\n            return Identifier_Identifier.Day;\r\n        if (Functions.isDefined(map[day.monthIdentifier]))\r\n            return Identifier_Identifier.Month;\r\n        if (Functions.isDefined(map[day.weekIdentifier]))\r\n            return Identifier_Identifier.Week;\r\n        if (Functions.isDefined(map[day.quarterIdentifier]))\r\n            return Identifier_Identifier.Quarter;\r\n        if (Functions.isDefined(map[day.year]))\r\n            return Identifier_Identifier.Year;\r\n        return null;\r\n    };\r\n    /**\r\n     * Gets all values in this modifier for the given day. If none exist, an empty\r\n     * array is returned. The values returned in the array are returned in most\r\n     * specific to least specific.\r\n     *\r\n     * @param day The day to get the values for.\r\n     * @returns An array of values (modifications) for the given day.\r\n     */\r\n    ScheduleModifier.prototype.getAll = function (day) {\r\n        var map = this.map;\r\n        var all = [];\r\n        if (map[day.timeIdentifier])\r\n            all.push(map[day.timeIdentifier]);\r\n        if (map[day.dayIdentifier])\r\n            all.push(map[day.dayIdentifier]);\r\n        if (map[day.monthIdentifier])\r\n            all.push(map[day.monthIdentifier]);\r\n        if (map[day.weekIdentifier])\r\n            all.push(map[day.weekIdentifier]);\r\n        if (map[day.quarterIdentifier])\r\n            all.push(map[day.quarterIdentifier]);\r\n        return all;\r\n    };\r\n    /**\r\n     * Moves the value/modification from one identifier to another.\r\n     *\r\n     * @param from The day to take the identifier from.\r\n     * @param fromType The identifier type.\r\n     * @param to The day to move the value to.\r\n     * @param toType The identifier type to move the value to.\r\n     */\r\n    ScheduleModifier.prototype.move = function (from, fromType, to, toType) {\r\n        var fromIdentifier = fromType.get(from);\r\n        var toIdentifier = toType.get(to);\r\n        this.map[toIdentifier] = this.map[fromIdentifier];\r\n        delete this.map[fromIdentifier];\r\n        return this;\r\n    };\r\n    /**\r\n     * Moves any identifiers with the matching time `fromTime` to `toTime` and\r\n     * returns the number of moves.\r\n     *\r\n     * @param fromTime The time to move from.\r\n     * @param toTime The time to move to.\r\n     * @returns The number of modifiers moved.\r\n     */\r\n    ScheduleModifier.prototype.moveTime = function (fromTime, toTime) {\r\n        var type = Identifier_Identifier.Time;\r\n        var moveIds = [];\r\n        this.iterate().iterate(function (_a) {\r\n            var id = _a[0], value = _a[1];\r\n            if (type.is(id)) {\r\n                var start = type.start(id);\r\n                if (start.sameTime(fromTime)) {\r\n                    moveIds.push(id);\r\n                }\r\n            }\r\n        });\r\n        var moved = 0;\r\n        for (var _i = 0, moveIds_1 = moveIds; _i < moveIds_1.length; _i++) {\r\n            var id = moveIds_1[_i];\r\n            var value = this.map[id];\r\n            var start = type.start(id);\r\n            var newStart = start.withTime(toTime);\r\n            var newId = type.get(newStart);\r\n            if (!this.map[newId]) {\r\n                this.map[newId] = value;\r\n                delete this.map[id];\r\n                moved++;\r\n            }\r\n        }\r\n        return moved;\r\n    };\r\n    /**\r\n     * Removes any identifiers and modifications that are at the given time.\r\n     *\r\n     * @param time The time to remove.\r\n     * @returns The number of modifiers removed.\r\n     */\r\n    ScheduleModifier.prototype.removeTime = function (time) {\r\n        var type = Identifier_Identifier.Time;\r\n        var removed = 0;\r\n        this.iterate().iterate(function (_a, iterator) {\r\n            var id = _a[0];\r\n            if (type.is(id)) {\r\n                var start = type.start(id);\r\n                if (start.sameTime(time)) {\r\n                    iterator.remove();\r\n                    removed++;\r\n                }\r\n            }\r\n        });\r\n        return removed;\r\n    };\r\n    /**\r\n     * Sets the value/modification in this map given a day, the value, and the\r\n     * identifier type.\r\n     *\r\n     * @param day The day to take an identifier from.\r\n     * @param value The value/modification to set.\r\n     * @param type The identifier type.\r\n     */\r\n    ScheduleModifier.prototype.set = function (day, value, type) {\r\n        this.map[type.get(day)] = value;\r\n        return this;\r\n    };\r\n    /**\r\n     * Removes the value/modification from this modifier based on the identifier\r\n     * pulled from the day.\r\n     *\r\n     * @param day The day to take an identifier from.\r\n     * @param type The identifier type.\r\n     */\r\n    ScheduleModifier.prototype.unset = function (day, type) {\r\n        delete this.map[type.get(day)];\r\n        return this;\r\n    };\r\n    /**\r\n     * Iterates through the modifiers passing the identifier and the related value.\r\n     *\r\n     * @returns A new instance of an [[Iterator]].\r\n     */\r\n    ScheduleModifier.prototype.iterate = function () {\r\n        var _this = this;\r\n        return new Iterator_Iterator(function (iterator) {\r\n            var map = _this.map;\r\n            for (var rawId in map) {\r\n                var asNumber = parseInt(rawId);\r\n                var validAsNumber = asNumber + '' === rawId;\r\n                var id = validAsNumber ? asNumber : rawId;\r\n                switch (iterator.act([id, map[rawId]])) {\r\n                    case IteratorAction.Stop:\r\n                        return;\r\n                    case IteratorAction.Remove:\r\n                        delete map[rawId];\r\n                        break;\r\n                }\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * Queries the modifier for all values/modifications which fall in the time\r\n     * span that the given identifier represents. All identifiers and their value\r\n     * are passed to the given callback.\r\n     *\r\n     * @param prefix The identifier\r\n     * @returns A new instance of an [[Iterator]].\r\n     */\r\n    ScheduleModifier.prototype.query = function (query) {\r\n        return this.iterate()\r\n            .filter(function (_a) {\r\n            var id = _a[0], value = _a[1];\r\n            return Identifier_Identifier.contains(query, id);\r\n        });\r\n        ;\r\n    };\r\n    /**\r\n     * Returns all identifiers stored in this modifier.\r\n     */\r\n    ScheduleModifier.prototype.identifiers = function (filter) {\r\n        return this.iterate()\r\n            .filter(function (_a) {\r\n            var id = _a[0], value = _a[1];\r\n            return !filter || filter(value, id);\r\n        })\r\n            .map(function (_a) {\r\n            var id = _a[0];\r\n            return id;\r\n        });\r\n    };\r\n    /**\r\n     * Builds a list of spans and the associated values. The spans are calculated\r\n     * from the identiier key via [[Identifier.span]].\r\n     *\r\n     * @param endInclusive If the end date in the spans should be the last\r\n     *    millisecond of the timespan or the first millisecond of the next.\r\n     * @returns An array of spans calculated from the identifiers with the\r\n     *    associated values/modifications.\r\n     */\r\n    ScheduleModifier.prototype.spans = function (endInclusive) {\r\n        if (endInclusive === void 0) { endInclusive = false; }\r\n        return this.iterate()\r\n            .map(function (_a) {\r\n            var id = _a[0], value = _a[1];\r\n            var type = Identifier_Identifier.find(id);\r\n            if (type) {\r\n                var span = type.span(id, endInclusive);\r\n                return { span: span, value: value };\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * Builds a list of the descriptions of the identifiers in this modifier.\r\n     *\r\n     * @param short If the description should use shorter language or longer.\r\n     * @returns The built list of descriptions.\r\n     */\r\n    ScheduleModifier.prototype.describe = function (short) {\r\n        if (short === void 0) { short = false; }\r\n        return this.iterate()\r\n            .map(function (_a) {\r\n            var id = _a[0];\r\n            var type = Identifier_Identifier.find(id);\r\n            if (type) {\r\n                return type.describe(id, short);\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * Builds a map of the values/modifications keyed by the descripton of the\r\n     * identifier computed via [[Identifier.describe]].\r\n     *\r\n     * @param short If the description should use shorter language or longer.\r\n     * @returns The built map of description to values/modifications.\r\n     */\r\n    ScheduleModifier.prototype.describeMap = function (short) {\r\n        if (short === void 0) { short = false; }\r\n        var map = this.map;\r\n        var out = {};\r\n        for (var id in map) {\r\n            var type = Identifier_Identifier.find(id);\r\n            if (type) {\r\n                out[type.describe(id, short)] = map[id];\r\n            }\r\n        }\r\n        return out;\r\n    };\r\n    return ScheduleModifier;\r\n}());\r\n\r\n\n// CONCATENATED MODULE: ./src/Schedule.ts\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_moment__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_10_moment__);\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// @ts-ignore\r\n\r\n/**\r\n * A class which describes when an event occurs over what time and if it repeats.\r\n *\r\n * @typeparam M The type of metadata stored in the schedule.\r\n */\r\nvar Schedule_Schedule = (function () {\r\n    /**\r\n     * Creates a schedule based on the given input.\r\n     *\r\n     * @param input The input which describes the schedule of events.\r\n     */\r\n    function Schedule(input) {\r\n        this.exclude = new ScheduleModifier_ScheduleModifier();\r\n        this.include = new ScheduleModifier_ScheduleModifier();\r\n        this.cancel = new ScheduleModifier_ScheduleModifier();\r\n        this.meta = new ScheduleModifier_ScheduleModifier();\r\n        if (Functions.isDefined(input)) {\r\n            this.set(input);\r\n        }\r\n    }\r\n    /**\r\n     * Sets the schedule with the given input.\r\n     *\r\n     * @param input The input or schedule which describes the schedule of events.\r\n     * @param parseMeta A function to use when parsing meta input into the desired type.\r\n     * @see [[Parse.schedule]]\r\n     */\r\n    Schedule.prototype.set = function (input, parseMeta) {\r\n        if (parseMeta === void 0) { parseMeta = (function (x) { return x; }); }\r\n        if (input instanceof Schedule) {\r\n            Parse_Parse.schedule(input.toInput(), undefined, this);\r\n        }\r\n        else {\r\n            Parse_Parse.schedule(input, Functions.coalesce(input.parseMeta, parseMeta), this);\r\n        }\r\n        return this;\r\n    };\r\n    Object.defineProperty(Schedule.prototype, \"lastTime\", {\r\n        /**\r\n         * Returns the last event time specified or `undefined` if this schedule is\r\n         * for an all day event.\r\n         */\r\n        get: function () {\r\n            return this.times[this.times.length - 1];\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Schedule.prototype, \"identifierType\", {\r\n        /**\r\n         * The [[Identifier]] for this schedule. Either [[Identifier.Day]] or\r\n         * [[Identifier.Time]].\r\n         */\r\n        get: function () {\r\n            return this.isFullDay() ? Identifier_Identifier.Day : Identifier_Identifier.Time;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Updates the [[Schedule.durationInDays]] variable based on the\r\n     * [[Schedule.lastTime]] (if any), the [[Schedule.duration]] and it's\r\n     * [[Schedule.durationUnit]].\r\n     */\r\n    Schedule.prototype.updateDurationInDays = function () {\r\n        var start = this.lastTime ? this.lastTime.toMilliseconds() : 0;\r\n        var duration = this.duration * (Constants.DURATION_TO_MILLIS[this.durationUnit] || 0);\r\n        var exclude = Constants.MILLIS_IN_DAY;\r\n        var day = Constants.MILLIS_IN_DAY;\r\n        this.durationInDays = Math.max(0, Math.ceil((start + duration - exclude) / day));\r\n        return this;\r\n    };\r\n    /**\r\n     * Updates [[Schedule.checks]] based on the frequencies that were specified\r\n     * in the schedule input.\r\n     */\r\n    Schedule.prototype.updateChecks = function () {\r\n        this.checks = Parse_Parse.givenFrequency([\r\n            this.year,\r\n            this.month,\r\n            this.week,\r\n            this.weekOfYear,\r\n            this.fullWeekOfYear,\r\n            this.weekspanOfYear,\r\n            this.lastFullWeekOfYear,\r\n            this.lastWeekspanOfYear,\r\n            this.weekOfMonth,\r\n            this.weekspanOfMonth,\r\n            this.fullWeekOfMonth,\r\n            this.lastWeekspanOfMonth,\r\n            this.lastFullWeekOfMonth,\r\n            this.dayOfWeek,\r\n            this.dayOfMonth,\r\n            this.lastDayOfMonth,\r\n            this.dayOfYear\r\n        ]);\r\n        return this;\r\n    };\r\n    /**\r\n     * Determines whether the given day lies between the earliest and latest\r\n     * valid day in the schedule.\r\n     *\r\n     * @param day The day to test.\r\n     * @returns `true` if the day lies in the schedule, otherwise `false`.\r\n     * @see [[Schedule.start]]\r\n     * @see [[Schedule.end]]\r\n     */\r\n    Schedule.prototype.matchesSpan = function (day) {\r\n        return (this.start === null || day.isSameOrAfter(this.start)) &&\r\n            (this.end === null || day.isBefore(this.end));\r\n    };\r\n    /**\r\n     * Determines whether the given range overlaps with the earliest and latest\r\n     * valid days in this schedule (if any).\r\n     *\r\n     * @param start The first day in the range.\r\n     * @param end The last day in the range.\r\n     * @returns `true` if the range intersects with the schedule, otherwise `false`.\r\n     * @see [[Schedule.start]]\r\n     * @see [[Schedule.end]]\r\n     */\r\n    Schedule.prototype.matchesRange = function (start, end) {\r\n        if (this.start && end.isBefore(this.start)) {\r\n            return false;\r\n        }\r\n        if (this.end && start.isAfter(this.end)) {\r\n            return false;\r\n        }\r\n        return true;\r\n    };\r\n    /**\r\n     * Determines whether the given day is explicitly excluded in the schedule.\r\n     *\r\n     * @param day The day to test.\r\n     * @param lookAtTime lookAtTime If the specific time of the given day should\r\n     *    be looked at.\r\n     * @returns `true` if the day was excluded, otherwise `false`.\r\n     */\r\n    Schedule.prototype.isExcluded = function (day, lookAtTime) {\r\n        if (lookAtTime === void 0) { lookAtTime = true; }\r\n        return this.exclude.get(day, false, lookAtTime);\r\n    };\r\n    /**\r\n     * Determines whether the given day is explicitly included in the schedule.\r\n     *\r\n     * @param day The day to test.\r\n     * @param lookAtTime lookAtTime If the specific time of the given day should\r\n     *    be looked at.\r\n     * @returns `true` if the day is NOT explicitly included, otherwise `false`.\r\n     */\r\n    Schedule.prototype.isIncluded = function (day, lookAtTime) {\r\n        if (lookAtTime === void 0) { lookAtTime = true; }\r\n        return this.include.get(day, false, lookAtTime);\r\n    };\r\n    /**\r\n     * Determines whether the given day is cancelled in the schedule.\r\n     *\r\n     * @param day The day to test.\r\n     * @param lookAtTime lookAtTime If the specific time of the given day should\r\n     *    be looked at.\r\n     * @returns `true` if the day was cancelled, otherwise `false`.\r\n     */\r\n    Schedule.prototype.isCancelled = function (day, lookAtTime) {\r\n        if (lookAtTime === void 0) { lookAtTime = true; }\r\n        return this.cancel.get(day, false, lookAtTime);\r\n    };\r\n    /**\r\n     * Returns the metadata for the given day or `null` if there is none.\r\n     *\r\n     * @param day The day to return the metadata for.\r\n     * @param otherwise The data to return if none exists for the given day.\r\n     * @param lookAtTime lookAtTime If the specific time of the given day should\r\n     *    be looked at.\r\n     * @returns The metadata or `null`.\r\n     */\r\n    Schedule.prototype.getMeta = function (day, otherwise, lookAtTime) {\r\n        if (otherwise === void 0) { otherwise = null; }\r\n        if (lookAtTime === void 0) { lookAtTime = true; }\r\n        return this.meta.get(day, otherwise, lookAtTime);\r\n    };\r\n    /**\r\n     * Returns all metadata for the given day or an empty array if there is none.\r\n     *\r\n     * @param day The day to return the metadata for.\r\n     * @returns The array of metadata ordered by priority or an empty array.\r\n     */\r\n    Schedule.prototype.getMetas = function (day) {\r\n        return this.meta.getAll(day);\r\n    };\r\n    /**\r\n     * Returns whether the events in the schedule are all day long or start at\r\n     * specific times. Full day events start at the start of the day and end at\r\n     * the start of the next day (if the duration = `1` and durationUnit = 'days').\r\n     * Full day events have no times specified and should have a durationUnit of\r\n     * either `days` or `weeks`.\r\n     */\r\n    Schedule.prototype.isFullDay = function () {\r\n        return this.times.length === 0;\r\n    };\r\n    /**\r\n     * Sets whether this schedule is a full day event if it is not already. If\r\n     * this schedule is a full day event and `false` is passed to this function\r\n     * a single timed event will be added based on `defaultTime`. If this schedule\r\n     * has timed events and `true` is passed to make the schedule full day, the\r\n     * timed events are removed from this schedule. If the durationUnit is not the\r\n     * expected unit based on the new full day flag - the duration is reset to 1\r\n     * and the duration unit is set to the expected unit.\r\n     *\r\n     * @param fullDay Whether this schedule should represent a full day event or\r\n     *    timed events.\r\n     * @param defaultTime If `fullDay` is `false` and this schedule is currently\r\n     *    a full day event - this time will be used as the time of the first event.\r\n     */\r\n    Schedule.prototype.setFullDay = function (fullDay, defaultTime) {\r\n        if (fullDay === void 0) { fullDay = true; }\r\n        if (defaultTime === void 0) { defaultTime = '08:00'; }\r\n        if (fullDay !== this.isFullDay()) {\r\n            if (fullDay) {\r\n                this.times = [];\r\n                if (this.durationUnit !== 'days' && this.durationUnit !== 'day') {\r\n                    this.duration = 1;\r\n                    this.durationUnit = 'days';\r\n                }\r\n            }\r\n            else {\r\n                this.times = [Parse_Parse.time(defaultTime)];\r\n                if (this.durationUnit !== 'hours' && this.durationUnit !== 'hour') {\r\n                    this.duration = 1;\r\n                    this.durationUnit = 'hours';\r\n                }\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Adjusts the [[Schedule.start]] and [[Schedule.end]] dates specified on this\r\n     * schedule if this schedule represents a single event and the `start` and\r\n     * `end` are already set or `addSpan` is `true`.\r\n     *\r\n     * @param addSpan If `true`, the `start` and `end` dates will always be\r\n     *    adjusted if this schedule is a single event.\r\n     */\r\n    Schedule.prototype.adjustDefinedSpan = function (addSpan) {\r\n        if (addSpan === void 0) { addSpan = false; }\r\n        var single = this.getSingleEventSpan();\r\n        if (single && (addSpan || (this.start && this.end))) {\r\n            this.start = single.start.start();\r\n            this.end = single.end.end();\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Returns a span of time for a schedule with full day events starting on the\r\n     * start of the given day with the desired duration in days or weeks.\r\n     *\r\n     * @param day The day the span starts on.\r\n     * @returns The span of time starting on the given day.\r\n     */\r\n    Schedule.prototype.getFullSpan = function (day) {\r\n        var start = day.start();\r\n        var end = start.add(this.duration, this.durationUnit);\r\n        return new DaySpan_DaySpan(start, end);\r\n    };\r\n    /**\r\n     * Returns a span of time starting on the given day at the given day with the\r\n     * duration specified on this schedule.\r\n     *\r\n     * @param day The day the span starts on.\r\n     * @param time The time of day the span starts.\r\n     * @returns The span of time calculated.\r\n     */\r\n    Schedule.prototype.getTimeSpan = function (day, time) {\r\n        var start = day.withTime(time);\r\n        var end = start.add(this.duration, this.durationUnit);\r\n        return new DaySpan_DaySpan(start, end);\r\n    };\r\n    /**\r\n     * Determines whether the given day is a day on the schedule for the start\r\n     * of an event. If an event is more than one day and the day given is not the\r\n     * start this may return `false`. This does not test for event instances\r\n     * that exist through [[Schedule.include]].\r\n     *\r\n     * @param day The day to test.\r\n     * @returns `true` if the day marks the start of an event on the schedule.\r\n     * @see [[Schedule.isIncluded]]\r\n     * @see [[Schedule.isFullyExcluded]]\r\n     * @see [[Schedule.matchesSpan]]\r\n     */\r\n    Schedule.prototype.matchesDay = function (day) {\r\n        if (this.isIncluded(day, false)) {\r\n            return true;\r\n        }\r\n        if (!this.matchesSpan(day) || this.isFullyExcluded(day)) {\r\n            return false;\r\n        }\r\n        for (var _i = 0, _a = this.checks; _i < _a.length; _i++) {\r\n            var check = _a[_i];\r\n            if (!check(day[check.property])) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    };\r\n    /**\r\n     * Determines whether the given day has events added through\r\n     * [[Schedule.include]].\r\n     *\r\n     * @param day The day to look for included times on.\r\n     * @returns `true` if there are included event instances on the given day,\r\n     *    otherwise `false`.\r\n     */\r\n    Schedule.prototype.hasIncludedTime = function (day) {\r\n        return !this.iterateIncludeTimes(day).isEmpty();\r\n    };\r\n    /**\r\n     * Determines whether the given day is fully excluded from the schedule. A\r\n     * fully excluded day is one that has a day-wide exclusion, or the schedule\r\n     * is not an all-day event and all times in the schedule are specifically\r\n     * excluded.\r\n     *\r\n     * @param day The day to test.*\r\n     * @returns `true` if he day is fully excluded, otherwise `false`.\r\n     */\r\n    Schedule.prototype.isFullyExcluded = function (day) {\r\n        if (this.isExcluded(day, false)) {\r\n            return true;\r\n        }\r\n        if (this.isFullDay()) {\r\n            return false;\r\n        }\r\n        for (var _i = 0, _a = this.times; _i < _a.length; _i++) {\r\n            var time = _a[_i];\r\n            if (!this.isExcluded(day.withTime(time))) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    };\r\n    /**\r\n     * Finds the next day an event occurs on the schedule given a day to start,\r\n     * optionally including it, and a maximum number of days to look ahead.\r\n     *\r\n     * @param day The day to start to search from.\r\n     * @param includeDay If the given day should be included in the search.\r\n     * @param lookAhead The maximum number of days to look ahead from the given\r\n     *     day for event occurrences.\r\n     * @returns The next day on the schedule or `null` if none exists.\r\n     */\r\n    Schedule.prototype.nextDay = function (day, includeDay, lookAhead) {\r\n        if (includeDay === void 0) { includeDay = false; }\r\n        if (lookAhead === void 0) { lookAhead = 366; }\r\n        return this.iterateDaycast(day, 1, true, includeDay, lookAhead).first();\r\n    };\r\n    /**\r\n     * Finds the next specified number of days that events occur on the schedule\r\n     * given a day to start, optionally including it, and a maximum number of days\r\n     * to look ahead.\r\n     *\r\n     * @param day The day to start to search from.\r\n     * @param max The maximum number of days to return in the result.\r\n     * @param includeDay If the given day should be included in the search.\r\n     * @param lookAhead The maximum number of days to look ahead from the given\r\n     *     day for event occurrences.\r\n     * @returns An array containing the next days on the schedule that events\r\n     *    start or an empty array if there are none.\r\n     */\r\n    Schedule.prototype.nextDays = function (day, max, includeDay, lookAhead) {\r\n        if (includeDay === void 0) { includeDay = false; }\r\n        if (lookAhead === void 0) { lookAhead = 366; }\r\n        return this.iterateDaycast(day, max, true, includeDay, lookAhead);\r\n    };\r\n    /**\r\n     * Finds the previous day an event occurs on the schedule given a day to start,\r\n     * optionally including it, and a maximum number of days to look behind.\r\n     *\r\n     * @param day The day to start to search from.\r\n     * @param includeDay If the given day should be included in the search.\r\n     * @param lookBack The maximum number of days to look behind from the given\r\n     *     day for event occurrences.\r\n     * @returns The previous day on the schedule or `null` if none exists.\r\n     */\r\n    Schedule.prototype.prevDay = function (day, includeDay, lookBack) {\r\n        if (includeDay === void 0) { includeDay = false; }\r\n        if (lookBack === void 0) { lookBack = 366; }\r\n        return this.iterateDaycast(day, 1, false, includeDay, lookBack).first();\r\n    };\r\n    /**\r\n     * Finds the previous specified number of days that events occur on the\r\n     * schedule given a day to start, optionally including it, and a maximum\r\n     * number of days to look behind.\r\n     *\r\n     * @param day The day to start to search from.\r\n     * @param max The maximum number of days to return in the result.\r\n     * @param includeDay If the given day should be included in the search.\r\n     * @param lookAhead The maximum number of days to look behind from the given\r\n     *     day for event occurrences.\r\n     * @returns An array containing the previous days on the schedule that events\r\n     *    start or an empty array if there are none.\r\n     */\r\n    Schedule.prototype.prevDays = function (day, max, includeDay, lookBack) {\r\n        if (includeDay === void 0) { includeDay = false; }\r\n        if (lookBack === void 0) { lookBack = 366; }\r\n        return this.iterateDaycast(day, max, false, includeDay, lookBack);\r\n    };\r\n    /**\r\n     * Iterates over days that events start in the schedule given a day to start,\r\n     * a maximum number of days to find, and a direction to look.\r\n     *\r\n     * @param day The day to start to search from.\r\n     * @param max The maximum number of days to iterate.\r\n     * @param next If `true` this searches forward, otherwise `false` is backwards.\r\n     * @param includeDay If the given day should be included in the search.\r\n     * @param lookup The maximum number of days to look through from the given\r\n     *     day for event occurrences.\r\n     * @returns A new Iterator for the days found in the cast.\r\n     * @see [[Schedule.iterateSpans]]\r\n     */\r\n    Schedule.prototype.iterateDaycast = function (day, max, next, includeDay, lookup) {\r\n        var _this = this;\r\n        if (includeDay === void 0) { includeDay = false; }\r\n        if (lookup === void 0) { lookup = 366; }\r\n        return new Iterator_Iterator(function (iterator) {\r\n            var iterated = 0;\r\n            for (var days = 0; days < lookup; days++) {\r\n                if (!includeDay || days > 0) {\r\n                    day = next ? day.next() : day.prev();\r\n                }\r\n                if (!_this.iterateSpans(day, false).isEmpty()) {\r\n                    var action = iterator.act(day);\r\n                    if (action === IteratorAction.Stop || ++iterated >= max) {\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * Iterates through the spans (event instances) that start on or covers the\r\n     * given day.\r\n     *\r\n     * @param day The day to look for spans on.\r\n     * @param covers If `true` spans which span multiple days will be looked at\r\n     *    to see if they intersect with the given day, otherwise `false` will\r\n     *    only look at the given day for the start of events.\r\n     * @returns A new Iterator for all the spans found.\r\n     */\r\n    Schedule.prototype.iterateSpans = function (day, covers) {\r\n        var _this = this;\r\n        if (covers === void 0) { covers = false; }\r\n        return new Iterator_Iterator(function (iterator) {\r\n            var current = day;\r\n            var lookBehind = covers ? _this.durationInDays : 0;\r\n            // If the events start at the end of the day and may last multiple days....\r\n            if (_this.isFullDay()) {\r\n                // If the schedule has events which span multiple days we need to look\r\n                // backwards for events that overlap with the given day.\r\n                while (lookBehind >= 0) {\r\n                    // If the current day matches the schedule rules...\r\n                    if (_this.matchesDay(current)) {\r\n                        // Build a DaySpan with the given start day and the schedules duration.\r\n                        var span = _this.getFullSpan(current);\r\n                        // If that dayspan intersects with the given day, it's a winner!\r\n                        if (span.matchesDay(day)) {\r\n                            switch (iterator.act(span)) {\r\n                                case IteratorAction.Stop:\r\n                                    return;\r\n                            }\r\n                        }\r\n                    }\r\n                    current = current.prev();\r\n                    lookBehind--;\r\n                }\r\n            }\r\n            else {\r\n                // If the schedule has events which span multiple days we need to look\r\n                // backwards for events that overlap with the given day.\r\n                while (lookBehind >= 0) {\r\n                    // If the current day matches the schedule rules...\r\n                    if (_this.matchesDay(current)) {\r\n                        // Iterate through each daily occurrence in the schedule...\r\n                        for (var _i = 0, _a = _this.times; _i < _a.length; _i++) {\r\n                            var time = _a[_i];\r\n                            var span = _this.getTimeSpan(current, time);\r\n                            // If the event intersects with the given day and the occurrence\r\n                            // has not specifically been excluded...\r\n                            if (span.matchesDay(day) && !_this.isExcluded(span.start, true)) {\r\n                                switch (iterator.act(span)) {\r\n                                    case IteratorAction.Stop:\r\n                                        return;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    else {\r\n                        // The current day does not match the schedule, however the schedule\r\n                        // might have moved/random event occurrents on the current day.\r\n                        // We only want the ones that overlap with the given day.\r\n                        _this.iterateIncludeTimes(current, day).iterate(function (span, timeIterator) {\r\n                            switch (iterator.act(span)) {\r\n                                case IteratorAction.Stop:\r\n                                    timeIterator.stop();\r\n                                    break;\r\n                            }\r\n                        });\r\n                        if (iterator.action === IteratorAction.Stop) {\r\n                            return;\r\n                        }\r\n                    }\r\n                    current = current.prev();\r\n                    lookBehind--;\r\n                }\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * Determines if the given day is on the schedule and the time specified on\r\n     * the day matches one of the times on the schedule.\r\n     *\r\n     * @param day The day to test.\r\n     * @returns `true` if the day and time match the schedule, otherwise false.\r\n     */\r\n    Schedule.prototype.matchesTime = function (day) {\r\n        return !!this.iterateSpans(day, true).first(function (span) { return span.start.sameMinute(day); });\r\n    };\r\n    /**\r\n     * Determines if the given day is covered by this schedule. A schedule can\r\n     * specify events that span multiple days - so even though the day does not\r\n     * match the starting day of a span - it can be a day that is within the\r\n     * schedule.\r\n     *\r\n     * @param day The day to test.\r\n     * @returns `true` if the day is covered by an event on this schedule,\r\n     *    otherwise `false`.\r\n     */\r\n    Schedule.prototype.coversDay = function (day) {\r\n        return !this.iterateSpans(day, true).isEmpty();\r\n    };\r\n    /**\r\n     * Determines if the given timestamp lies in an event occurrence on this\r\n     * schedule.\r\n     *\r\n     * @param day The timestamp to test against the schedule.\r\n     * @return `true` if the timestamp lies in an event occurrent start and end\r\n     *    timestamps, otherwise `false`.\r\n     */\r\n    Schedule.prototype.coversTime = function (day) {\r\n        return !!this.iterateSpans(day, true).first(function (span) { return span.contains(day); });\r\n    };\r\n    /**\r\n     * Sets the frequency for the given property. This does not update the\r\n     * [[Schedule.checks]] array, the [[Schedule.updateChecks]] function needs\r\n     * to be called.\r\n     *\r\n     * @param property The frequency to update.\r\n     * @param frequency The new frequency.\r\n     */\r\n    Schedule.prototype.setFrequency = function (property, frequency) {\r\n        this[property] = Parse_Parse.frequency(frequency, property);\r\n        return this;\r\n    };\r\n    /**\r\n     * Changes the exclusion status of the event at the given time. By default\r\n     * this excludes this event - but `false`  may be passed to undo an exclusion.\r\n     *\r\n     * @param time The start time of the event occurrence to exclude or include.\r\n     * @param excluded Whether the event should be excluded.\r\n     */\r\n    Schedule.prototype.setExcluded = function (time, excluded) {\r\n        if (excluded === void 0) { excluded = true; }\r\n        var type = this.identifierType;\r\n        this.exclude.set(time, excluded, type);\r\n        this.include.set(time, !excluded, type);\r\n        return this;\r\n    };\r\n    /**\r\n     * Changes the cancellation status of the event at the given start time. By\r\n     * default this cancels the event occurrence - but `false` may be passed to\r\n     * undo a cancellation.\r\n     *\r\n     * @param time The start time of the event occurrence to cancel or uncancel.\r\n     * @param cancelled Whether the event should be cancelled.\r\n     */\r\n    Schedule.prototype.setCancelled = function (time, cancelled) {\r\n        if (cancelled === void 0) { cancelled = true; }\r\n        this.cancel.set(time, cancelled, this.identifierType);\r\n        return this;\r\n    };\r\n    /**\r\n     * Removes the time from this schedule and all related included, excluded,\r\n     * cancelled instances as well as metadata.\r\n     *\r\n     * @param time The time to remove from the schedule.\r\n     * @param removeInclude If any included instances should be removed as well.\r\n     * @returns `true` if the time was removed, otherwise `false`.\r\n     */\r\n    Schedule.prototype.removeTime = function (time, removeInclude) {\r\n        if (removeInclude === void 0) { removeInclude = true; }\r\n        var found = false;\r\n        for (var i = 0; i < this.times.length && !found; i++) {\r\n            if (found = time.matches(this.times[i])) {\r\n                this.times.splice(i, 1);\r\n            }\r\n        }\r\n        if (found) {\r\n            if (removeInclude) {\r\n                this.include.removeTime(time);\r\n            }\r\n            this.exclude.removeTime(time);\r\n            this.cancel.removeTime(time);\r\n            this.meta.removeTime(time);\r\n        }\r\n        return found;\r\n    };\r\n    /**\r\n     * Moves the event instance starting at `fromTime` to `toTime` optionally\r\n     * placing `meta` in the schedules metadata for the new time `toTime`.\r\n     * If this schedule has a single event ([[Schedule.isSingleEvent]]) then the\r\n     * only value needed is `toTime` and not `fromTime`.\r\n     *\r\n     * @param toTime The timestamp of the new event.\r\n     * @param fromTime The timestamp of the event on the schedule to move if this\r\n     *    schedule generates multiple events.\r\n     * @returns `true` if the schedule had the event moved, otherwise `false`.\r\n     */\r\n    Schedule.prototype.move = function (toTime, fromTime, meta) {\r\n        if (!this.moveSingleEvent(toTime) && fromTime) {\r\n            return this.moveInstance(fromTime, toTime);\r\n        }\r\n        return false;\r\n    };\r\n    /**\r\n     * Moves a time specified in this schedule to the given time, adjusting\r\n     * any cancelled event instances, metadata, and any excluded and included\r\n     * event instances.\r\n     *\r\n     * @param fromTime The time to move.\r\n     * @param toTime The new time in the schedule.\r\n     * @returns `true` if time was moved, otherwise `false`.\r\n     */\r\n    Schedule.prototype.moveTime = function (fromTime, toTime) {\r\n        var found = false;\r\n        for (var i = 0; i < this.times.length && !found; i++) {\r\n            if (found = fromTime.matches(this.times[i])) {\r\n                this.times.splice(i, 1, toTime);\r\n            }\r\n        }\r\n        if (found) {\r\n            this.include.moveTime(fromTime, toTime);\r\n            this.exclude.moveTime(fromTime, toTime);\r\n            this.cancel.moveTime(fromTime, toTime);\r\n            this.meta.moveTime(fromTime, toTime);\r\n            this.adjustDefinedSpan(false);\r\n        }\r\n        return found;\r\n    };\r\n    /**\r\n     * Moves the event instance starting at `fromTime` to `toTime` optionally\r\n     * placing `meta` in the schedules metadata for the new time `toTime`. A move\r\n     * is accomplished by excluding the current event and adding an inclusion of\r\n     * the new day & time.\r\n     *\r\n     * @param fromTime The timestamp of the event on the schedule to move.\r\n     * @param toTime The timestamp of the new event.\r\n     * @returns `true`.\r\n     * @see [[Schedule.move]]\r\n     */\r\n    Schedule.prototype.moveInstance = function (fromTime, toTime) {\r\n        var type = this.identifierType;\r\n        this.exclude.set(fromTime, true, type);\r\n        this.exclude.set(toTime, false, type);\r\n        this.include.set(toTime, true, type);\r\n        this.include.set(fromTime, false, type);\r\n        if (this.cancel.get(fromTime, false) && !this.cancel.get(toTime, false)) {\r\n            this.cancel.set(toTime, true, type);\r\n            if (this.cancel.getIdentifier(fromTime) === type) {\r\n                this.cancel.unset(fromTime, type);\r\n            }\r\n        }\r\n        var meta = this.meta.get(fromTime, null);\r\n        if (meta && meta !== this.meta.get(toTime, null)) {\r\n            this.meta.set(toTime, meta, type);\r\n            if (this.meta.getIdentifier(fromTime) === type) {\r\n                this.meta.unset(fromTime, type);\r\n            }\r\n        }\r\n        return true;\r\n    };\r\n    /**\r\n     * Moves the single event in this schedule to the given day/time if applicable.\r\n     * If this schedule is not a single event schedule then `false` is returned.\r\n     * If this schedule is a timed event the time will take the time of the given\r\n     * `toTime` of `takeTime` is `true`.\r\n     *\r\n     * @param toTime The time to move the single event to.\r\n     * @param takeTime If this schedule has a single timed event, should the time\r\n     *    of the event be changed to the time of the given `toTime`?\r\n     * @returns `true` if the schedule was adjusted, otherwise `false`.\r\n     * @see [[Schedule.move]]\r\n     */\r\n    Schedule.prototype.moveSingleEvent = function (toTime, takeTime) {\r\n        if (takeTime === void 0) { takeTime = true; }\r\n        if (!this.isSingleEvent()) {\r\n            return false;\r\n        }\r\n        for (var _i = 0, _a = this.checks; _i < _a.length; _i++) {\r\n            var check = _a[_i];\r\n            var prop = check.property;\r\n            var value = toTime[prop];\r\n            var frequency = Parse_Parse.frequency([value], prop);\r\n            this[prop] = frequency;\r\n        }\r\n        if (this.times.length === 1 && takeTime) {\r\n            this.times = [toTime.asTime()];\r\n        }\r\n        this.updateChecks();\r\n        var span = this.getSingleEventSpan();\r\n        if (this.start) {\r\n            this.start = span.start.start();\r\n        }\r\n        if (this.end) {\r\n            this.end = span.end.end();\r\n        }\r\n        return true;\r\n    };\r\n    /**\r\n     * Returns the span of the single event in this schedule if it's that type of\r\n     * schedule, otherwise `null` is returned.\r\n     *\r\n     * @returns A span of the single event, otherwise `null`.\r\n     * @see [[Schedule.isSingleEvent]]\r\n     */\r\n    Schedule.prototype.getSingleEventSpan = function () {\r\n        if (!this.isSingleEvent()) {\r\n            return null;\r\n        }\r\n        var startOfYear = Day_Day.build(this.year.input[0], 0, 1);\r\n        var start = this.iterateDaycast(startOfYear, 1, true, true, 366).first();\r\n        if (!start) {\r\n            return null;\r\n        }\r\n        return this.isFullDay() ?\r\n            this.getFullSpan(start) :\r\n            this.getTimeSpan(start, this.times[0]);\r\n    };\r\n    /**\r\n     * Determines whether this schedule produces a single event, and no more.\r\n     * If this schedule has any includes, it's assumed to be a multiple event\r\n     * schedule. A single event can be detected in the following scenarios where\r\n     * each frequency has a single occurrence (see [[Schedule.isSingleFrequency]]).\r\n     *\r\n     * - year, day of year\r\n     * - year, month, day of month\r\n     * - year, month, week of month, day of week\r\n     * - year, week of year, day of week\r\n     *\r\n     * @returns `true` if this schedule produces a single event, otherwise `false`.\r\n     */\r\n    Schedule.prototype.isSingleEvent = function () {\r\n        // 0 = full day, 1 = once a day, 1+ = multiple events a day\r\n        if (this.times.length > 1) {\r\n            return false;\r\n        }\r\n        // Let's assume if there are includes, this is not a single event.\r\n        if (!this.include.isEmpty()) {\r\n            return false;\r\n        }\r\n        // If this can occur on multiple years, not a single event.\r\n        if (!this.isSingleYear()) {\r\n            return false;\r\n        }\r\n        // If this is a specific year and day of the year: single!\r\n        if (this.isSingleDayOfYear()) {\r\n            return true;\r\n        }\r\n        // If this is a specific year, month, and day of month: single!\r\n        if (this.isSingleMonth() && this.isSingleDayOfMonth()) {\r\n            return true;\r\n        }\r\n        // If this is a specific year, month, week of the month, day of the week: single!\r\n        if (this.isSingleMonth() && this.isSingleWeekOfMonth() && this.isSingleDayOfWeek()) {\r\n            return true;\r\n        }\r\n        // If this is a specific year, week of the year, day of the week: single!\r\n        if (this.isSingleWeekOfYear() && this.isSingleDayOfWeek()) {\r\n            return true;\r\n        }\r\n        // Doesn't look like a single event.\r\n        return false;\r\n    };\r\n    /**\r\n     * @returns `true` if this schedule produces events only in a specific year.\r\n     * @see [[Schedule.year]]\r\n     */\r\n    Schedule.prototype.isSingleYear = function () {\r\n        return this.isSingleFrequency(this.year);\r\n    };\r\n    /**\r\n     * @returns `true` if this schedule produces events only in a specific month.\r\n     * @see [[Schedule.month]]\r\n     */\r\n    Schedule.prototype.isSingleMonth = function () {\r\n        return this.isSingleFrequency(this.month);\r\n    };\r\n    /**\r\n     * @returns `true` if this schedule produces events only in a specific day of\r\n     *    the month.\r\n     * @see [[Schedule.dayOfMonth]]\r\n     * @see [[Schedule.lastDayOfMonth]]\r\n     */\r\n    Schedule.prototype.isSingleDayOfMonth = function () {\r\n        return this.isSingleFrequency(this.dayOfMonth) ||\r\n            this.isSingleFrequency(this.lastDayOfMonth);\r\n    };\r\n    /**\r\n     * @returns `true` if this schedule produces events only in a specific day of\r\n     *    the week.\r\n     * @see [[Schedule.dayOfWeek]]\r\n     */\r\n    Schedule.prototype.isSingleDayOfWeek = function () {\r\n        return this.isSingleFrequency(this.dayOfWeek);\r\n    };\r\n    /**\r\n     * @returns `true` if this schedule produces events only in a specific day of\r\n     *    the year.\r\n     * @see [[Schedule.dayOfYear]]\r\n     */\r\n    Schedule.prototype.isSingleDayOfYear = function () {\r\n        return this.isSingleFrequency(this.dayOfYear);\r\n    };\r\n    /**\r\n     * @returns `true` if this schedule produces events only in a specific week of\r\n     *    the month.\r\n     * @see [[Schedule.weekspanOfMonth]]\r\n     * @see [[Schedule.fullWeekOfMonth]]\r\n     * @see [[Schedule.weekOfMonth]]\r\n     * @see [[Schedule.lastFullWeekOfMonth]]\r\n     * @see [[Schedule.lastWeekspanOfMonth]]\r\n     */\r\n    Schedule.prototype.isSingleWeekOfMonth = function () {\r\n        return this.isSingleFrequency(this.weekspanOfMonth) ||\r\n            this.isSingleFrequency(this.fullWeekOfMonth) ||\r\n            this.isSingleFrequency(this.weekOfMonth) ||\r\n            this.isSingleFrequency(this.lastFullWeekOfMonth) ||\r\n            this.isSingleFrequency(this.lastWeekspanOfMonth);\r\n    };\r\n    /**\r\n     * @returns `true` if this schedule produces events only in a specific week of\r\n     *    the year.\r\n     * @see [[Schedule.weekspanOfYear]]\r\n     * @see [[Schedule.fullWeekOfYear]]\r\n     * @see [[Schedule.week]]\r\n     * @see [[Schedule.weekOfYear]]\r\n     * @see [[Schedule.lastFullWeekOfYear]]\r\n     * @see [[Schedule.lastWeekspanOfYear]]\r\n     */\r\n    Schedule.prototype.isSingleWeekOfYear = function () {\r\n        return this.isSingleFrequency(this.weekspanOfYear) ||\r\n            this.isSingleFrequency(this.fullWeekOfYear) ||\r\n            this.isSingleFrequency(this.week) ||\r\n            this.isSingleFrequency(this.weekOfYear) ||\r\n            this.isSingleFrequency(this.lastFullWeekOfYear) ||\r\n            this.isSingleFrequency(this.lastWeekspanOfYear);\r\n    };\r\n    /**\r\n     * Determines if the given [[FrequencyCheck]] results in a single occurrence.\r\n     *\r\n     * @returns `true` if the frequency results in a single event, otherwise `false`.\r\n     */\r\n    Schedule.prototype.isSingleFrequency = function (frequency) {\r\n        return Functions.isArray(frequency.input) && frequency.input.length === 1;\r\n    };\r\n    /**\r\n     * Creates a forecast for this schedule which returns a number of event\r\n     * occurrences around a given day. A single item could be returned per day, or\r\n     * you could get an item for each timed event occurrence.\r\n     *\r\n     * @param around The day to find a forecast around.\r\n     * @param covers If `true` spans which span multiple days will be looked at\r\n     *    to see if they intersect with the given day, otherwise `false` will\r\n     *    only look at the given day for the start of events.\r\n     * @param daysAfter The number of events to return before the given day.\r\n     * @param daysBefore The number of events to return after the given day.\r\n     * @param times If timed events should be returned, or only one for each day.\r\n     * @param lookAround How many days to look before and after the given day for\r\n     *    event occurrences.\r\n     * @returns A new iterator which provides the event occurence span, the day it\r\n     *    starts (or is covered if `covers` is `true`), and the identifier for the\r\n     *    event.\r\n     */\r\n    Schedule.prototype.forecast = function (around, covers, daysAfter, daysBefore, times, lookAround) {\r\n        var _this = this;\r\n        if (covers === void 0) { covers = true; }\r\n        if (daysBefore === void 0) { daysBefore = daysAfter; }\r\n        if (times === void 0) { times = false; }\r\n        if (lookAround === void 0) { lookAround = 366; }\r\n        var type = this.identifierType;\r\n        var tuplesForDay = function (day, tuples) {\r\n            var spans = _this.iterateSpans(day, covers).list();\r\n            var last = times ? spans.length : Math.min(1, spans.length);\r\n            var offset = times ? 0 : spans.length - 1;\r\n            for (var i = 0; i < last; i++) {\r\n                var span = spans[i + offset];\r\n                var id = type.get(span.start);\r\n                if (tuples.act([span, day, id]) === IteratorAction.Stop) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        };\r\n        var prev = new Iterator_Iterator(function (iterator) {\r\n            var curr = around;\r\n            for (var i = 0; i < lookAround; i++) {\r\n                if (!tuplesForDay(curr, iterator)) {\r\n                    break;\r\n                }\r\n                curr = curr.prev();\r\n            }\r\n        });\r\n        var next = new Iterator_Iterator(function (iterator) {\r\n            var curr = around;\r\n            for (var i = 0; i < lookAround; i++) {\r\n                curr = curr.next();\r\n                if (!tuplesForDay(curr, iterator)) {\r\n                    break;\r\n                }\r\n            }\r\n        });\r\n        return prev.take(daysBefore + 1).reverse().append(next.take(daysAfter));\r\n    };\r\n    /**\r\n     * Iterates timed events that were explicitly specified on the given day.\r\n     * Those events could span multiple days so may be tested against another day.\r\n     *\r\n     * @param day The day to look for included timed events.\r\n     * @param matchAgainst The day to test against the timed event.\r\n     * @returns A new Iterator for all the included spans found.\r\n     */\r\n    Schedule.prototype.iterateIncludeTimes = function (day, matchAgainst) {\r\n        var _this = this;\r\n        if (matchAgainst === void 0) { matchAgainst = day; }\r\n        var isIncludedTime = function (result) {\r\n            var id = result[0], included = result[1];\r\n            return included && Identifier_Identifier.Time.is(id);\r\n        };\r\n        var getSpan = function (result) {\r\n            var id = result[0];\r\n            var time = Identifier_Identifier.Time.start(id);\r\n            var span = _this.getTimeSpan(time, time.asTime());\r\n            if (span.matchesDay(matchAgainst)) {\r\n                return span;\r\n            }\r\n        };\r\n        return this.include.query(day.dayIdentifier).map(getSpan, isIncludedTime);\r\n    };\r\n    /**\r\n     * Clones this schedule.\r\n     *\r\n     * @returns A new schedule which matches this schedule.\r\n     */\r\n    Schedule.prototype.clone = function () {\r\n        return new Schedule(this.toInput());\r\n    };\r\n    /**\r\n     * Converts the schedule instance back into input.\r\n     *\r\n     * @param returnDays When `true` the start, end, and array of exclusions will\r\n     *    have [[Day]] instances, otherwise the UTC timestamp and dayIdentifiers\r\n     *    will be used when `false`.\r\n     * @param returnTimes When `true` the times returned in the input will be\r\n     *    instances of [[Time]] otherwise the `timeFormat` is used to convert the\r\n     *    times to strings.\r\n     * @param timeFormat The time format to use when returning the times as strings.\r\n     * @param alwaysDuration If the duration values (`duration` and\r\n     *    `durationUnit`) should always be returned in the input.\r\n     * @returns The input that describes this schedule.\r\n     * @see [[Time.format]]\r\n     */\r\n    Schedule.prototype.toInput = function (returnDays, returnTimes, timeFormat, alwaysDuration) {\r\n        if (returnDays === void 0) { returnDays = false; }\r\n        if (returnTimes === void 0) { returnTimes = false; }\r\n        if (timeFormat === void 0) { timeFormat = ''; }\r\n        if (alwaysDuration === void 0) { alwaysDuration = false; }\r\n        var defaultUnit = Constants.DURATION_DEFAULT_UNIT(this.isFullDay());\r\n        var exclusions = this.exclude.identifiers(function (v) { return v; }).list();\r\n        var inclusions = this.include.identifiers(function (v) { return v; }).list();\r\n        var cancels = this.cancel.identifiers(function (v) { return v; }).list();\r\n        var hasMeta = !this.meta.isEmpty();\r\n        var out = {};\r\n        var times = [];\r\n        for (var _i = 0, _a = this.times; _i < _a.length; _i++) {\r\n            var time = _a[_i];\r\n            times.push(returnTimes ? time : (timeFormat ? time.format(timeFormat) : time.toString()));\r\n        }\r\n        if (this.start)\r\n            out.start = returnDays ? this.start : this.start.time;\r\n        if (this.end)\r\n            out.end = returnDays ? this.end : this.end.time;\r\n        if (times.length)\r\n            out.times = times;\r\n        if (alwaysDuration || this.duration !== Constants.DURATION_DEFAULT)\r\n            out.duration = this.duration;\r\n        if (alwaysDuration || this.durationUnit !== defaultUnit)\r\n            out.durationUnit = this.durationUnit;\r\n        if (exclusions.length)\r\n            out.exclude = exclusions;\r\n        if (inclusions.length)\r\n            out.include = inclusions;\r\n        if (cancels.length)\r\n            out.cancel = cancels;\r\n        if (hasMeta)\r\n            out.meta = Functions.extend({}, this.meta.map);\r\n        if (this.dayOfWeek.input)\r\n            out.dayOfWeek = this.dayOfWeek.input;\r\n        if (this.dayOfMonth.input)\r\n            out.dayOfMonth = this.dayOfMonth.input;\r\n        if (this.lastDayOfMonth.input)\r\n            out.lastDayOfMonth = this.lastDayOfMonth.input;\r\n        if (this.dayOfYear.input)\r\n            out.dayOfYear = this.dayOfYear.input;\r\n        if (this.year.input)\r\n            out.year = this.year.input;\r\n        if (this.month.input)\r\n            out.month = this.month.input;\r\n        if (this.week.input)\r\n            out.week = this.week.input;\r\n        if (this.weekOfYear.input)\r\n            out.weekOfYear = this.weekOfYear.input;\r\n        if (this.weekspanOfYear.input)\r\n            out.weekspanOfYear = this.weekspanOfYear.input;\r\n        if (this.fullWeekOfYear.input)\r\n            out.fullWeekOfYear = this.fullWeekOfYear.input;\r\n        if (this.lastWeekspanOfYear.input)\r\n            out.lastWeekspanOfYear = this.lastWeekspanOfYear.input;\r\n        if (this.lastFullWeekOfYear.input)\r\n            out.lastFullWeekOfYear = this.lastFullWeekOfYear.input;\r\n        if (this.weekOfMonth.input)\r\n            out.weekOfMonth = this.weekOfMonth.input;\r\n        if (this.weekspanOfMonth.input)\r\n            out.weekspanOfMonth = this.weekspanOfMonth.input;\r\n        if (this.fullWeekOfMonth.input)\r\n            out.fullWeekOfMonth = this.fullWeekOfMonth.input;\r\n        if (this.lastWeekspanOfMonth.input)\r\n            out.lastWeekspanOfMonth = this.lastWeekspanOfMonth.input;\r\n        if (this.lastFullWeekOfMonth.input)\r\n            out.lastFullWeekOfMonth = this.lastFullWeekOfMonth.input;\r\n        return out;\r\n    };\r\n    /**\r\n     * Describes the schedule in a human friendly string taking into account all\r\n     * possible values specified in this schedule.\r\n     *\r\n     * @param thing A brief description of the things (events) on the schedule.\r\n     * @param includeRange When `true` the [[Schedule.start]] and [[Schedule.end]]\r\n     *    are possibly included in the description if they have values.\r\n     * @param includeTimes When `true` the [[Schedule.times]] are possibly included\r\n     *    in the description.\r\n     * @param includeDuration When `true` the [[Schedule.duration]] and\r\n     *    [[Schedule.durationUnit]] are added to the description if\r\n     *    [[Schedule.duration]] is not equal to `1`.\r\n     * @param includeExcludes When `true` the [[Schedule.exclude]] are added\r\n     *    to the description if there are any.\r\n     * @param includeIncludes When `true` the [[Schedule.include]] are added\r\n     *    to the description if there are any.\r\n     * @param includeCancels When `true` the [[Schedule.cancel]] are added\r\n     *    to the description if there are any.\r\n     * @returns The descroption of the schedule.\r\n     */\r\n    Schedule.prototype.describe = function (thing, includeRange, includeTimes, includeDuration, includeExcludes, includeIncludes, includeCancels) {\r\n        if (thing === void 0) { thing = 'event'; }\r\n        if (includeRange === void 0) { includeRange = true; }\r\n        if (includeTimes === void 0) { includeTimes = true; }\r\n        if (includeDuration === void 0) { includeDuration = false; }\r\n        if (includeExcludes === void 0) { includeExcludes = false; }\r\n        if (includeIncludes === void 0) { includeIncludes = false; }\r\n        if (includeCancels === void 0) { includeCancels = false; }\r\n        var out = '';\r\n        if (includeRange) {\r\n            if (this.start) {\r\n                out += 'Starting on ' + this.start.format('dddd Do, YYYY');\r\n                if (this.end) {\r\n                    out += ' and ending on ' + this.end.format('dddd Do, YYYY');\r\n                }\r\n            }\r\n            else if (this.end) {\r\n                out += 'Up until ' + this.end.format('dddd Do, YYYY');\r\n            }\r\n        }\r\n        if (out) {\r\n            out += ' the ' + thing + ' will occur';\r\n        }\r\n        else {\r\n            out += 'The ' + thing + ' will occur';\r\n        }\r\n        out += this.describeRule(this.dayOfWeek.input, 'day of the week', function (x) { return __WEBPACK_IMPORTED_MODULE_10_moment__[\"weekdays\"]()[x]; }, 1, false);\r\n        out += this.describeRule(this.lastDayOfMonth.input, 'last day of the month', function (x) { return Suffix.CACHE[x]; });\r\n        out += this.describeRule(this.dayOfMonth.input, 'day of the month', function (x) { return Suffix.CACHE[x]; });\r\n        out += this.describeRule(this.dayOfYear.input, 'day of the year', function (x) { return Suffix.CACHE[x]; }, 1);\r\n        out += this.describeRule(this.year.input, 'year', function (x) { return x; }, 0, false, ' in ');\r\n        out += this.describeRule(this.month.input, 'month', function (x) { return __WEBPACK_IMPORTED_MODULE_10_moment__[\"months\"]()[x]; }, 0, false, ' in ');\r\n        out += this.describeRule(this.weekOfYear.input, 'week of the year', function (x) { return Suffix.CACHE[x]; });\r\n        out += this.describeRule(this.weekspanOfYear.input, 'weekspan of the year', function (x) { return Suffix.CACHE[x + 1]; }, 1);\r\n        out += this.describeRule(this.fullWeekOfYear.input, 'full week of the year', function (x) { return Suffix.CACHE[x]; });\r\n        out += this.describeRule(this.lastWeekspanOfYear.input, 'last weekspan of the year', function (x) { return Suffix.CACHE[x + 1]; }, 1);\r\n        out += this.describeRule(this.lastFullWeekOfYear.input, 'last full week of the year', function (x) { return Suffix.CACHE[x]; });\r\n        out += this.describeRule(this.weekOfMonth.input, 'week of the month', function (x) { return Suffix.CACHE[x]; });\r\n        out += this.describeRule(this.fullWeekOfMonth.input, 'full week of the month', function (x) { return Suffix.CACHE[x]; });\r\n        out += this.describeRule(this.weekspanOfMonth.input, 'weekspan of the month', function (x) { return Suffix.CACHE[x + 1]; }, 1);\r\n        out += this.describeRule(this.lastFullWeekOfMonth.input, 'last full week of the month', function (x) { return Suffix.CACHE[x]; });\r\n        out += this.describeRule(this.lastWeekspanOfMonth.input, 'last weekspan of the month', function (x) { return Suffix.CACHE[x + 1]; }, 1);\r\n        if (includeTimes && this.times.length) {\r\n            out += ' at ';\r\n            out += this.describeArray(this.times, function (x) { return x.format('hh:mm a'); });\r\n        }\r\n        if (includeDuration && this.duration !== Constants.DURATION_DEFAULT) {\r\n            out += ' lasting ' + this.duration + ' ';\r\n            if (this.durationUnit) {\r\n                out += this.durationUnit + ' ';\r\n            }\r\n        }\r\n        if (includeExcludes) {\r\n            var excludes = this.exclude.spans().list();\r\n            if (excludes.length) {\r\n                out += ' excluding ';\r\n                out += this.describeArray(excludes, function (x) { return x.span.summary(Units.DAY); });\r\n            }\r\n        }\r\n        if (includeIncludes) {\r\n            var includes = this.include.spans().list();\r\n            if (includes.length) {\r\n                out += ' including ';\r\n                out += this.describeArray(includes, function (x) { return x.span.summary(Units.DAY); });\r\n            }\r\n        }\r\n        if (includeCancels) {\r\n            var cancels = this.cancel.spans().list();\r\n            if (cancels.length) {\r\n                out += ' with cancellations on ';\r\n                out += this.describeArray(cancels, function (x) { return x.span.summary(Units.DAY); });\r\n            }\r\n        }\r\n        return out;\r\n    };\r\n    /**\r\n     * Describes the given frequency.\r\n     *\r\n     * @param value The frequency to describe.\r\n     * @param unit The unit of the frequency.\r\n     * @param map How the values in the frequency should be described.\r\n     * @param everyOffset A value to add to a [[FrequencyValueEvery]] offset to\r\n     *    account for zero-based values that should be shifted for human\r\n     *    friendliness.\r\n     * @param the If the word 'the' should be used to describe the unit.\r\n     * @param on The word which preceeds values of the given unit.\r\n     * @param required If the description should always return a non-empty string\r\n     *    even if the frequency was not specified in the original input.\r\n     * @returns A string description of the frequency.\r\n     */\r\n    Schedule.prototype.describeRule = function (value, unit, map, everyOffset, the, on, required) {\r\n        if (everyOffset === void 0) { everyOffset = 0; }\r\n        if (the === void 0) { the = true; }\r\n        if (on === void 0) { on = ' on '; }\r\n        if (required === void 0) { required = false; }\r\n        var out = '';\r\n        var suffix = the ? ' ' + unit : '';\r\n        if (Functions.isFrequencyValueEvery(value)) {\r\n            var valueEvery = value;\r\n            out += ' every ' + Suffix.CACHE[valueEvery.every] + ' ' + unit;\r\n            if (valueEvery.offset) {\r\n                out += ' starting at ' + map(valueEvery.offset + everyOffset) + suffix;\r\n            }\r\n        }\r\n        else if (Functions.isFrequencyValueOneOf(value)) {\r\n            var valueOne = value;\r\n            if (valueOne.length) {\r\n                out += on + (the ? 'the ' : '');\r\n                out += this.describeArray(valueOne, map);\r\n                out += suffix;\r\n            }\r\n        }\r\n        else if (required) {\r\n            out += on + 'any ' + unit;\r\n        }\r\n        return out;\r\n    };\r\n    /**\r\n     * Describes the array by adding commas where appropriate and 'and' before the\r\n     * last value of the array (if its more than `1`).\r\n     *\r\n     * @param array The array of items to describe.\r\n     * @param map The function which converts an item to a string.\r\n     * @returns The final description of the array items.\r\n     */\r\n    Schedule.prototype.describeArray = function (array, map) {\r\n        var out = '';\r\n        var last = array.length - 1;\r\n        out += map(array[0]);\r\n        for (var i = 1; i < last; i++) {\r\n            out += ', ' + map(array[i]);\r\n        }\r\n        if (last > 0) {\r\n            out += ' and ' + map(array[last]);\r\n        }\r\n        return out;\r\n    };\r\n    /**\r\n     * Generates a schedule for an event which occurs once all day for a given day\r\n     * optionally spanning multiple days starting on the given day.\r\n     *\r\n     * @param input The day the event starts.\r\n     * @param days The number of days the event lasts.\r\n     * @returns A new schedule that starts on the given day.\r\n     */\r\n    Schedule.forDay = function (input, days) {\r\n        if (days === void 0) { days = 1; }\r\n        var day = Day_Day.parse(input);\r\n        if (!day) {\r\n            return null;\r\n        }\r\n        return new Schedule({\r\n            year: [day.year],\r\n            month: [day.month],\r\n            dayOfMonth: [day.dayOfMonth],\r\n            duration: days,\r\n            durationUnit: 'days'\r\n        });\r\n    };\r\n    /**\r\n     * Generates a schedule for an event which occurs once at a given time on a\r\n     * given day optionally spanning any amount of time (default is 1 hour).\r\n     *\r\n     * @param input The day the event starts.\r\n     * @param time The time the event starts.\r\n     * @param duration The duration of the event.\r\n     * @param durationUnit The unit for the duration of the event.\r\n     * @returns A new schedule that starts on the given day and time.\r\n     */\r\n    Schedule.forTime = function (input, time, duration, durationUnit) {\r\n        if (duration === void 0) { duration = 1; }\r\n        if (durationUnit === void 0) { durationUnit = 'hours'; }\r\n        var day = Day_Day.parse(input);\r\n        if (!day) {\r\n            return null;\r\n        }\r\n        return new Schedule({\r\n            year: [day.year],\r\n            month: [day.month],\r\n            dayOfMonth: [day.dayOfMonth],\r\n            times: [time],\r\n            duration: duration,\r\n            durationUnit: durationUnit\r\n        });\r\n    };\r\n    /**\r\n     * Generates a schedule for an event which occurs once over a given span.\r\n     *\r\n     * @param span The span of the event.\r\n     * @returns A new schedule that starts and ends at the given timestamps.\r\n     */\r\n    Schedule.forSpan = function (span) {\r\n        var start = span.start;\r\n        var minutes = span.minutes();\r\n        var isDay = minutes % Constants.MINUTES_IN_DAY === 0;\r\n        var isHour = minutes % Constants.MINUTES_IN_HOUR === 0;\r\n        var duration = isDay ? minutes / Constants.MINUTES_IN_DAY : (isHour ? minutes / Constants.MINUTES_IN_HOUR : minutes);\r\n        var durationUnit = isDay ? 'days' : (isHour ? 'hours' : 'minutes');\r\n        return this.forTime(start, start.asTime(), duration, durationUnit);\r\n    };\r\n    return Schedule;\r\n}());\r\n\r\n\n// CONCATENATED MODULE: ./src/Event.ts\n\r\n/**\r\n * A pairing of a user specified event object and the schedule which defines\r\n * when it occurs on a calendar.\r\n *\r\n * @typeparam T The type of data stored in the [[Event]] class.\r\n * @typeparam M The type of metadata stored in the schedule.\r\n */\r\nvar Event = (function () {\r\n    /**\r\n     * Creates a new event.\r\n     *\r\n     * @param schedule The schedule which defines when the event occurs.\r\n     * @param data User specified object which describes this event.\r\n     * @param id User specified ID which identifies this event.\r\n     */\r\n    function Event(schedule, data, id, visible) {\r\n        if (visible === void 0) { visible = true; }\r\n        this.schedule = schedule;\r\n        this.data = data;\r\n        this.id = id;\r\n        this.visible = visible;\r\n    }\r\n    return Event;\r\n}());\r\n\r\n\n// CONCATENATED MODULE: ./src/Time.ts\n\r\n\r\n\r\n\r\n/**\r\n * A class which holds a specific time during in any day.\r\n */\r\nvar Time_Time = (function () {\r\n    /**\r\n     * Creates a new Time instance given an hour and optionally a minute, second,\r\n     * and millisecond. If they have not been specified they default to 0.\r\n     *\r\n     * @param hour The hour.\r\n     * @param minute The minute.\r\n     * @param second The second.\r\n     * @param millisecond The millisecond.\r\n     */\r\n    function Time(hour, minute, second, millisecond) {\r\n        if (minute === void 0) { minute = Constants.MINUTE_MIN; }\r\n        if (second === void 0) { second = Constants.SECOND_MIN; }\r\n        if (millisecond === void 0) { millisecond = Constants.MILLIS_MIN; }\r\n        this.hour = hour;\r\n        this.minute = minute;\r\n        this.second = second;\r\n        this.millisecond = millisecond;\r\n    }\r\n    /**\r\n     * Formats this time into a string. The following list describes the available\r\n     * formatting patterns:\r\n     *\r\n     * ### Hour\r\n     * - H: 0-23\r\n     * - HH: 00-23\r\n     * - h: 12,1-12,1-11\r\n     * - hh: 12,01-12,01-11\r\n     * - k: 1-24\r\n     * - kk: 01-24\r\n     * - a: am,pm\r\n     * - A: AM,PM\r\n     * ### Minute\r\n     * - m: 0-59\r\n     * - mm: 00-59\r\n     * ### Second\r\n     * - s: 0-59\r\n     * - ss: 00-59\r\n     * ### Millisecond\r\n     * - S: 0-9\r\n     * - SS: 00-99\r\n     * - SSS: 000-999\r\n     *\r\n     * @param format The format to output.\r\n     * @returns The formatted time.\r\n     */\r\n    Time.prototype.format = function (format) {\r\n        var formatterEntries = Time.FORMATTERS;\r\n        var out = '';\r\n        for (var i = 0; i < format.length; i++) {\r\n            var handled = false;\r\n            for (var k = 0; k < formatterEntries.length && !handled; k++) {\r\n                var entry = formatterEntries[k];\r\n                var part = format.substring(i, i + entry.size);\r\n                if (part.length === entry.size) {\r\n                    var formatter = entry.formats[part];\r\n                    if (formatter) {\r\n                        out += formatter(this);\r\n                        i += entry.size - 1;\r\n                        handled = true;\r\n                    }\r\n                }\r\n            }\r\n            if (!handled) {\r\n                out += format.charAt(i);\r\n            }\r\n        }\r\n        return out;\r\n    };\r\n    /**\r\n     * Determines whether this time is an exact match for the given time.\r\n     *\r\n     * @param time The given time to test against.\r\n     * @returns `true` if the time matches this time, otherwise `false`.\r\n     */\r\n    Time.prototype.matches = function (time) {\r\n        return this.hour === time.hour &&\r\n            this.minute === time.minute &&\r\n            this.second === time.second &&\r\n            this.millisecond === time.millisecond;\r\n    };\r\n    /**\r\n     * Determines whether this time has the same hour as the given time.\r\n     *\r\n     * @param time The given time to test against.\r\n     * @returns `true` if the given hour matches this hour, otherwise `false`.\r\n     */\r\n    Time.prototype.matchesHour = function (time) {\r\n        return this.hour === time.hour;\r\n    };\r\n    /**\r\n     * Determines whether this time has the same hour and minute as the given time.\r\n     *\r\n     * @param time The given time to test against.\r\n     * @returns `true` if the given hour and minute matches, otherwise `false`.\r\n     */\r\n    Time.prototype.matchesMinute = function (time) {\r\n        return this.hour === time.hour &&\r\n            this.minute === time.minute;\r\n    };\r\n    /**\r\n     * Determines whether this time has the same hour, minute, and second as the\r\n     * given time.\r\n     *\r\n     * @param time The given time to test against.\r\n     * @returns `true` if the given hour, minute, and second matches, otherwise\r\n     *    `false`.\r\n     */\r\n    Time.prototype.matchesSecond = function (time) {\r\n        return this.hour === time.hour &&\r\n            this.minute === time.minute &&\r\n            this.second === time.second;\r\n    };\r\n    /**\r\n     * Sets the time of this instance to the same time of the given input.\r\n     *\r\n     * @param input The time to set this to.\r\n     * @returns `true` if this time was set, otherwise `false` (invalid input).\r\n     */\r\n    Time.prototype.set = function (input) {\r\n        var parsed = Time.parse(input);\r\n        var valid = !!parsed;\r\n        if (valid) {\r\n            this.hour = parsed.hour;\r\n            this.minute = parsed.minute;\r\n            this.second = parsed.second;\r\n            this.millisecond = parsed.millisecond;\r\n        }\r\n        return valid;\r\n    };\r\n    /**\r\n     * @returns The number of milliseconds from the start of the day until this\r\n     *  time.\r\n     */\r\n    Time.prototype.toMilliseconds = function () {\r\n        return this.hour * Constants.MILLIS_IN_HOUR +\r\n            this.minute * Constants.MILLIS_IN_MINUTE +\r\n            this.second * Constants.MILLIS_IN_SECOND +\r\n            this.millisecond;\r\n    };\r\n    /**\r\n     * @returns The time formatted using the smallest format that completely\r\n     *  represents this time.\r\n     */\r\n    Time.prototype.toString = function () {\r\n        if (this.millisecond)\r\n            return this.format('HH:mm:ss.SSS');\r\n        if (this.second)\r\n            return this.format('HH:mm:ss');\r\n        if (this.minute)\r\n            return this.format('HH:mm');\r\n        return this.format('HH');\r\n    };\r\n    /**\r\n     * @returns A unique identifier for this time. The number returned is in the\r\n     *  following format: SSSssmmHH\r\n     */\r\n    Time.prototype.toIdentifier = function () {\r\n        return this.hour +\r\n            this.minute * 100 +\r\n            this.second * 10000 +\r\n            this.millisecond * 10000000;\r\n    };\r\n    /**\r\n     * @returns An object with hour, minute, second, a millisecond properties if\r\n     *  they are non-zero on this time.\r\n     */\r\n    Time.prototype.toObject = function () {\r\n        var out = {\r\n            hour: this.hour\r\n        };\r\n        if (this.minute)\r\n            out.minute = this.minute;\r\n        if (this.second)\r\n            out.second = this.second;\r\n        if (this.millisecond)\r\n            out.millisecond = this.millisecond;\r\n        return out;\r\n    };\r\n    /**\r\n     * Parses a value and tries to convert it to a Time instance.\r\n     *\r\n     * @param input The input to parse.\r\n     * @returns The instance parsed or `null` if it was invalid.\r\n     * @see [[Parse.time]]\r\n     */\r\n    Time.parse = function (input) {\r\n        return Parse_Parse.time(input);\r\n    };\r\n    /**\r\n     * Parses a string and converts it to a Time instance. If the string is not\r\n     * in a valid format `null` is returned.\r\n     *\r\n     * @param time The string to parse.\r\n     * @returns The instance parsed or `null` if it was invalid.\r\n     * @see [[Time.REGEX]]\r\n     */\r\n    Time.fromString = function (time) {\r\n        var matches = this.REGEX.exec(time);\r\n        if (!matches) {\r\n            return null;\r\n        }\r\n        var h = parseInt(matches[1]) || 0;\r\n        var m = parseInt(matches[2]) || 0;\r\n        var s = parseInt(matches[3]) || 0;\r\n        var l = parseInt(matches[4]) || 0;\r\n        return this.build(h, m, s, l);\r\n    };\r\n    /**\r\n     * Parses a number and converts it to a Time instance. The number is assumed\r\n     * to be in the [[Time.toIdentifier]] format.\r\n     *\r\n     * @param time The number to parse.\r\n     * @returns The instance parsed.\r\n     */\r\n    Time.fromIdentifier = function (time) {\r\n        var h = time % 100;\r\n        var m = Math.floor(time / 100) % 100;\r\n        var s = Math.floor(time / 10000) % 100;\r\n        var l = Math.floor(time / 10000000) % 1000;\r\n        return this.build(h, m, s, l);\r\n    };\r\n    /**\r\n     * Returns a new instance given an hour and optionally a minute, second,\r\n     * and millisecond. If they have not been specified they default to 0.\r\n     *\r\n     * @param hour The hour.\r\n     * @param minute The minute.\r\n     * @param second The second.\r\n     * @param millisecond The millisecond.\r\n     * @returns A new instance.\r\n     */\r\n    Time.build = function (hour, minute, second, millisecond) {\r\n        if (minute === void 0) { minute = Constants.MINUTE_MIN; }\r\n        if (second === void 0) { second = Constants.SECOND_MIN; }\r\n        if (millisecond === void 0) { millisecond = Constants.MILLIS_MIN; }\r\n        return new Time(hour, minute, second, millisecond);\r\n    };\r\n    /**\r\n     * The regular expression used to parse a time from a string.\r\n     *\r\n     * - ## = hour\r\n     * - ##:## = hour & minute\r\n     * - ##:##:## = hour, minute, & second\r\n     * - ##:##:##.### = hour, minute, second, and milliseconds\r\n     */\r\n    Time.REGEX = /^(\\d\\d?):?(\\d\\d)?:?(\\d\\d)?\\.?(\\d\\d\\d)?$/;\r\n    /**\r\n     * A set of formatting functions keyed by their format string.\r\n     */\r\n    Time.FORMATTERS = [\r\n        {\r\n            size: 3,\r\n            formats: {\r\n                SSS: function (t) { return Functions.padNumber(t.millisecond, 3); }\r\n            }\r\n        },\r\n        {\r\n            size: 2,\r\n            formats: {\r\n                HH: function (t) { return Functions.padNumber(t.hour, 2); },\r\n                hh: function (t) { return Functions.padNumber((t.hour % 12) || 12, 2); },\r\n                kk: function (t) { return Functions.padNumber(t.hour + 1, 2); },\r\n                mm: function (t) { return Functions.padNumber(t.minute, 2); },\r\n                ss: function (t) { return Functions.padNumber(t.second, 2); },\r\n                SS: function (t) { return Functions.padNumber(t.millisecond, 3, 2); }\r\n            }\r\n        },\r\n        {\r\n            size: 1,\r\n            formats: {\r\n                A: function (t) { return t.hour < 12 ? 'AM' : 'PM'; },\r\n                a: function (t) { return t.hour < 12 ? 'am' : 'pm'; },\r\n                H: function (t) { return t.hour + ''; },\r\n                h: function (t) { return ((t.hour % 12) || 12) + ''; },\r\n                k: function (t) { return (t.hour + 1) + ''; },\r\n                m: function (t) { return t.minute + ''; },\r\n                s: function (t) { return t.second + ''; },\r\n                S: function (t) { return Functions.padNumber(t.millisecond, 3, 1); }\r\n            }\r\n        }\r\n    ];\r\n    return Time;\r\n}());\r\n\r\n\n// CONCATENATED MODULE: ./src/Parse.ts\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * The class which takes user input and parses it to specific structures.\r\n */\r\nvar Parse_Parse = (function () {\r\n    function Parse() {\r\n    }\r\n    /**\r\n     * Parses a value and converts it to a [[FrequencyCheck]].\r\n     *\r\n     * @param input The input to parse into a function.\r\n     * @param property The [[Day]] property the frequency is for.\r\n     * @returns A function which determines whether a value matches a frequency.\r\n     * @see [[Schedule]]\r\n     */\r\n    Parse.frequency = function (input, property) {\r\n        var check = function (value) {\r\n            return true;\r\n        };\r\n        check.given = false;\r\n        if (Functions.isFrequencyValueEvery(input)) {\r\n            var every_1 = input.every;\r\n            var offset_1 = (input.offset || 0) % every_1;\r\n            check = function (value) {\r\n                return value % every_1 === offset_1;\r\n            };\r\n            check.given = true;\r\n        }\r\n        if (Functions.isFrequencyValueOneOf(input)) {\r\n            var map_1 = {};\r\n            for (var i = 0; i < input.length; i++) {\r\n                map_1[input[i]] = true;\r\n            }\r\n            check = function (value) {\r\n                return !!map_1[value];\r\n            };\r\n            check.given = true;\r\n        }\r\n        check.input = Functions.coalesce(input, null);\r\n        check.property = property;\r\n        return check;\r\n    };\r\n    /**\r\n     * Parses [[DayInput]] into a [[Day]] instance.\r\n     *\r\n     * ```typescript\r\n     * Parse.day( 65342300 );               // UTC timestamp\r\n     * Parse.day( '01/02/2014' );           // strings in many formats\r\n     * Parse.day( day );                    // return a passed instance\r\n     * Parse.day( [2018, 0, 2] );           // array: 01/02/2018\r\n     * Parse.day( {year: 2018, month: 2} ); // object: 03/01/2018\r\n     * Parse.day( true );                   // today\r\n     * ```\r\n     *\r\n     * @param input The input to parse.\r\n     * @returns The Day parsed or `null` if the value is not valid.\r\n     */\r\n    Parse.day = function (input) {\r\n        if (Functions.isNumber(input)) {\r\n            return Day_Day.unix(input);\r\n        }\r\n        else if (Functions.isString(input)) {\r\n            return Day_Day.fromString(input);\r\n        }\r\n        else if (input instanceof Day_Day) {\r\n            return input;\r\n        }\r\n        else if (Functions.isArray(input)) {\r\n            return Day_Day.fromArray(input);\r\n        }\r\n        else if (Functions.isObject(input)) {\r\n            return Day_Day.fromObject(input);\r\n        }\r\n        else if (input === true) {\r\n            return Day_Day.today();\r\n        }\r\n        return null;\r\n    };\r\n    /**\r\n     * Parses a value and tries to convert it to a Time instance.\r\n     *\r\n     * ```typescript\r\n     * Parse.time( time );      // return a passed instance\r\n     * Parse.time( 9 );         // 09:00:00.000\r\n     * Parse.time( 3009 );      // 09:30:00.000\r\n     * Parse.time( 593009 );    // 09:30:59.000\r\n     * Parsetime( '09' );       // 09:00:00.000\r\n     * Parse.time( '9:30' );    // 09:30:00.000\r\n     * Parse.time( '9:30:59' ); // 09:30:59.000\r\n     * Parse.time( {hour: 2} ); // 02:00:00.000\r\n     * ```\r\n     *\r\n     * @param input The input to parse.\r\n     * @returns The instance parsed or `null` if it was invalid.\r\n     * @see [[Time.fromIdentifier]]\r\n     * @see [[Time.fromString]]\r\n     */\r\n    Parse.time = function (input) {\r\n        if (input instanceof Time_Time) {\r\n            return input;\r\n        }\r\n        if (Functions.isNumber(input)) {\r\n            return Time_Time.fromIdentifier(input);\r\n        }\r\n        if (Functions.isString(input)) {\r\n            return Time_Time.fromString(input);\r\n        }\r\n        if (Functions.isObject(input) && Functions.isNumber(input.hour)) {\r\n            return new Time_Time(input.hour, input.minute, input.second, input.millisecond);\r\n        }\r\n        return null;\r\n    };\r\n    /**\r\n     * Parses a value and tries to convert it to an array of Time instances.\r\n     * If any of the given values are not a valid time value then the resulting\r\n     * array will not contain a time instance.\r\n     *\r\n     * @param input The input to parse.\r\n     * @returns A non-null array of time instances.\r\n     * @see [[Parse.time]]\r\n     */\r\n    Parse.times = function (input) {\r\n        var times = [];\r\n        if (Functions.isArray(input)) {\r\n            for (var _i = 0, input_1 = input; _i < input_1.length; _i++) {\r\n                var timeInput = input_1[_i];\r\n                var time = this.time(timeInput);\r\n                if (time) {\r\n                    times.push(time);\r\n                }\r\n            }\r\n            // Sort times from earliest to latest.\r\n            times.sort(function (a, b) {\r\n                return a.toMilliseconds() - b.toMilliseconds();\r\n            });\r\n        }\r\n        return times;\r\n    };\r\n    /**\r\n     * Parses an array of excluded days into a map of excluded days where the\r\n     * array value and returned object key are [[Day.dayIdentifier]].\r\n     *\r\n     * ```typescript\r\n     * Parse.modifier( [ 20180101, 20140506 ] );            // {'20180101': true, '20140506': true}\r\n     * Parse.modifier( [ 20180101, Day.build(2014,4,6) ] ); // {'20180101': true, '20140506': true}\r\n     * ```\r\n     *\r\n     * @param input The input to parse.\r\n     * @param value The default value if the input given is an array of identifiers.\r\n     * @param parseMeta A function to use to parse a modifier.\r\n     * @param out The modifier to set the identifiers and values of and return.\r\n     * @returns The object with identifier keys and `true` values.\r\n     * @see [[Day.dayIdentifier]]\r\n     */\r\n    Parse.modifier = function (input, value, parseMeta, out) {\r\n        if (parseMeta === void 0) { parseMeta = (function (x) { return x; }); }\r\n        if (out === void 0) { out = new ScheduleModifier_ScheduleModifier(); }\r\n        var map = {};\r\n        if (Functions.isArray(input)) {\r\n            for (var _i = 0, input_2 = input; _i < input_2.length; _i++) {\r\n                var identifier = input_2[_i];\r\n                if (identifier instanceof Day_Day) {\r\n                    map[identifier.dayIdentifier] = value;\r\n                }\r\n                else if (Functions.isNumber(identifier)) {\r\n                    map[identifier] = value;\r\n                }\r\n                else if (Functions.isString(identifier)) {\r\n                    map[identifier] = value;\r\n                }\r\n            }\r\n        }\r\n        if (Functions.isObject(input)) {\r\n            for (var identifier in input) {\r\n                map[identifier] = parseMeta(input[identifier]);\r\n            }\r\n        }\r\n        out.map = map;\r\n        return out;\r\n    };\r\n    /**\r\n     * Parses an object which specifies a schedule where events may or may not\r\n     * repeat and they may be all day events or at specific times.\r\n     *\r\n     * @param input The input to parse into a schedule.\r\n     * @param parseMeta A function to use when parsing meta input into the desired type.\r\n     * @param out The schedule to set the values of and return.\r\n     * @returns An instance of the parsed [[Schedule]].\r\n     */\r\n    Parse.schedule = function (input, parseMeta, out) {\r\n        if (parseMeta === void 0) { parseMeta = (function (x) { return x; }); }\r\n        if (out === void 0) { out = new Schedule_Schedule(); }\r\n        if (input instanceof Schedule_Schedule) {\r\n            return input;\r\n        }\r\n        var on = this.day(input.on);\r\n        var times = this.times(input.times);\r\n        var fullDay = times.length === 0;\r\n        if (on) {\r\n            input.start = on.start();\r\n            input.end = on.end();\r\n            input.year = [on.year];\r\n            input.month = [on.month];\r\n            input.dayOfMonth = [on.dayOfMonth];\r\n        }\r\n        out.times = times;\r\n        out.duration = Functions.coalesce(input.duration, Constants.DURATION_DEFAULT);\r\n        out.durationUnit = Functions.coalesce(input.durationUnit, Constants.DURATION_DEFAULT_UNIT(fullDay));\r\n        out.start = this.day(input.start);\r\n        out.end = this.day(input.end);\r\n        out.exclude = this.modifier(input.exclude, true, undefined, out.exclude);\r\n        out.include = this.modifier(input.include, true, undefined, out.include);\r\n        out.cancel = this.modifier(input.cancel, true, undefined, out.cancel);\r\n        out.meta = this.modifier(input.meta, null, parseMeta, out.meta);\r\n        out.year = this.frequency(input.year, 'year');\r\n        out.month = this.frequency(input.month, 'month');\r\n        out.week = this.frequency(input.week, 'week');\r\n        out.weekOfYear = this.frequency(input.weekOfYear, 'weekOfYear');\r\n        out.weekspanOfYear = this.frequency(input.weekspanOfYear, 'weekspanOfYear');\r\n        out.fullWeekOfYear = this.frequency(input.fullWeekOfYear, 'fullWeekOfYear');\r\n        out.lastWeekspanOfYear = this.frequency(input.lastWeekspanOfYear, 'lastWeekspanOfYear');\r\n        out.lastFullWeekOfYear = this.frequency(input.lastFullWeekOfYear, 'lastFullWeekOfYear');\r\n        out.weekOfMonth = this.frequency(input.weekOfMonth, 'weekOfMonth');\r\n        out.weekspanOfMonth = this.frequency(input.weekspanOfMonth, 'weekspanOfMonth');\r\n        out.fullWeekOfMonth = this.frequency(input.fullWeekOfMonth, 'fullWeekOfMonth');\r\n        out.lastWeekspanOfMonth = this.frequency(input.lastWeekspanOfMonth, 'lastWeekspanOfMonth');\r\n        out.lastFullWeekOfMonth = this.frequency(input.lastFullWeekOfMonth, 'lastFullWeekOfMonth');\r\n        out.dayOfWeek = this.frequency(input.dayOfWeek, 'dayOfWeek');\r\n        out.dayOfMonth = this.frequency(input.dayOfMonth, 'dayOfMonth');\r\n        out.lastDayOfMonth = this.frequency(input.lastDayOfMonth, 'lastDayOfMonth');\r\n        out.dayOfYear = this.frequency(input.dayOfYear, 'dayOfYear');\r\n        out.updateDurationInDays();\r\n        out.updateChecks();\r\n        return out;\r\n    };\r\n    /**\r\n     * Parses an array of [[FrequencyCheck]] functions and returns an array of\r\n     * functions for only the checks that were specified by the user.\r\n     *\r\n     * @param checks The array of check functions to filter through.\r\n     * @returns The array of user specified checks.\r\n     */\r\n    Parse.givenFrequency = function (checks) {\r\n        var out = [];\r\n        for (var _i = 0, checks_1 = checks; _i < checks_1.length; _i++) {\r\n            var check = checks_1[_i];\r\n            if (check.given) {\r\n                out.push(check);\r\n            }\r\n        }\r\n        return out;\r\n    };\r\n    /**\r\n     * Parses [[EventInput]] and returns an [[Event]].\r\n     *\r\n     * @param input The input to parse.\r\n     * @param parseData A function to use when parsing data input into the desired type.\r\n     * @param parseMeta A function to use when parsing meta input into the desired type.\r\n     * @returns The parsed value.\r\n     */\r\n    Parse.event = function (input, parseData, parseMeta) {\r\n        if (parseData === void 0) { parseData = (function (x) { return x; }); }\r\n        if (parseMeta === void 0) { parseMeta = (function (x) { return x; }); }\r\n        if (input instanceof Event) {\r\n            return input;\r\n        }\r\n        if (!input.schedule) {\r\n            return null;\r\n        }\r\n        var schedule = this.schedule(input.schedule, parseMeta);\r\n        return new Event(schedule, parseData(input.data), input.id, input.visible);\r\n    };\r\n    /**\r\n     * Parses a schedule from a CRON pattern. TODO\r\n     */\r\n    Parse.cron = function (pattern, out) {\r\n        if (out === void 0) { out = new Schedule_Schedule(); }\r\n        return out;\r\n    };\r\n    return Parse;\r\n}());\r\n\r\n\n// CONCATENATED MODULE: ./src/Day.ts\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_moment__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_moment__);\n\r\n\r\n\r\n\r\n\r\n\r\n// @ts-ignore\r\n\r\n/**\r\n * A class which represents a point in time as\r\n */\r\nvar Day_Day = (function () {\r\n    /**\r\n     *\r\n     */\r\n    function Day(date) {\r\n        this.date = date;\r\n        this.time = date.valueOf();\r\n        this.millis = date.millisecond();\r\n        this.seconds = date.second();\r\n        this.minute = date.minute();\r\n        this.hour = date.hour();\r\n        this.month = date.month();\r\n        this.year = date.year();\r\n        this.quarter = date.quarter();\r\n        this.dayOfWeek = date.day();\r\n        this.dayOfMonth = date.date();\r\n        this.dayOfYear = date.dayOfYear();\r\n        this.week = date.week();\r\n        this.lastDayOfMonth = Day.getLastDayOfMonth(date);\r\n        this.weekOfYear = Day.getWeekOfYear(date);\r\n        this.weekspanOfYear = Day.getWeekspanOfYear(date);\r\n        this.fullWeekOfYear = Day.getFullWeekOfYear(date);\r\n        this.lastWeekspanOfYear = Day.getLastWeekspanOfYear(date);\r\n        this.lastFullWeekOfYear = Day.getLastFullWeekOfYear(date);\r\n        this.weekOfMonth = Day.getWeekOfMonth(date);\r\n        this.weekspanOfMonth = Day.getWeekspanOfMonth(date);\r\n        this.fullWeekOfMonth = Day.getFullWeekOfMonth(date);\r\n        this.lastWeekspanOfMonth = Day.getLastWeekspanOfMonth(date);\r\n        this.lastFullWeekOfMonth = Day.getLastFullWeekOfMonth(date);\r\n        this.timeIdentifier = Identifier_Identifier.Time.get(this);\r\n        this.dayIdentifier = Identifier_Identifier.Day.get(this);\r\n        this.weekIdentifier = Identifier_Identifier.Week.get(this);\r\n        this.monthIdentifier = Identifier_Identifier.Month.get(this);\r\n        this.quarterIdentifier = Identifier_Identifier.Quarter.get(this);\r\n    }\r\n    // Same\r\n    /**\r\n     *\r\n     */\r\n    Day.prototype.sameDay = function (day) {\r\n        return this.dayIdentifier === day.dayIdentifier;\r\n    };\r\n    /**\r\n     *\r\n     */\r\n    Day.prototype.sameMonth = function (day) {\r\n        return this.monthIdentifier === day.monthIdentifier;\r\n    };\r\n    /**\r\n     *\r\n     */\r\n    Day.prototype.sameWeek = function (day) {\r\n        return this.weekIdentifier === day.weekIdentifier;\r\n    };\r\n    /**\r\n     *\r\n     */\r\n    Day.prototype.sameYear = function (day) {\r\n        return this.year === day.year;\r\n    };\r\n    /**\r\n     *\r\n     */\r\n    Day.prototype.sameQuarter = function (day) {\r\n        return this.quarterIdentifier === day.quarterIdentifier;\r\n    };\r\n    /**\r\n     *\r\n     */\r\n    Day.prototype.sameHour = function (day) {\r\n        return this.dayIdentifier === day.dayIdentifier && this.hour === day.hour;\r\n    };\r\n    /**\r\n     *\r\n     */\r\n    Day.prototype.sameMinute = function (day) {\r\n        return this.timeIdentifier === day.timeIdentifier;\r\n    };\r\n    /**\r\n     *\r\n     */\r\n    Day.prototype.sameTime = function (time) {\r\n        return this.hour === time.hour && this.minute === time.minute && this.seconds === time.second && this.millis === time.millisecond;\r\n    };\r\n    // Comparison\r\n    /**\r\n     *\r\n     */\r\n    Day.prototype.isBefore = function (day, precision) {\r\n        return this.date.isBefore(day.date, precision);\r\n    };\r\n    /**\r\n     *\r\n     */\r\n    Day.prototype.isSameOrBefore = function (day, precision) {\r\n        return this.date.isSameOrBefore(day.date, precision);\r\n    };\r\n    /**\r\n     *\r\n     */\r\n    Day.prototype.isAfter = function (day, precision) {\r\n        return this.date.isAfter(day.date, precision);\r\n    };\r\n    /**\r\n     *\r\n     */\r\n    Day.prototype.isSameOrAfter = function (day, precision) {\r\n        return this.date.isSameOrAfter(day.date, precision);\r\n    };\r\n    /**\r\n     *\r\n     */\r\n    Day.prototype.max = function (day) {\r\n        return this.date.isAfter(day.date) ? this : day;\r\n    };\r\n    /**\r\n     *\r\n     */\r\n    Day.prototype.min = function (day) {\r\n        return this.date.isBefore(day.date) ? this : day;\r\n    };\r\n    // Between\r\n    Day.prototype.millisBetween = function (day, op, absolute) {\r\n        if (op === void 0) { op = Op.DOWN; }\r\n        if (absolute === void 0) { absolute = true; }\r\n        return operate(this.date.diff(day.date, 'milliseconds', true), op, absolute);\r\n    };\r\n    Day.prototype.secondsBetween = function (day, op, absolute) {\r\n        if (op === void 0) { op = Op.DOWN; }\r\n        if (absolute === void 0) { absolute = true; }\r\n        return operate(this.date.diff(day.date, 'seconds', true), op, absolute);\r\n    };\r\n    Day.prototype.minutesBetween = function (day, op, absolute) {\r\n        if (op === void 0) { op = Op.DOWN; }\r\n        if (absolute === void 0) { absolute = true; }\r\n        return operate(this.date.diff(day.date, 'minutes', true), op, absolute);\r\n    };\r\n    Day.prototype.hoursBetween = function (day, op, absolute) {\r\n        if (op === void 0) { op = Op.DOWN; }\r\n        if (absolute === void 0) { absolute = true; }\r\n        return operate(this.date.diff(day.date, 'hours', true), op, absolute);\r\n    };\r\n    Day.prototype.daysBetween = function (day, op, absolute) {\r\n        if (op === void 0) { op = Op.DOWN; }\r\n        if (absolute === void 0) { absolute = true; }\r\n        return operate(this.date.diff(day.date, 'days', true), op, absolute);\r\n    };\r\n    Day.prototype.weeksBetween = function (day, op, absolute) {\r\n        if (op === void 0) { op = Op.DOWN; }\r\n        if (absolute === void 0) { absolute = true; }\r\n        return operate(this.date.diff(day.date, 'weeks', true), op, absolute);\r\n    };\r\n    Day.prototype.monthsBetween = function (day, op, absolute) {\r\n        if (op === void 0) { op = Op.DOWN; }\r\n        if (absolute === void 0) { absolute = true; }\r\n        return operate(this.date.diff(day.date, 'months', true), op, absolute);\r\n    };\r\n    Day.prototype.yearsBetween = function (day, op, absolute) {\r\n        if (op === void 0) { op = Op.DOWN; }\r\n        if (absolute === void 0) { absolute = true; }\r\n        return operate(this.date.diff(day.date, 'years', true), op, absolute);\r\n    };\r\n    Day.prototype.isBetween = function (start, end, inclusive) {\r\n        if (inclusive === void 0) { inclusive = true; }\r\n        return this.date.isBetween(start.date, end.date, null, inclusive ? '[]' : '[)');\r\n    };\r\n    Day.prototype.mutate = function (mutator) {\r\n        var d = this.toMoment();\r\n        mutator(d);\r\n        return new Day(d);\r\n    };\r\n    Day.prototype.add = function (amount, unit) {\r\n        return this.mutate(function (d) { return d.add(amount, unit); });\r\n    };\r\n    Day.prototype.relative = function (millis) {\r\n        return this.mutate(function (d) { return d.add(millis, 'milliseconds'); });\r\n    };\r\n    // Days\r\n    Day.prototype.relativeDays = function (days) {\r\n        return this.mutate(function (d) { return d.add(days, 'days'); });\r\n    };\r\n    Day.prototype.prev = function (days) {\r\n        if (days === void 0) { days = 1; }\r\n        return this.relativeDays(-days);\r\n    };\r\n    Day.prototype.next = function (days) {\r\n        if (days === void 0) { days = 1; }\r\n        return this.relativeDays(days);\r\n    };\r\n    Day.prototype.withDayOfMonth = function (day) {\r\n        return this.mutate(function (d) { return d.date(day); });\r\n    };\r\n    Day.prototype.withDayOfWeek = function (dayOfWeek) {\r\n        return this.mutate(function (d) { return d.day(dayOfWeek); });\r\n    };\r\n    Day.prototype.withDayOfYear = function (dayOfYear) {\r\n        return this.mutate(function (d) { return d.dayOfYear(dayOfYear); });\r\n    };\r\n    // Month\r\n    Day.prototype.withMonth = function (month) {\r\n        return this.mutate(function (d) { return d.month(month); });\r\n    };\r\n    Day.prototype.relativeMonths = function (months) {\r\n        return this.mutate(function (d) { return d.add(months, 'months'); });\r\n    };\r\n    Day.prototype.prevMonth = function (months) {\r\n        if (months === void 0) { months = 1; }\r\n        return this.relativeMonths(-months);\r\n    };\r\n    Day.prototype.nextMonth = function (months) {\r\n        if (months === void 0) { months = 1; }\r\n        return this.relativeMonths(months);\r\n    };\r\n    // Week Of Year\r\n    Day.prototype.withWeek = function (week, relativeWeek) {\r\n        if (relativeWeek === void 0) { relativeWeek = this.week; }\r\n        return this.mutate(function (d) { return d.add((week - relativeWeek) * Constants.DAYS_IN_WEEK, 'days'); });\r\n    };\r\n    Day.prototype.withWeekOfYear = function (week) {\r\n        return this.withWeek(week, this.weekOfYear);\r\n    };\r\n    Day.prototype.withFullWeekOfYear = function (week) {\r\n        return this.withWeek(week, this.fullWeekOfYear);\r\n    };\r\n    Day.prototype.withWeekspanOfYear = function (week) {\r\n        return this.withWeek(week, this.weekspanOfYear);\r\n    };\r\n    Day.prototype.withWeekOfMonth = function (week) {\r\n        return this.withWeek(week, this.weekOfMonth);\r\n    };\r\n    Day.prototype.withWeekspanOfMonth = function (week) {\r\n        return this.withWeek(week, this.weekspanOfMonth);\r\n    };\r\n    Day.prototype.withFullWeekOfMonth = function (week) {\r\n        return this.withWeek(week, this.fullWeekOfMonth);\r\n    };\r\n    Day.prototype.relativeWeeks = function (weeks) {\r\n        return this.mutate(function (d) { return d.add(weeks, 'weeks'); });\r\n    };\r\n    Day.prototype.prevWeek = function (weeks) {\r\n        if (weeks === void 0) { weeks = 1; }\r\n        return this.relativeWeeks(-weeks);\r\n    };\r\n    Day.prototype.nextWeek = function (weeks) {\r\n        if (weeks === void 0) { weeks = 1; }\r\n        return this.relativeWeeks(weeks);\r\n    };\r\n    // Year\r\n    Day.prototype.withYear = function (year) {\r\n        return this.mutate(function (d) { return d.year(year); });\r\n    };\r\n    Day.prototype.relativeYears = function (years) {\r\n        return this.mutate(function (d) { return d.add(years, 'year'); });\r\n    };\r\n    Day.prototype.prevYear = function (years) {\r\n        if (years === void 0) { years = 1; }\r\n        return this.relativeYears(-years);\r\n    };\r\n    Day.prototype.nextYear = function (years) {\r\n        if (years === void 0) { years = 1; }\r\n        return this.relativeYears(years);\r\n    };\r\n    // Hour\r\n    Day.prototype.withHour = function (hour) {\r\n        return this.mutate(function (d) { return d.hour(hour); });\r\n    };\r\n    Day.prototype.relativeHours = function (hours) {\r\n        return this.mutate(function (d) { return d.add(hours, 'hours'); });\r\n    };\r\n    Day.prototype.prevHour = function (hours) {\r\n        if (hours === void 0) { hours = 1; }\r\n        return this.relativeHours(-hours);\r\n    };\r\n    Day.prototype.nextHour = function (hours) {\r\n        if (hours === void 0) { hours = 1; }\r\n        return this.relativeHours(hours);\r\n    };\r\n    // Time\r\n    Day.prototype.withTimes = function (hour, minute, second, millisecond) {\r\n        if (hour === void 0) { hour = Constants.HOUR_MIN; }\r\n        if (minute === void 0) { minute = Constants.MINUTE_MIN; }\r\n        if (second === void 0) { second = Constants.SECOND_MIN; }\r\n        if (millisecond === void 0) { millisecond = Constants.MILLIS_MIN; }\r\n        return this.mutate(function (d) { return d.set({ hour: hour, minute: minute, second: second, millisecond: millisecond }); });\r\n    };\r\n    Day.prototype.withTime = function (time) {\r\n        return this.withTimes(time.hour, time.minute, time.second, time.millisecond);\r\n    };\r\n    Day.prototype.asTime = function () {\r\n        return new Time_Time(this.hour, this.minute, this.seconds, this.millis);\r\n    };\r\n    // Start & End\r\n    // Time\r\n    Day.prototype.start = function () {\r\n        return this.mutate(function (d) { return d.startOf('day'); });\r\n    };\r\n    Day.prototype.isStart = function () {\r\n        return this.hour === Constants.HOUR_MIN &&\r\n            this.minute === Constants.MINUTE_MIN &&\r\n            this.seconds === Constants.SECOND_MIN &&\r\n            this.millis === Constants.MILLIS_MIN;\r\n    };\r\n    Day.prototype.end = function (inclusive) {\r\n        if (inclusive === void 0) { inclusive = true; }\r\n        return inclusive ?\r\n            this.mutate(function (d) { return d.endOf('day'); }) :\r\n            this.mutate(function (d) { return d.startOf('day').add(1, 'day'); });\r\n    };\r\n    Day.prototype.isEnd = function () {\r\n        return this.hour === Constants.HOUR_MAX &&\r\n            this.minute === Constants.MINUTE_MAX &&\r\n            this.seconds === Constants.SECOND_MAX &&\r\n            this.millis === Constants.MILLIS_MAX;\r\n    };\r\n    // Hour\r\n    Day.prototype.startOfHour = function () {\r\n        return this.mutate(function (d) { return d.startOf('hour'); });\r\n    };\r\n    Day.prototype.isStartOfHour = function () {\r\n        return this.minute === Constants.MINUTE_MIN &&\r\n            this.seconds === Constants.SECOND_MIN &&\r\n            this.millis === Constants.MILLIS_MIN;\r\n    };\r\n    Day.prototype.endOfHour = function (inclusive) {\r\n        if (inclusive === void 0) { inclusive = true; }\r\n        return inclusive ?\r\n            this.mutate(function (d) { return d.endOf('hour'); }) :\r\n            this.mutate(function (d) { return d.startOf('hour').add(1, 'hour'); });\r\n    };\r\n    Day.prototype.isEndOfHour = function () {\r\n        return this.minute === Constants.MINUTE_MAX &&\r\n            this.seconds === Constants.SECOND_MAX &&\r\n            this.millis === Constants.MILLIS_MAX;\r\n    };\r\n    // Week\r\n    Day.prototype.startOfWeek = function () {\r\n        return this.mutate(function (d) { return d.startOf('week'); });\r\n    };\r\n    Day.prototype.isStartOfWeek = function () {\r\n        return this.dayOfWeek === Constants.WEEKDAY_MIN;\r\n    };\r\n    Day.prototype.endOfWeek = function (inclusive) {\r\n        if (inclusive === void 0) { inclusive = true; }\r\n        return inclusive ?\r\n            this.mutate(function (d) { return d.endOf('week'); }) :\r\n            this.mutate(function (d) { return d.startOf('week').add(1, 'week'); });\r\n    };\r\n    Day.prototype.isEndOfWeek = function () {\r\n        return this.dayOfWeek === Constants.WEEKDAY_MAX;\r\n    };\r\n    // Month\r\n    Day.prototype.startOfMonth = function () {\r\n        return this.mutate(function (d) { return d.startOf('month'); });\r\n    };\r\n    Day.prototype.isStartOfMonth = function () {\r\n        return this.dayOfMonth === Constants.DAY_MIN;\r\n    };\r\n    Day.prototype.endOfMonth = function (inclusive) {\r\n        if (inclusive === void 0) { inclusive = true; }\r\n        return inclusive ?\r\n            this.mutate(function (d) { return d.endOf('month'); }) :\r\n            this.mutate(function (d) { return d.startOf('month').add(1, 'month'); });\r\n    };\r\n    Day.prototype.isEndOfMonth = function () {\r\n        return this.dayOfMonth === this.daysInMonth();\r\n    };\r\n    // Year\r\n    Day.prototype.startOfYear = function () {\r\n        return this.mutate(function (d) { return d.startOf('year'); });\r\n    };\r\n    Day.prototype.isStartOfYear = function () {\r\n        return this.month === Constants.MONTH_MIN && this.dayOfMonth === Constants.DAY_MIN;\r\n    };\r\n    Day.prototype.endOfYear = function (inclusive) {\r\n        if (inclusive === void 0) { inclusive = true; }\r\n        return inclusive ?\r\n            this.mutate(function (d) { return d.endOf('year'); }) :\r\n            this.mutate(function (d) { return d.startOf('year').add(1, 'year'); });\r\n    };\r\n    Day.prototype.isEndOfYear = function () {\r\n        return this.month === Constants.MONTH_MAX && this.dayOfMonth === Constants.DAY_MAX;\r\n    };\r\n    // Days In X\r\n    Day.prototype.daysInMonth = function () {\r\n        return this.date.daysInMonth();\r\n    };\r\n    Day.prototype.daysInYear = function () {\r\n        return this.endOfYear().dayOfYear;\r\n    };\r\n    Day.prototype.weeksInYear = function () {\r\n        return this.date.weeksInYear();\r\n    };\r\n    // Display\r\n    Day.prototype.format = function (format) {\r\n        return this.date.format(format);\r\n    };\r\n    Day.prototype.utc = function (keepLocalTime) {\r\n        return this.mutate(function (d) { return d.utc(keepLocalTime); });\r\n    };\r\n    Day.prototype.toMoment = function () {\r\n        return this.date.clone();\r\n    };\r\n    Day.prototype.toDate = function () {\r\n        return this.date.toDate();\r\n    };\r\n    Day.prototype.toArray = function () {\r\n        return this.date.toArray();\r\n    };\r\n    Day.prototype.toJSON = function () {\r\n        return this.date.toJSON();\r\n    };\r\n    Day.prototype.toISOString = function (keepOffset) {\r\n        if (keepOffset === void 0) { keepOffset = false; }\r\n        return this.date.toISOString(keepOffset);\r\n    };\r\n    Day.prototype.toObject = function () {\r\n        return this.date.toObject();\r\n    };\r\n    Day.prototype.toString = function () {\r\n        return this.date.toString();\r\n    };\r\n    // State\r\n    Day.prototype.isDST = function () {\r\n        return this.date.isDST();\r\n    };\r\n    Day.prototype.isLeapYear = function () {\r\n        return this.date.isLeapYear();\r\n    };\r\n    // Instances\r\n    Day.now = function () {\r\n        return new Day(__WEBPACK_IMPORTED_MODULE_5_moment__());\r\n    };\r\n    Day.today = function () {\r\n        return this.now().start();\r\n    };\r\n    Day.tomorrow = function () {\r\n        return this.today().next();\r\n    };\r\n    Day.fromMoment = function (moment) {\r\n        return moment && moment.isValid() ? new Day(moment) : null;\r\n    };\r\n    Day.unix = function (millis) {\r\n        return this.fromMoment(__WEBPACK_IMPORTED_MODULE_5_moment__(millis));\r\n    };\r\n    Day.unixSeconds = function (millis) {\r\n        return this.fromMoment(__WEBPACK_IMPORTED_MODULE_5_moment__[\"unix\"](millis));\r\n    };\r\n    Day.parse = function (input) {\r\n        return Parse_Parse.day(input);\r\n    };\r\n    Day.fromString = function (input) {\r\n        return this.fromMoment(__WEBPACK_IMPORTED_MODULE_5_moment__(input));\r\n    };\r\n    Day.fromFormat = function (input, formats) {\r\n        return this.fromMoment(__WEBPACK_IMPORTED_MODULE_5_moment__(input, formats));\r\n    };\r\n    Day.fromObject = function (input) {\r\n        return this.fromMoment(__WEBPACK_IMPORTED_MODULE_5_moment__(input));\r\n    };\r\n    Day.fromDate = function (input) {\r\n        return this.fromMoment(__WEBPACK_IMPORTED_MODULE_5_moment__(input));\r\n    };\r\n    Day.fromArray = function (input) {\r\n        return this.fromMoment(__WEBPACK_IMPORTED_MODULE_5_moment__(input));\r\n    };\r\n    Day.fromDayIdentifier = function (id) {\r\n        var date = id % 100;\r\n        var month = (Math.floor(id / 100) % 100) - 1;\r\n        var year = Math.floor(id / 10000);\r\n        return this.build(year, month, date);\r\n    };\r\n    Day.build = function (year, month, date, hour, minute, second, millisecond) {\r\n        if (date === void 0) { date = Constants.DAY_MIN; }\r\n        if (hour === void 0) { hour = Constants.HOUR_MIN; }\r\n        if (minute === void 0) { minute = Constants.MINUTE_MIN; }\r\n        if (second === void 0) { second = Constants.SECOND_MIN; }\r\n        if (millisecond === void 0) { millisecond = Constants.MILLIS_MIN; }\r\n        return new Day(__WEBPACK_IMPORTED_MODULE_5_moment__({ year: year, month: month, date: date, hour: hour, minute: minute, second: second, millisecond: millisecond }));\r\n    };\r\n    Day.getWeekspanOfYear = function (date) {\r\n        return Math.floor((date.dayOfYear() - 1) / Constants.DAYS_IN_WEEK);\r\n    };\r\n    Day.getLastWeekspanOfYear = function (date) {\r\n        var lastOfYear = date.clone().endOf('year');\r\n        var daysInYear = lastOfYear.dayOfYear();\r\n        return Math.floor((daysInYear - date.dayOfYear()) / Constants.DAYS_IN_WEEK);\r\n    };\r\n    Day.getWeekOfYear = function (date) {\r\n        var firstOfYear = date.clone().startOf('year');\r\n        var weeks = date.week();\r\n        return firstOfYear.day() > Constants.WEEK_OF_MONTH_MINIMUM_WEEKDAY ? weeks - 1 : weeks;\r\n    };\r\n    Day.getFullWeekOfYear = function (date) {\r\n        var firstOfYear = date.clone().startOf('year');\r\n        var weeks = date.week();\r\n        return firstOfYear.day() === Constants.WEEKDAY_MIN ? weeks : weeks - 1;\r\n    };\r\n    Day.getLastFullWeekOfYear = function (date) {\r\n        var firstOfYear = date.clone().startOf('year');\r\n        var weeks = date.week();\r\n        var weeksMax = date.weeksInYear();\r\n        var lastWeek = weeksMax - weeks;\r\n        return firstOfYear.day() === Constants.WEEKDAY_MIN ? lastWeek + 1 : lastWeek;\r\n    };\r\n    Day.getWeekspanOfMonth = function (date) {\r\n        return Math.floor((date.date() - 1) / Constants.DAYS_IN_WEEK);\r\n    };\r\n    Day.getLastWeekspanOfMonth = function (date) {\r\n        return Math.floor((date.daysInMonth() - date.date()) / Constants.DAYS_IN_WEEK);\r\n    };\r\n    Day.getFullWeekOfMonth = function (date) {\r\n        return Math.floor((date.date() - 1 - date.day() + Constants.DAYS_IN_WEEK) / Constants.DAYS_IN_WEEK);\r\n    };\r\n    Day.getLastFullWeekOfMonth = function (date) {\r\n        return Math.floor((date.daysInMonth() - date.date() - (Constants.WEEKDAY_MAX - date.day()) + Constants.DAYS_IN_WEEK) / Constants.DAYS_IN_WEEK);\r\n    };\r\n    Day.getWeekOfMonth = function (date) {\r\n        var dom = date.date();\r\n        var dow = date.day();\r\n        var sundayDate = dom - dow;\r\n        return Math.floor((sundayDate + Constants.WEEK_OF_MONTH_MINIMUM_WEEKDAY + 5) / Constants.DAYS_IN_WEEK);\r\n    };\r\n    Day.getLastDayOfMonth = function (date) {\r\n        return date.daysInMonth() - date.date() + 1;\r\n    };\r\n    return Day;\r\n}());\r\n\r\n\n// CONCATENATED MODULE: ./src/CalendarDay.ts\n\r\nvar CalendarDay___extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\n\r\n\r\n\r\n/**\r\n * A day in a [[Calendar]] with extra information relative to any selection on\r\n * the calendar, the current date, or events on the day.\r\n *\r\n * @typeparam T The type of data stored in the [[Event]] class.\r\n * @typeparam M The type of metadata stored in the schedule.\r\n */\r\nvar CalendarDay_CalendarDay = (function (_super) {\r\n    CalendarDay___extends(CalendarDay, _super);\r\n    function CalendarDay() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        /**\r\n         * Whether this day is the current day (ex: today).\r\n         */\r\n        _this.currentDay = false;\r\n        /**\r\n         * Whether this day is on the same week as the current day (ex: today).\r\n         */\r\n        _this.currentWeek = false;\r\n        /**\r\n         * Whether this day is on the same month as the current day (ex: today).\r\n         */\r\n        _this.currentMonth = false;\r\n        /**\r\n         * Whether this day is on the same year as the current day (ex: today).\r\n         */\r\n        _this.currentYear = false;\r\n        /**\r\n         * How many days away this day is from the current day (ex: today). If this\r\n         * day is the current day the offset is 0. If this day is before the current\r\n         * day it will be the negative number of days away. Otherwise this will be\r\n         * positive meaning this day is after the current day by the given days.\r\n         */\r\n        _this.currentOffset = 0;\r\n        /**\r\n         * Whether this day is part of a selection on the calendar.\r\n         */\r\n        _this.selectedDay = false;\r\n        /**\r\n         * Whether this day is on the same week that the calendar selection is.\r\n         */\r\n        _this.selectedWeek = false;\r\n        /**\r\n         * Whether this day is on the same month that the calendar selection is.\r\n         */\r\n        _this.selectedMonth = false;\r\n        /**\r\n         * Whether this day is on the same year that the calendar selection is.\r\n         */\r\n        _this.selectedYear = false;\r\n        /**\r\n         * Whether this day is in the current calendar or not. Some days are outside\r\n         * the calendar span and used to fill in weeks. Month calendars will fill in\r\n         * days so the list of days in the calendar start on Sunday and end on Saturday.\r\n         */\r\n        _this.inCalendar = false;\r\n        /**\r\n         * The list of events on this day based on the settings and schedules in the\r\n         * calendar.\r\n         */\r\n        _this.events = [];\r\n        return _this;\r\n    }\r\n    /**\r\n     * Creates an iterator for the events on this day.\r\n     *\r\n     * @returns The new iterator for the events on this day.\r\n     */\r\n    CalendarDay.prototype.iterateEvents = function () {\r\n        return Iterator_Iterator.forArray(this.events);\r\n    };\r\n    /**\r\n     * Updates the current flags on this day given the current day (ex: today).\r\n     *\r\n     * @param current The current day of the calendar.\r\n     */\r\n    CalendarDay.prototype.updateCurrent = function (current) {\r\n        this.currentDay = this.sameDay(current);\r\n        this.currentWeek = this.sameWeek(current);\r\n        this.currentMonth = this.sameMonth(current);\r\n        this.currentYear = this.sameYear(current);\r\n        this.currentOffset = this.daysBetween(current, Op.DOWN, false);\r\n        return this;\r\n    };\r\n    /**\r\n     * Updates the selection flags on this day given the selection range on the\r\n     * calendar.\r\n     *\r\n     * @param selected The span of days selected on the calendar.\r\n     */\r\n    CalendarDay.prototype.updateSelected = function (selected) {\r\n        this.selectedDay = selected.matchesDay(this);\r\n        this.selectedWeek = selected.matchesWeek(this);\r\n        this.selectedMonth = selected.matchesMonth(this);\r\n        this.selectedYear = selected.matchesYear(this);\r\n        return this;\r\n    };\r\n    /**\r\n     * Clears the selection flags on this day. This is done when the selection on\r\n     * the calendar is cleared.\r\n     */\r\n    CalendarDay.prototype.clearSelected = function () {\r\n        this.selectedDay = this.selectedWeek = this.selectedMonth = this.selectedYear = false;\r\n        return this;\r\n    };\r\n    return CalendarDay;\r\n}(Day_Day));\r\n\r\n\n// CONCATENATED MODULE: ./src/CalendarEvent.ts\n\r\n\r\n/**\r\n * An instance of an [[Event]] on a given day of a [[Calendar]] generated by\r\n * the event's [[Schedule]].\r\n *\r\n * @typeparam T The type of data stored in the [[Event]] class.\r\n * @typeparam M The type of metadata stored in the schedule and in this class.\r\n */\r\nvar CalendarEvent_CalendarEvent = (function () {\r\n    /**\r\n     * Creates a new event instance given the id, the event paired with the\r\n     * schedule, the schedule, the time span of the event, and the day on the\r\n     * calendar the event belongs to.\r\n     *\r\n     * @param id The relatively unique identifier of this event.\r\n     * @param event The event which created this instance.\r\n     * @param time The time span of this event.\r\n     * @param actualDay The day on the calendar this event is for.\r\n     */\r\n    function CalendarEvent(id, event, time, actualDay) {\r\n        /**\r\n         * The row this event is on in a visual calendar. An event can span multiple\r\n         * days and it is desirable to have the occurrence on each day to line up.\r\n         * This is only set when [[Calendar.updateRows]] is true or manually set.\r\n         * This value makes sense for visual calendars for all day events or when the\r\n         * visual calendar is not positioning events based on their time span.\r\n         */\r\n        this.row = 0;\r\n        /**\r\n         * The column this event is on in a visual calendar. An event can have its\r\n         * time overlap with another event displaying one of the events in another\r\n         * column. This is only set when [[Calendar.updateColumns]] is true or\r\n         * manually set. This value makes sense for visual calendars that are\r\n         * displaying event occurrences at specific times positioned accordingly.\r\n         */\r\n        this.col = 0;\r\n        /**\r\n         * Define width of event column in visual calendar.\r\n         * Don't mix it up with day or week column width.\r\n         */\r\n        this.colWidth = 0;\r\n        this.id = id;\r\n        this.event = event;\r\n        this.time = time;\r\n        this.day = actualDay;\r\n        this.fullDay = event.schedule.isFullDay();\r\n        this.meta = event.schedule.getMeta(time.start);\r\n        this.cancelled = event.schedule.isCancelled(time.start);\r\n        this.starting = time.isPoint || time.start.sameDay(actualDay);\r\n        this.ending = time.isPoint || time.end.relative(-1).sameDay(actualDay);\r\n    }\r\n    Object.defineProperty(CalendarEvent.prototype, \"scheduleId\", {\r\n        /**\r\n         * The id of the schedule uniqe within the calendar which generated this event.\r\n         */\r\n        get: function () {\r\n            return Math.floor(this.id / Constants.MAX_EVENTS_PER_DAY);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(CalendarEvent.prototype, \"start\", {\r\n        /**\r\n         * The start timestamp of the event.\r\n         */\r\n        get: function () {\r\n            return this.time.start;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(CalendarEvent.prototype, \"end\", {\r\n        /**\r\n         * The end timestamp of the event.\r\n         */\r\n        get: function () {\r\n            return this.time.end;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(CalendarEvent.prototype, \"schedule\", {\r\n        /**\r\n         * The schedule which generated this event.\r\n         */\r\n        get: function () {\r\n            return this.event.schedule;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(CalendarEvent.prototype, \"data\", {\r\n        /**\r\n         * The related event data.\r\n         */\r\n        get: function () {\r\n            return this.event.data;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(CalendarEvent.prototype, \"identifier\", {\r\n        /**\r\n         * An [[IdentifierInput]] for the start of this event.\r\n         */\r\n        get: function () {\r\n            return this.identifierType.get(this.start);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(CalendarEvent.prototype, \"identifierType\", {\r\n        /**\r\n         * The [[Identifier]] for this event. Either [[Identifier.Day]] or\r\n         * [[Identifier.Time]].\r\n         */\r\n        get: function () {\r\n            return this.schedule.identifierType;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(CalendarEvent.prototype, \"startDelta\", {\r\n        /**\r\n         * Returns a delta value between 0 and 1 which represents where the\r\n         * [[CalendarEvent.start]] is relative to [[CalendarEvent.day]]. The delta\r\n         * value would be less than 0 if the start of the event is before\r\n         * [[CalendarEvent.day]].\r\n         */\r\n        get: function () {\r\n            return this.time.startDelta(this.day);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(CalendarEvent.prototype, \"endDelta\", {\r\n        /**\r\n         * Returns a delta value between 0 and 1 which represents where the\r\n         * [[CalendarEvent.end]] is relative to [[CalendarEvent.day]]. The delta value\r\n         * would be greater than 1 if the end of the event is after\r\n         * [[CalendarEvent.day]].\r\n         */\r\n        get: function () {\r\n            return this.time.endDelta(this.day);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Calculates the bounds for this event if it were placed in a rectangle which\r\n     * represents a day (24 hour period). By default the returned values are\r\n     * between 0 and 1 and can be scaled by the proper rectangle dimensions or the\r\n     * rectangle dimensions can be passed to this function.\r\n     *\r\n     * @param dayHeight The height of the rectangle of the day.\r\n     * @param dayWidth The width of the rectangle of the day.\r\n     * @param columnOffset The offset in the rectangle of the day to adjust this\r\n     *    event by if it intersects or is contained in a previous event. This also\r\n     *    reduces the width of the returned bounds to keep the bounds in the\r\n     *    rectangle of the day.\r\n     * @param clip `true` if the bounds should stay in the day rectangle, `false`\r\n     *    and the bounds may go outside the rectangle of the day for multi-day\r\n     *    events.\r\n     * @param offsetX How much to translate the left & right properties by.\r\n     * @param offsetY How much to translate the top & bottom properties by.\r\n     * @returns The calculated bounds for this event.\r\n     */\r\n    CalendarEvent.prototype.getTimeBounds = function (dayHeight, dayWidth, columnOffset, clip, offsetX, offsetY) {\r\n        if (dayHeight === void 0) { dayHeight = 1; }\r\n        if (dayWidth === void 0) { dayWidth = 1; }\r\n        if (columnOffset === void 0) { columnOffset = 0.1; }\r\n        if (clip === void 0) { clip = true; }\r\n        if (offsetX === void 0) { offsetX = 0; }\r\n        if (offsetY === void 0) { offsetY = 0; }\r\n        return this.time.getBounds(this.day, dayHeight, dayWidth, this.col, this.colWidth, clip, offsetX, offsetY);\r\n    };\r\n    /**\r\n     * Changes the cancellation status of this event. By default this cancels\r\n     * this event - but `false` may be passed to undo a cancellation.\r\n     *\r\n     * @param cancelled Whether the event should be cancelled.\r\n     */\r\n    CalendarEvent.prototype.cancel = function (cancelled) {\r\n        if (cancelled === void 0) { cancelled = true; }\r\n        this.schedule.setCancelled(this.start, cancelled);\r\n        this.cancelled = cancelled;\r\n        return this;\r\n    };\r\n    /**\r\n     * Changes the exclusion status of this event. By default this excludes this\r\n     * event - but `false`  may be passed to undo an exclusion.\r\n     *\r\n     * @param excluded Whether the event should be excluded.\r\n     */\r\n    CalendarEvent.prototype.exclude = function (excluded) {\r\n        if (excluded === void 0) { excluded = true; }\r\n        this.schedule.setExcluded(this.start, excluded);\r\n        return this;\r\n    };\r\n    /**\r\n     * Moves this event to potentially another day and time. A move is\r\n     * accomplished by excluding the current event and adding an inclusion of the\r\n     * new day & time. Any [[CalendarEvent.meta]] on this event will be moved to\r\n     * the new event. If the schedule represents a single event\r\n     * ([[Schedule.isSingleEvent]]) then the schedule frequencies are updated\r\n     * to match the timestamp provided.\r\n     *\r\n     * @param toTime The timestamp to move this event to.\r\n     * @returns Whether the event was moved to the given time.\r\n     */\r\n    CalendarEvent.prototype.move = function (toTime) {\r\n        return this.schedule.move(toTime, this.start);\r\n    };\r\n    return CalendarEvent;\r\n}());\r\n\r\n\n// CONCATENATED MODULE: ./src/Calendar.ts\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * A collection of [[CalendarDay]]s, the events on the calendar, and all\r\n * [[CalendarEvent]]s generated based on the events.\r\n *\r\n * @typeparam T The type of data stored in the [[Event]] class.\r\n * @typeparam M The type of metadata stored in the schedule.\r\n */\r\nvar Calendar_Calendar = (function () {\r\n    /**\r\n     * Creates a new calendar given a span, type, size, moving functions, and\r\n     * optionally some default properties for the calendar.\r\n     *\r\n     * @param start The first day on the calendar.\r\n     * @param end The last day on the calendar.\r\n     * @param type The calendar type used for describing the calendar and splitting it.\r\n     * @param size The number of calendar types in this calendar.\r\n     * @param moveStart The function to move the start day.\r\n     * @param moveEnd The function to move the end by.\r\n     * @param input The default properties for this calendar.\r\n     * @see [[Calendar.start]]\r\n     * @see [[Calendar.end]]\r\n     * @see [[Calendar.type]]\r\n     * @see [[Calendar.size]]\r\n     * @see [[Calendar.moveStart]]\r\n     * @see [[Calendar.moveEnd]]\r\n     */\r\n    function Calendar(start, end, type, size, moveStart, moveEnd, input) {\r\n        /**\r\n         * If the calendar should be filled in so the first day of the calendar is\r\n         * Sunday and the last day is Saturday.\r\n         */\r\n        this.fill = false;\r\n        /**\r\n         * The minimum number of days in the calendar no matter what the type or size\r\n         * is. This can be used to display a month with a constant number of weeks -\r\n         * because not all months contain the same number of weeks.\r\n         */\r\n        this.minimumSize = 0;\r\n        /**\r\n         * When `true` a [[CalendarEvent]] instance exists on each [[CalendarDay]]\r\n         * the event covers even if the event didn't start on that day.\r\n         */\r\n        this.repeatCovers = true;\r\n        /**\r\n         * When `true` an event instance will be created for each time specified on\r\n         * the schedule. If the schedule specifies an all day event then only one\r\n         * event is added to a day. This is typically done when displaying days or\r\n         * weeks and events can be displayed on a timeline.\r\n         */\r\n        this.listTimes = false;\r\n        /**\r\n         * When `true` events will be added to days \"outside\" the calendar. Days\r\n         * outside the calendar are days filled in when [[Calendar.fill]] is `true`.\r\n         * More specifically days that are in [[Calendar.filled]] and not in\r\n         * [[Calendar.span]].\r\n         */\r\n        this.eventsOutside = false;\r\n        /**\r\n         * When `true` [[CalendarEvent.row]] will be set so when visually displaying\r\n         * the event with others multi-day events will align and not overlap.\r\n         */\r\n        this.updateRows = false;\r\n        /**\r\n         * When `true` [[CalendarEvent.col]] will be set so when visually displaying\r\n         * the event based on start and end time any events that overlap with each\r\n         * other will be \"indented\" to see the event below it.\r\n         */\r\n        this.updateColumns = false;\r\n        /**\r\n         * The function (if any) which sorts the events on a calendar day.\r\n         */\r\n        this.eventSorter = null;\r\n        /**\r\n         * A function to use when parsing meta input into the desired type.\r\n         *\r\n         * @param input The input to parse.\r\n         * @returns The meta parsed from the given input, if any.\r\n         */\r\n        this.parseMeta = (function (x) { return x; });\r\n        /**\r\n         * A function to use when parsing meta input into the desired type.\r\n         *\r\n         * @param input The input to parse.\r\n         * @returns The meta parsed from the given input, if any.\r\n         */\r\n        this.parseData = (function (x) { return x; });\r\n        /**\r\n         * A selection of days on the calendar. If no days are selected this is `null`.\r\n         * This is merely used to keep the selection flags in [[CalendarDay]] updated\r\n         * via [[Calendar.refreshSelection]].\r\n         */\r\n        this.selection = null;\r\n        /**\r\n         * The array of days in this calendar and their events.\r\n         */\r\n        this.days = [];\r\n        /**\r\n         * The array of scheduled events added to the calendar.\r\n         */\r\n        this.events = [];\r\n        /**\r\n         * The array of visible events on the calendar. This is built based on the\r\n         * span of the schedule in the given event and also the [[Event.visible]] flag.\r\n         */\r\n        this.visible = [];\r\n        this.span = new DaySpan_DaySpan(start, end);\r\n        this.filled = new DaySpan_DaySpan(start, end);\r\n        this.type = type;\r\n        this.size = size;\r\n        this.moveStart = moveStart;\r\n        this.moveEnd = moveEnd;\r\n        if (Functions.isDefined(input)) {\r\n            this.set(input);\r\n        }\r\n        else {\r\n            this.refresh();\r\n        }\r\n    }\r\n    /**\r\n     * Changes the calendar possibly morphing it to a different type or size if\r\n     * specified in the given input. If the type and size are not morphed then\r\n     * the following properties may be updated:\r\n     *\r\n     * - [[Calendar.fill]]\r\n     * - [[Calendar.minimumSize]]\r\n     * - [[Calendar.repeatCovers]]\r\n     * - [[Calendar.listTimes]]\r\n     * - [[Calendar.eventsOutside]]\r\n     * - [[Calendar.updateRows]]\r\n     * - [[Calendar.updateColumns]]\r\n     * - [[Calendar.eventSorter]]\r\n     * - [[Calendar.events]]\r\n     * - [[Calendar.parseData]]\r\n     * - [[Calendar.parseMeta]]\r\n     *\r\n     * If [[CalendarInput.delayRefresh]] is not given with `true` then\r\n     * [[Calendar.refresh]] will be called once the calendar properties have been\r\n     * updated.\r\n     *\r\n     * @param input The new properties for this calendar to overwrite with.\r\n     */\r\n    Calendar.prototype.set = function (input) {\r\n        var typeChange = Functions.isDefined(input.type) && input.type !== this.type;\r\n        var sizeChange = Functions.isDefined(input.size) && input.size !== this.size;\r\n        if (typeChange || sizeChange) {\r\n            var focus_1 = Functions.coalesce(input.otherwiseFocus, 0.4999);\r\n            var prefer = Functions.coalesce(input.preferToday, true);\r\n            var size = Functions.coalesce(input.size, this.size);\r\n            var type = Functions.coalesce(input.type, this.type);\r\n            var around = Functions.coalesce(input.around, this.days[Math.floor((this.days.length - 1) * focus_1)]);\r\n            var today = Day_Day.today();\r\n            if (!around || (prefer && this.span.matchesDay(today))) {\r\n                around = today;\r\n            }\r\n            var meta = Calendar.TYPES[type];\r\n            var start = meta.getStart(Day_Day.parse(around), size, focus_1);\r\n            var end = meta.getEnd(start, size, focus_1);\r\n            this.span.start = start;\r\n            this.span.end = end;\r\n            this.type = type;\r\n            this.size = size;\r\n            this.moveStart = meta.moveStart;\r\n            this.moveEnd = meta.moveEnd;\r\n        }\r\n        else if (input.around) {\r\n            var focus_2 = Functions.coalesce(input.otherwiseFocus, 0.4999);\r\n            var around = Day_Day.parse(input.around);\r\n            var type = this.type;\r\n            var size = this.size;\r\n            var meta = Calendar.TYPES[type];\r\n            var start = meta.getStart(around, size, focus_2);\r\n            var end = meta.getEnd(start, size, focus_2);\r\n            this.span.start = start;\r\n            this.span.end = end;\r\n        }\r\n        this.fill = Functions.coalesce(input.fill, this.fill);\r\n        this.minimumSize = Functions.coalesce(input.minimumSize, this.minimumSize);\r\n        this.repeatCovers = Functions.coalesce(input.repeatCovers, this.repeatCovers);\r\n        this.listTimes = Functions.coalesce(input.listTimes, this.listTimes);\r\n        this.eventsOutside = Functions.coalesce(input.eventsOutside, this.eventsOutside);\r\n        this.updateRows = Functions.coalesce(input.updateRows, this.updateRows);\r\n        this.updateColumns = Functions.coalesce(input.updateColumns, this.updateColumns);\r\n        this.eventSorter = Functions.coalesce(input.eventSorter, this.eventSorter);\r\n        this.parseMeta = Functions.coalesce(input.parseMeta, this.parseMeta);\r\n        this.parseData = Functions.coalesce(input.parseData, this.parseData);\r\n        if (Functions.isArray(input.events)) {\r\n            this.setEvents(input.events, true);\r\n        }\r\n        if (!input.delayRefresh) {\r\n            this.refresh();\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Sets the [[Calendar.minimumSize]] value and returns `this` for method\r\n     * chaining.\r\n     *\r\n     * @param minimumSize The new value.\r\n     */\r\n    Calendar.prototype.withMinimumSize = function (minimumSize) {\r\n        this.minimumSize = minimumSize;\r\n        this.refresh();\r\n        return this;\r\n    };\r\n    /**\r\n     * Sets the [[Calendar.repeatCovers]] value and returns `this` for method\r\n     * chaining.\r\n     *\r\n     * @param repeatCovers The new value.\r\n     */\r\n    Calendar.prototype.withRepeatCovers = function (repeatCovers) {\r\n        this.repeatCovers = repeatCovers;\r\n        this.refreshEvents();\r\n        return this;\r\n    };\r\n    /**\r\n     * Sets the [[Calendar.listTimes]] value and returns `this` for method\r\n     * chaining.\r\n     *\r\n     * @param listTimes The new value.\r\n     */\r\n    Calendar.prototype.withListTimes = function (listTimes) {\r\n        this.listTimes = listTimes;\r\n        this.refreshEvents();\r\n        return this;\r\n    };\r\n    /**\r\n     * Sets the [[Calendar.eventsOutside]] value and returns `this` for method\r\n     * chaining.\r\n     *\r\n     * @param eventsOutside The new value.\r\n     */\r\n    Calendar.prototype.withEventsOutside = function (eventsOutside) {\r\n        this.eventsOutside = eventsOutside;\r\n        this.refreshEvents();\r\n        return this;\r\n    };\r\n    /**\r\n     * Sets the [[Calendar.updateRows]] value and returns `this` for method\r\n     * chaining.\r\n     *\r\n     * @param updateRows The new value.\r\n     * @param refresh If the rows should be updated now if `updateRows` is `true`.\r\n     */\r\n    Calendar.prototype.withUpdateRows = function (updateRows, refresh) {\r\n        if (refresh === void 0) { refresh = true; }\r\n        this.updateRows = updateRows;\r\n        if (refresh && updateRows) {\r\n            this.refreshRows();\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Sets the [[Calendar.updateColumns]] value and returns `this` for method\r\n     * chaining.\r\n     *\r\n     * @param updateColumns The new value.\r\n     * @param refresh If the columns should be updated now if `updateColumns` is\r\n     *    `true`.\r\n     */\r\n    Calendar.prototype.withUpdateColumns = function (updateColumns, refresh) {\r\n        if (refresh === void 0) { refresh = true; }\r\n        this.updateColumns = updateColumns;\r\n        if (refresh && updateColumns) {\r\n            this.refreshColumns();\r\n        }\r\n        return this;\r\n    };\r\n    Object.defineProperty(Calendar.prototype, \"start\", {\r\n        /**\r\n         * Returns the start day of the calendar. If this calendar is filled, this\r\n         * may not represent the very first day in the calendar.\r\n         */\r\n        get: function () {\r\n            return this.span.start;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Calendar.prototype, \"end\", {\r\n        /**\r\n         * Returns the end day of the calendar. If this calendar is filled, this\r\n         * may not represent the very last day in the calendar.\r\n         */\r\n        get: function () {\r\n            return this.span.end;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Returns the summary of the span of time this calendar represents.\r\n     *\r\n     * @param dayOfWeek [[DaySpan.summary]]\r\n     * @param short [[DaySpan.summary]]\r\n     * @param repeat [[DaySpan.summary]]\r\n     * @param contextual [[DaySpan.summary]]\r\n     * @param delimiter [[DaySpan.summary]]\r\n     * @see [[DaySpan.summary]]\r\n     */\r\n    Calendar.prototype.summary = function (dayOfWeek, short, repeat, contextual, delimiter) {\r\n        if (dayOfWeek === void 0) { dayOfWeek = true; }\r\n        if (short === void 0) { short = false; }\r\n        if (repeat === void 0) { repeat = false; }\r\n        if (contextual === void 0) { contextual = true; }\r\n        if (delimiter === void 0) { delimiter = \" - \"; }\r\n        return this.span.summary(this.type, dayOfWeek, short, repeat, contextual, delimiter);\r\n    };\r\n    /**\r\n     * Splits up this calendar into an iterable collection of calendars. The\r\n     * resulting iterator will return `size / by` number of calendars.\r\n     *\r\n     * @param by The new size of the resulting calendars. If the the size of the\r\n     *    current calendar is not divisible by this value the resulting calendars\r\n     *    may cover more or less than this calendar covers.\r\n     * @returns An iterator for the calendars produced.\r\n     */\r\n    Calendar.prototype.split = function (by) {\r\n        var _this = this;\r\n        if (by === void 0) { by = 1; }\r\n        return new Iterator_Iterator(function (iterator) {\r\n            var start = _this.start;\r\n            var end = _this.moveEnd(_this.end, by - _this.size);\r\n            for (var i = 0; i < _this.size; i++) {\r\n                var calendar = new Calendar(start, end, _this.type, by, _this.moveStart, _this.moveEnd, _this);\r\n                if (iterator.act(calendar) === IteratorAction.Stop) {\r\n                    return;\r\n                }\r\n                start = _this.moveStart(start, by);\r\n                end = _this.moveEnd(end, by);\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * Refreshes the days and events in this calendar based on the start and end\r\n     * days, the calendar properties, and its eventss.\r\n     *\r\n     * @param today The current day to update the calendar days via\r\n     *    [[CalendarDay.updateCurrent]].\r\n     */\r\n    Calendar.prototype.refresh = function (today) {\r\n        if (today === void 0) { today = Day_Day.today(); }\r\n        this.length = this.span.days(Op.UP, true);\r\n        this.resetDays();\r\n        this.refreshCurrent(today);\r\n        this.refreshSelection();\r\n        this.refreshVisible();\r\n        this.refreshEvents();\r\n        return this;\r\n    };\r\n    /**\r\n     * Updates the [[Calendar.filled]] span based on [[Calendar.start]],\r\n     * [[Calendar.end]], and [[Calendar.fill]] properties.\r\n     */\r\n    Calendar.prototype.resetFilled = function () {\r\n        this.filled.start = this.fill ? this.start.startOfWeek() : this.start;\r\n        this.filled.end = this.fill ? this.end.endOfWeek() : this.end;\r\n        return this;\r\n    };\r\n    /**\r\n     * Updates [[Calendar.days]] to match the span of days in the calendar.\r\n     */\r\n    Calendar.prototype.resetDays = function () {\r\n        this.resetFilled();\r\n        var days = this.days;\r\n        var filled = this.filled;\r\n        var current = filled.start;\r\n        var daysBetween = filled.days(Op.UP);\r\n        var total = Math.max(this.minimumSize, daysBetween);\r\n        for (var i = 0; i < total; i++) {\r\n            var day = days[i];\r\n            if (!day || !day.sameDay(current)) {\r\n                day = new CalendarDay_CalendarDay(current.date);\r\n                if (i < days.length) {\r\n                    days.splice(i, 1, day);\r\n                }\r\n                else {\r\n                    days.push(day);\r\n                }\r\n            }\r\n            day.inCalendar = this.span.contains(day);\r\n            current = current.next();\r\n        }\r\n        if (days.length > total) {\r\n            days.splice(total, days.length - total);\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Updates the list of visible schedules.\r\n     */\r\n    Calendar.prototype.refreshVisible = function () {\r\n        var start = this.filled.start;\r\n        var end = this.filled.end;\r\n        this.visible = this.events.filter(function (e) {\r\n            return e.visible && e.schedule.matchesRange(start, end);\r\n        });\r\n        return this;\r\n    };\r\n    /**\r\n     * Updates the days with the current day via [[CalendarDay.updateCurrent]].\r\n     *\r\n     * @param today The new current day.\r\n     */\r\n    Calendar.prototype.refreshCurrent = function (today) {\r\n        if (today === void 0) { today = Day_Day.today(); }\r\n        this.iterateDays().iterate(function (d) {\r\n            d.updateCurrent(today);\r\n        });\r\n        return this;\r\n    };\r\n    /**\r\n     * Updates the selection flags in [[CalendarDay]] based on the\r\n     * [[Calendar.selection]] property.\r\n     */\r\n    Calendar.prototype.refreshSelection = function () {\r\n        var _this = this;\r\n        this.iterateDays().iterate(function (d) {\r\n            if (_this.selection) {\r\n                d.updateSelected(_this.selection);\r\n            }\r\n            else {\r\n                d.clearSelected();\r\n            }\r\n        });\r\n        return this;\r\n    };\r\n    /**\r\n     * Updates the [[CalendarDay.events]] based on the events in this calendar\r\n     * and the following properties:\r\n     *\r\n     * - [[Calendar.eventsForDay]]\r\n     * - [[Calendar.eventsOutside]]\r\n     * - [[Calendar.listTimes]]\r\n     * - [[Calendar.repeatCovers]]\r\n     * - [[Calendar.updateRows]]\r\n     * - [[Calendar.updateColumns]]\r\n     */\r\n    Calendar.prototype.refreshEvents = function () {\r\n        var _this = this;\r\n        this.iterateDays().iterate(function (d) {\r\n            if (d.inCalendar || _this.eventsOutside) {\r\n                d.events = _this.eventsForDay(d, _this.listTimes, _this.repeatCovers);\r\n            }\r\n        });\r\n        if (this.updateRows) {\r\n            this.refreshRows();\r\n        }\r\n        if (this.updateColumns) {\r\n            this.refreshColumns();\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Refreshes the [[CalendarEvent.row]] property as described in the link.\r\n     */\r\n    Calendar.prototype.refreshRows = function () {\r\n        var eventToRow = {};\r\n        var onlyFullDay = this.listTimes;\r\n        this.iterateDays().iterate(function (d) {\r\n            if (d.dayOfWeek === 0) {\r\n                eventToRow = {};\r\n            }\r\n            var used = {};\r\n            for (var _i = 0, _a = d.events; _i < _a.length; _i++) {\r\n                var event_1 = _a[_i];\r\n                if (onlyFullDay && !event_1.fullDay) {\r\n                    continue;\r\n                }\r\n                if (event_1.id in eventToRow) {\r\n                    used[event_1.row = eventToRow[event_1.id]] = true;\r\n                }\r\n            }\r\n            var rowIndex = 0;\r\n            for (var _b = 0, _c = d.events; _b < _c.length; _b++) {\r\n                var event_2 = _c[_b];\r\n                if ((onlyFullDay && !event_2.fullDay) || event_2.id in eventToRow) {\r\n                    continue;\r\n                }\r\n                while (used[rowIndex]) {\r\n                    rowIndex++;\r\n                }\r\n                eventToRow[event_2.id] = event_2.row = rowIndex;\r\n                rowIndex++;\r\n            }\r\n        });\r\n        return this;\r\n    };\r\n    /**\r\n     * Refreshes the [[CalendarEvent.col]] and [[CalendarEvent.colWidth]] property as described in the link.\r\n     *\r\n     * Based on https://stackoverflow.com/questions/11311410/visualization-of-calendar-events-algorithm-to-layout-events-with-maximum-width\r\n     * 1. Think of an unlimited grid with just a left edge.\r\n     * 2. Each event is one cell wide, and the height and vertical position is fixed based on starting and ending times.\r\n     * 3. Try to place each event in a column as far left as possible, without it intersecting any earlier event in that column.\r\n     * 4. Then, when each connected group of events is placed, their actual widths will be 1/n of the maximum number of columns used by the group.\r\n     * 5. You could also expand the events at the far left and right to use up any remaining space.\r\n     */\r\n    Calendar.prototype.refreshColumns = function () {\r\n        this.iterateDays().iterate(function (d) {\r\n            var columns = [];\r\n            var lastEventEnding = null;\r\n            var events = d.events;\r\n            events.sort(function (e1, e2) {\r\n                if (e1.time.start.time < e2.time.start.time)\r\n                    return -1;\r\n                if (e1.time.start.time > e2.time.start.time)\r\n                    return 1;\r\n                if (e1.time.end.time < e2.time.end.time)\r\n                    return -1;\r\n                if (e1.time.end.time > e2.time.end.time)\r\n                    return 1;\r\n                return 0;\r\n            });\r\n            for (var _i = 0, events_1 = events; _i < events_1.length; _i++) {\r\n                var event_3 = events_1[_i];\r\n                // Check if a new event group needs to be started\r\n                if (lastEventEnding !== null && event_3.time.start.time >= lastEventEnding) {\r\n                    // The latest event is later than any of the event in the\r\n                    // current group. There is no overlap. Output the current\r\n                    // event group and start a new event group.\r\n                    packEvents(columns);\r\n                    columns = []; // This starts new event group.\r\n                    lastEventEnding = null;\r\n                }\r\n                var placed = false;\r\n                for (var i = 0; i < columns.length; i++) {\r\n                    var col = columns[i];\r\n                    if (!collidesWith(col[col.length - 1], event_3)) {\r\n                        col.push(event_3);\r\n                        placed = true;\r\n                        break;\r\n                    }\r\n                }\r\n                // It was not possible to place the event. Add a new column\r\n                // for the current event group.\r\n                if (!placed) {\r\n                    columns.push([event_3]);\r\n                }\r\n                // Remember the latest event end time of the current group.\r\n                // This is later used to determine if a new groups starts.\r\n                if (lastEventEnding === null || event_3.time.end.time > lastEventEnding) {\r\n                    lastEventEnding = event_3.time.end.time;\r\n                }\r\n            }\r\n            if (columns.length > 0) {\r\n                packEvents(columns);\r\n            }\r\n        });\r\n        /**\r\n         * Make the layout for a group of events by set the left offset\r\n         * and width for each event in the connected group.\r\n         * Step 4 in the algorithm.\r\n         */\r\n        function packEvents(columns) {\r\n            var columnsLength = columns.length;\r\n            columns.forEach(function (col, colIndex) {\r\n                col.forEach(function (event) {\r\n                    var colSpan = expandEvent(event, colIndex, columns);\r\n                    event.col = colIndex / columnsLength;\r\n                    event.colWidth = colSpan / columnsLength;\r\n                });\r\n            });\r\n        }\r\n        /**\r\n         * Check if two events collide.\r\n         */\r\n        function collidesWith(e1, e2) {\r\n            return e1.time.end.time > e2.time.start.time && e1.time.start.time < e2.time.end.time;\r\n        }\r\n        /**\r\n         * Expand events at the far right to use up any remaining space.\r\n         * Return number how many columns the event can expand into, without\r\n         * colliding with other events.\r\n         * Step 5 in the algorithm.\r\n         */\r\n        function expandEvent(e1, colIndex, columns) {\r\n            var colSpan = 1;\r\n            for (var i = colIndex + 1; i < columns.length; i++) {\r\n                var col = columns[i];\r\n                for (var j = 0; j < col.length; j++) {\r\n                    var e2 = col[j];\r\n                    if (collidesWith(e1, e2)) {\r\n                        return colSpan;\r\n                    }\r\n                }\r\n                colSpan++;\r\n            }\r\n            return colSpan;\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Gets the calendar day for the given day.\r\n     *\r\n     * @param input The day to get the calendar day for.\r\n     * @returns The reference to the calendar day, or null if the given input\r\n     *    is not on this calendar.\r\n     */\r\n    Calendar.prototype.getDay = function (input) {\r\n        var parsed = Day_Day.parse(input);\r\n        if (parsed) {\r\n            var dayCount = parsed.start().daysBetween(this.days[0], Op.DOWN, false);\r\n            return this.days[dayCount];\r\n        }\r\n        return null;\r\n    };\r\n    /**\r\n     * Iterates over all days in this calendar and passes each day to `iterator`.\r\n     *\r\n     * @param iterator The function to pass [[CalendarDay]]s to.\r\n     */\r\n    Calendar.prototype.iterateDays = function () {\r\n        var _this = this;\r\n        return new Iterator_Iterator(function (iterator) {\r\n            var days = _this.days;\r\n            for (var i = 0; i < days.length; i++) {\r\n                switch (iterator.act(days[i])) {\r\n                    case IteratorAction.Stop:\r\n                        return;\r\n                }\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * Returns the events for the given day optionally looking at schedule times,\r\n     * optionally looking at events which cover multiple days, and optionally\r\n     * sorted with the given function.\r\n     *\r\n     * @param day The day to find events for.\r\n     * @param getTimes When `true` an event is added to the result for each time\r\n     *    specified in the schedule.\r\n     * @param covers When `true` events which don't start on the given day but do\r\n     *    overlap are added to the result.\r\n     * @param sorter The function to sort the events by, if any.\r\n     * @returns An array of events that occurred on the given day.\r\n     */\r\n    Calendar.prototype.eventsForDay = function (day, getTimes, covers, sorter) {\r\n        if (getTimes === void 0) { getTimes = true; }\r\n        if (covers === void 0) { covers = true; }\r\n        if (sorter === void 0) { sorter = this.eventSorter; }\r\n        var events = [];\r\n        var entries = this.visible;\r\n        var _loop_1 = function (entryIndex) {\r\n            var entry = entries[entryIndex];\r\n            var schedule = entry.schedule;\r\n            var eventId = entryIndex * Constants.MAX_EVENTS_PER_DAY;\r\n            var timeIndex = 0;\r\n            schedule.iterateSpans(day, covers).iterate(function (span, iterator) {\r\n                events.push(new CalendarEvent_CalendarEvent(eventId + timeIndex++, entry, span, day));\r\n                if (!getTimes) {\r\n                    iterator.stop();\r\n                }\r\n            });\r\n        };\r\n        for (var entryIndex = 0; entryIndex < entries.length; entryIndex++) {\r\n            _loop_1(entryIndex);\r\n        }\r\n        if (sorter) {\r\n            events.sort(sorter);\r\n        }\r\n        return events;\r\n    };\r\n    /**\r\n     * Finds the event given one of the ways to identify the event.\r\n     *\r\n     * @param input The value to use to search for an event.\r\n     * @returns The refrence to the event or null if not found.\r\n     */\r\n    Calendar.prototype.findEvent = function (id) {\r\n        for (var _i = 0, _a = this.events; _i < _a.length; _i++) {\r\n            var event_4 = _a[_i];\r\n            if (event_4 === id || event_4.schedule === id || event_4.data === id || event_4.id === id) {\r\n                return event_4;\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    /**\r\n     * Removes the list of events if they exist in the calendar.\r\n     *\r\n     * @param events The array of events to remove if they exist. If no\r\n     *    events are passed (via `null`) then all events will be removed\r\n     *    from the calendar.\r\n     * @param delayRefresh When `true` the [[Calendar.refreshEvents]] will not be\r\n     *    called after the events are removed.\r\n     * @see [[Calendar.removeEvent]]\r\n     * @see [[Calendar.refreshEvents]]\r\n     */\r\n    Calendar.prototype.removeEvents = function (events, delayRefresh) {\r\n        if (events === void 0) { events = null; }\r\n        if (delayRefresh === void 0) { delayRefresh = false; }\r\n        if (events) {\r\n            for (var _i = 0, events_2 = events; _i < events_2.length; _i++) {\r\n                var event_5 = events_2[_i];\r\n                this.removeEvent(event_5, true);\r\n            }\r\n        }\r\n        else {\r\n            this.events = [];\r\n        }\r\n        this.refreshVisible();\r\n        if (!delayRefresh) {\r\n            this.refreshEvents();\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Removes the given event if it exists on the calendar.\r\n     *\r\n     * @param event The event to remove if it exists.\r\n     * @param delayRefresh When `true` the [[Calendar.refreshEvents]] will not be\r\n     *    called after the event is removed.\r\n     * @see [[Calendar.refreshEvents]]\r\n     */\r\n    Calendar.prototype.removeEvent = function (event, delayRefresh) {\r\n        if (delayRefresh === void 0) { delayRefresh = false; }\r\n        var found = this.findEvent(event);\r\n        if (found) {\r\n            this.events.splice(this.events.indexOf(found), 1);\r\n            this.refreshVisible();\r\n            if (!delayRefresh) {\r\n                this.refreshEvents();\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Adds the given event to this calendar if it doesn't exist already (or\r\n     * `allowDuplicates` is `true`).\r\n     *\r\n     * @param event The event to add to the calendar.\r\n     * @param allowDuplicates If an event can be added more than once.\r\n     * @param delayRefresh When `true` the [[Calendar.refreshEvents]] will not be\r\n     *    called after the event is added.\r\n     * @see [[Calendar.refreshEvents]]\r\n     */\r\n    Calendar.prototype.addEvent = function (event, allowDuplicates, delayRefresh) {\r\n        if (allowDuplicates === void 0) { allowDuplicates = false; }\r\n        if (delayRefresh === void 0) { delayRefresh = false; }\r\n        var parsed = Parse_Parse.event(event, this.parseData, this.parseMeta);\r\n        if (!allowDuplicates) {\r\n            var existing = this.findEvent(parsed);\r\n            if (existing) {\r\n                return this;\r\n            }\r\n        }\r\n        this.events.push(parsed);\r\n        this.refreshVisible();\r\n        if (!delayRefresh) {\r\n            this.refreshEvents();\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Adds the given events to this calendar if they don't exist already (or\r\n     * `allowDuplicates` is `true`).\r\n     *\r\n     * @param events The events to add to the calendar.\r\n     * @param allowDuplicates If an event can be added more than once.\r\n     * @param delayRefresh When `true` the [[Calendar.refreshEvents]] will not be\r\n     *    called after the events are added.\r\n     * @see [[Calendar.refreshEvents]]\r\n     */\r\n    Calendar.prototype.addEvents = function (events, allowDuplicates, delayRefresh) {\r\n        if (allowDuplicates === void 0) { allowDuplicates = false; }\r\n        if (delayRefresh === void 0) { delayRefresh = false; }\r\n        for (var _i = 0, events_3 = events; _i < events_3.length; _i++) {\r\n            var event_6 = events_3[_i];\r\n            this.addEvent(event_6, allowDuplicates, true);\r\n        }\r\n        if (!delayRefresh) {\r\n            this.refreshEvents();\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Sets the given events to this calendar replacing the current list of\r\n     * events.\r\n     *\r\n     * @param events The events to set to the calendar.\r\n     * @param delayRefresh When `true` the [[Calendar.refreshEvents]] will not be\r\n     *    called after the events are added.\r\n     * @see [[Calendar.refreshEvents]]\r\n     */\r\n    Calendar.prototype.setEvents = function (events, delayRefresh) {\r\n        if (delayRefresh === void 0) { delayRefresh = false; }\r\n        var parsedEvents = [];\r\n        for (var i = 0; i < events.length; i++) {\r\n            var parsed = Parse_Parse.event(events[i], this.parseData, this.parseMeta);\r\n            if (parsed) {\r\n                parsedEvents.push(parsed);\r\n            }\r\n        }\r\n        this.events = parsedEvents;\r\n        this.refreshVisible();\r\n        if (!delayRefresh) {\r\n            this.refreshEvents();\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Sets the selection point or range of the calendar and updates the flags\r\n     * in the days.\r\n     *\r\n     * @param start The start of the selection.\r\n     * @param end The end of the selection.\r\n     * @see [[Calendar.refreshSelection]]\r\n     */\r\n    Calendar.prototype.select = function (start, end) {\r\n        if (end === void 0) { end = start; }\r\n        this.selection = new DaySpan_DaySpan(start, end);\r\n        this.refreshSelection();\r\n        return this;\r\n    };\r\n    /**\r\n     * Sets the selection of the calendar to nothing.\r\n     *\r\n     * @see [[Calendar.refreshSelection]]\r\n     */\r\n    Calendar.prototype.unselect = function () {\r\n        this.selection = null;\r\n        this.refreshSelection();\r\n        return this;\r\n    };\r\n    /**\r\n     * Shifts the calendar days by the given amount.\r\n     *\r\n     * @param jump The amount to shift the calendar by.\r\n     * @param delayRefresh When `true` [[Calendar.refresh]] will not be called\r\n     *    after calendar is moved.\r\n     */\r\n    Calendar.prototype.move = function (jump, delayRefresh) {\r\n        if (jump === void 0) { jump = this.size; }\r\n        if (delayRefresh === void 0) { delayRefresh = false; }\r\n        this.span.start = this.moveStart(this.start, jump);\r\n        this.span.end = this.moveEnd(this.end, jump);\r\n        if (!delayRefresh) {\r\n            this.refresh();\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Moves the calenndar to the next set of days.\r\n     *\r\n     * @param jump The amount to shift the calendar by.\r\n     * @param delayRefresh When `true` [[Calendar.refresh]] will not be called\r\n     *    after calendar is moved.\r\n     */\r\n    Calendar.prototype.next = function (jump, delayRefresh) {\r\n        if (jump === void 0) { jump = this.size; }\r\n        if (delayRefresh === void 0) { delayRefresh = false; }\r\n        return this.move(jump, delayRefresh);\r\n    };\r\n    /**\r\n     * Moves the calenndar to the previous set of days.\r\n     *\r\n     * @param jump The amount to shift the calendar by.\r\n     * @param delayRefresh When `true` [[Calendar.refresh]] will not be called\r\n     *    after calendar is moved.\r\n     */\r\n    Calendar.prototype.prev = function (jump, delayRefresh) {\r\n        if (jump === void 0) { jump = this.size; }\r\n        if (delayRefresh === void 0) { delayRefresh = false; }\r\n        return this.move(-jump, delayRefresh);\r\n    };\r\n    /**\r\n     * Converts this calendar to input which can be used to later recreate this\r\n     * calendar. The only properties of the calendar which will be loss is the\r\n     * [[Calendar.eventSorter]] property because it is a function.\r\n     *\r\n     * @param plain If the returned input should be plain objects as opposed\r\n     *    to [[Day]] and [[Event]] instances.\r\n     * @param plainData A function to convert [[Event.data]] to a plain object if\r\n     *    it is not already.\r\n     * @param plainMeta A function to convert values in [[Schedule.meta]] to plain\r\n     *    objects if they are not alreday.\r\n     * @returns The input generated from this calendar.\r\n     */\r\n    Calendar.prototype.toInput = function (plain, plainData, plainMeta) {\r\n        if (plain === void 0) { plain = false; }\r\n        if (plainData === void 0) { plainData = function (d) { return d; }; }\r\n        if (plainMeta === void 0) { plainMeta = function (m) { return m; }; }\r\n        var out = {};\r\n        out.type = this.type;\r\n        out.size = this.size;\r\n        out.fill = this.fill;\r\n        out.minimumSize = this.minimumSize;\r\n        out.repeatCovers = this.repeatCovers;\r\n        out.listTimes = this.listTimes;\r\n        out.eventsOutside = this.eventsOutside;\r\n        out.updateRows = this.updateRows;\r\n        out.updateColumns = this.updateColumns;\r\n        out.around = plain ? this.span.start.time : this.span.start;\r\n        out.events = [];\r\n        for (var _i = 0, _a = this.events; _i < _a.length; _i++) {\r\n            var event_7 = _a[_i];\r\n            if (plain) {\r\n                var plainEvent = {};\r\n                if (Functions.isDefined(event_7.id)) {\r\n                    plainEvent.id = event_7.id;\r\n                }\r\n                if (Functions.isDefined(event_7.data)) {\r\n                    plainEvent.data = plainData(event_7.data);\r\n                }\r\n                if (!event_7.visible) {\r\n                    plainEvent.visible = event_7.visible;\r\n                }\r\n                plainEvent.schedule = event_7.schedule.toInput();\r\n                var meta = plainEvent.schedule.meta;\r\n                if (meta) {\r\n                    for (var identifier in meta) {\r\n                        meta[identifier] = plainMeta(meta[identifier]);\r\n                    }\r\n                }\r\n                out.events.push(plainEvent);\r\n            }\r\n            else {\r\n                out.events.push(event_7);\r\n            }\r\n        }\r\n        return out;\r\n    };\r\n    /**\r\n     * Creates a calendar based on the given input.\r\n     *\r\n     * @param input The input which has at least the `type` specified.\r\n     * @returns A new calendar instance.\r\n     */\r\n    Calendar.fromInput = function (input) {\r\n        var initial = Day_Day.today();\r\n        return new Calendar(initial, initial, null, 1, null, null, input);\r\n    };\r\n    /**\r\n     * Creates a calendar based around a given unit optionally focused around a\r\n     * given day.\r\n     *\r\n     * @param type The unit of the calendar.\r\n     * @param days The number of units in the calendar.\r\n     * @param around The day to focus the calendar on.\r\n     * @param focus The value which describes how months are added around the given\r\n     *    day. The default value will center the calendar around the given day.\r\n     *    When the value is `0` the given day is the first day in the calendar,\r\n     *    and when the value is `1` the given day is the last day in the calendar.\r\n     * @param input The default properties for the calendar.\r\n     * @returns A new calendar instance.\r\n     */\r\n    Calendar.forType = function (type, size, around, focus, input) {\r\n        if (size === void 0) { size = 1; }\r\n        if (around === void 0) { around = Day_Day.today(); }\r\n        if (focus === void 0) { focus = 0.49999; }\r\n        var meta = this.TYPES[type];\r\n        var start = meta.getStart(around, size, focus);\r\n        var end = meta.getEnd(start, size, focus);\r\n        return new Calendar(start, end, type, size, meta.moveStart, meta.moveEnd, input || meta.defaultInput);\r\n    };\r\n    /**\r\n     * Creates a calendar based around days optionally focused around a given day.\r\n     *\r\n     * @param days The number of days in the calendar.\r\n     * @param around The day to focus the calendar on.\r\n     * @param focus The value which describes how days are added around the given\r\n     *    day. The default value will center the calendar around the given day.\r\n     *    When the value is `0` the given day is the first day in the calendar,\r\n     *    and when the value is `1` the given day is the last day in the calendar.\r\n     * @param input The default properties for the calendar.\r\n     * @returns A new calendar instance.\r\n     * @see [[Calendar.forType]]\r\n     */\r\n    Calendar.days = function (days, around, focus, input) {\r\n        if (days === void 0) { days = 1; }\r\n        if (around === void 0) { around = Day_Day.today(); }\r\n        if (focus === void 0) { focus = 0.4999; }\r\n        return this.forType(Units.DAY, days, around, focus, input);\r\n    };\r\n    /**\r\n     * Creates a calendar based around weeks optionally focused around a given day.\r\n     *\r\n     * @param days The number of weeks in the calendar.\r\n     * @param around The day to focus the calendar on.\r\n     * @param focus The value which describes how weeks are added around the given\r\n     *    day. The default value will center the calendar around the given day.\r\n     *    When the value is `0` the given day is the first day in the calendar,\r\n     *    and when the value is `1` the given day is the last day in the calendar.\r\n     * @param input The default properties for the calendar.\r\n     * @returns A new calendar instance.\r\n     * @see [[Calendar.forType]]\r\n     */\r\n    Calendar.weeks = function (weeks, around, focus, input) {\r\n        if (weeks === void 0) { weeks = 1; }\r\n        if (around === void 0) { around = Day_Day.today(); }\r\n        if (focus === void 0) { focus = 0.4999; }\r\n        return this.forType(Units.WEEK, weeks, around, focus, input);\r\n    };\r\n    /**\r\n     * Creates a calendar based around months optionally focused around a given day.\r\n     *\r\n     * @param days The number of months in the calendar.\r\n     * @param around The day to focus the calendar on.\r\n     * @param focus The value which describes how months are added around the given\r\n     *    day. The default value will center the calendar around the given day.\r\n     *    When the value is `0` the given day is the first day in the calendar,\r\n     *    and when the value is `1` the given day is the last day in the calendar.\r\n     * @param input The default properties for the calendar.\r\n     * @returns A new calendar instance.\r\n     * @see [[Calendar.forType]]\r\n     */\r\n    Calendar.months = function (months, around, focus, input) {\r\n        if (months === void 0) { months = 1; }\r\n        if (around === void 0) { around = Day_Day.today(); }\r\n        if (focus === void 0) { focus = 0.4999; }\r\n        return this.forType(Units.MONTH, months, around, focus, input);\r\n    };\r\n    /**\r\n     * Creates a calendar based around years optionally focused around a given day.\r\n     *\r\n     * @param days The number of years in the calendar.\r\n     * @param around The day to focus the calendar on.\r\n     * @param focus The value which describes how years are added around the given\r\n     *    day. The default value will center the calendar around the given day.\r\n     *    When the value is `0` the given day is the first day in the calendar,\r\n     *    and when the value is `1` the given day is the last day in the calendar.\r\n     * @param input The default properties for the calendar.\r\n     * @returns A new calendar instance.\r\n     * @see [[Calendar.forType]]\r\n     */\r\n    Calendar.years = function (years, around, focus, input) {\r\n        if (years === void 0) { years = 1; }\r\n        if (around === void 0) { around = Day_Day.today(); }\r\n        if (focus === void 0) { focus = 0.4999; }\r\n        return this.forType(Units.YEAR, years, around, focus, input);\r\n    };\r\n    /**\r\n     * A map of functions and properties by [[Units]] used to create or morph\r\n     * Calendars.\r\n     */\r\n    Calendar.TYPES = (Calendar__a = {},\r\n        Calendar__a[Units.DAY] = {\r\n            getStart: function (around, size, focus) {\r\n                return around.start().relativeDays(-Math.floor(size * focus));\r\n            },\r\n            getEnd: function (start, size, focus) {\r\n                return start.relativeDays(size - 1).end();\r\n            },\r\n            moveStart: function (day, amount) {\r\n                return day.relativeDays(amount);\r\n            },\r\n            moveEnd: function (day, amount) {\r\n                return day.relativeDays(amount);\r\n            },\r\n            defaultInput: undefined\r\n        },\r\n        Calendar__a[Units.WEEK] = {\r\n            getStart: function (around, size, focus) {\r\n                return around.start().startOfWeek().relativeWeeks(-Math.floor(size * focus));\r\n            },\r\n            getEnd: function (start, size, focus) {\r\n                return start.relativeWeeks(size - 1).endOfWeek();\r\n            },\r\n            moveStart: function (day, amount) {\r\n                return day.relativeWeeks(amount);\r\n            },\r\n            moveEnd: function (day, amount) {\r\n                return day.relativeWeeks(amount);\r\n            },\r\n            defaultInput: undefined\r\n        },\r\n        Calendar__a[Units.MONTH] = {\r\n            getStart: function (around, size, focus) {\r\n                return around.start().startOfMonth().relativeMonths(-Math.floor(size * focus));\r\n            },\r\n            getEnd: function (start, size, focus) {\r\n                return start.relativeMonths(size - 1).endOfMonth();\r\n            },\r\n            moveStart: function (day, amount) {\r\n                return day.relativeMonths(amount);\r\n            },\r\n            moveEnd: function (day, amount) {\r\n                return day.startOfMonth().relativeMonths(amount).endOfMonth();\r\n            },\r\n            defaultInput: { fill: true }\r\n        },\r\n        Calendar__a[Units.YEAR] = {\r\n            getStart: function (around, size, focus) {\r\n                return around.start().startOfYear().relativeYears(-Math.floor(size * focus));\r\n            },\r\n            getEnd: function (start, size, focus) {\r\n                return start.relativeYears(size - 1).endOfYear();\r\n            },\r\n            moveStart: function (day, amount) {\r\n                return day.relativeYears(amount);\r\n            },\r\n            moveEnd: function (day, amount) {\r\n                return day.relativeYears(amount);\r\n            },\r\n            defaultInput: { fill: true }\r\n        },\r\n        Calendar__a);\r\n    return Calendar;\r\n}());\r\n\r\nvar Calendar__a;\r\n\n// CONCATENATED MODULE: ./src/Month.ts\n\r\n/**\r\n * The months in a year.\r\n */\r\nvar Month = (function () {\r\n    function Month() {\r\n    }\r\n    Month.JANUARY = 0;\r\n    Month.FEBRUARY = 1;\r\n    Month.MARCH = 2;\r\n    Month.APRIL = 3;\r\n    Month.MAY = 4;\r\n    Month.JUNE = 5;\r\n    Month.JULY = 6;\r\n    Month.AUGUST = 7;\r\n    Month.SEPTEMBER = 8;\r\n    Month.OCTOBER = 9;\r\n    Month.NOVEMBER = 10;\r\n    Month.DECEMBER = 11;\r\n    /**\r\n     * The full list of months in a year.\r\n     */\r\n    Month.LIST = [\r\n        Month.JANUARY,\r\n        Month.FEBRUARY,\r\n        Month.MARCH,\r\n        Month.APRIL,\r\n        Month.MAY,\r\n        Month.JUNE,\r\n        Month.JULY,\r\n        Month.AUGUST,\r\n        Month.SEPTEMBER,\r\n        Month.OCTOBER,\r\n        Month.NOVEMBER,\r\n        Month.DECEMBER\r\n    ];\r\n    return Month;\r\n}());\r\n\r\n\n// CONCATENATED MODULE: ./src/Weekday.ts\n\r\n/**\r\n * The days in a week.\r\n */\r\nvar Weekday = (function () {\r\n    function Weekday() {\r\n    }\r\n    Weekday.SUNDAY = 0;\r\n    Weekday.MONDAY = 1;\r\n    Weekday.TUESDAY = 2;\r\n    Weekday.WEDNESDAY = 3;\r\n    Weekday.THURSDAY = 4;\r\n    Weekday.FRIDAY = 5;\r\n    Weekday.SATURDAY = 6;\r\n    /**\r\n     * The full list of days in a week.\r\n     */\r\n    Weekday.LIST = [\r\n        Weekday.SUNDAY,\r\n        Weekday.MONDAY,\r\n        Weekday.TUESDAY,\r\n        Weekday.WEDNESDAY,\r\n        Weekday.THURSDAY,\r\n        Weekday.FRIDAY,\r\n        Weekday.SATURDAY\r\n    ];\r\n    /**\r\n     * The list of days starting with Monday and ending on Friday.\r\n     */\r\n    Weekday.WEEK = [\r\n        Weekday.MONDAY,\r\n        Weekday.TUESDAY,\r\n        Weekday.WEDNESDAY,\r\n        Weekday.THURSDAY,\r\n        Weekday.FRIDAY\r\n    ];\r\n    /**\r\n     * The days on the weekend, starting with Saturday and ending with Sunday.\r\n     */\r\n    Weekday.ENDS = [\r\n        Weekday.SATURDAY,\r\n        Weekday.SUNDAY\r\n    ];\r\n    return Weekday;\r\n}());\r\n\r\n\n// CONCATENATED MODULE: ./src/Pattern.ts\n\r\n\r\n\r\n\r\n\r\n/**\r\n * A class which helps describe [[ScheduleInput]] if it matches a pattern.\r\n */\r\nvar Pattern_Pattern = (function () {\r\n    /**\r\n     * Creates a new pattern.\r\n     *\r\n     * @param name The unique name of the pattern.\r\n     * @param listed If the pattern is \"listed\" [[Pattern.listed]].\r\n     * @param describe A function to describe the pattern given a [[Day]].\r\n     * @param rules The rules which describe how to detect and apply the pattern\r\n     *    to schedule input.\r\n     */\r\n    function Pattern(name, listed, describe, rules) {\r\n        this.name = name;\r\n        this.listed = listed;\r\n        this.describe = describe;\r\n        this.rules = rules;\r\n    }\r\n    /**\r\n     * Applies this pattern to a [[Schedule]] or [[ScheduleInput]] removing and\r\n     * adding any necessary properties from the input to match this pattern -\r\n     * based around the day provided.\r\n     *\r\n     * @param schedule The schedule to update to match this pattern.\r\n     * @param day The day to base the schedule on.\r\n     * @returns The reference to the input passed in.\r\n     */\r\n    Pattern.prototype.apply = function (schedule, day) {\r\n        if (schedule instanceof Schedule_Schedule) {\r\n            this.applyGeneric(day, function (prop, frequency) { return schedule.setFrequency(prop, frequency); }, function (prop) { return schedule.setFrequency(prop); });\r\n            schedule.updateChecks();\r\n        }\r\n        else {\r\n            this.applyGeneric(day, function (prop, frequency) { return schedule[prop] = frequency; }, function (prop) { return delete schedule[prop]; });\r\n        }\r\n        return schedule;\r\n    };\r\n    /**\r\n     * Applies this pattern to any object provided they implement the\r\n     * `setFrequency` and `removeFrequency` functions.\r\n     *\r\n     * @param day The day to base the schedule on.\r\n     * @param setFrequency The function which sets the frequency on the object.\r\n     * @param removeFrequency The function to remove a frequency from the object.\r\n     */\r\n    Pattern.prototype.applyGeneric = function (day, setFrequency, removeFrequency) {\r\n        for (var _i = 0, _a = Pattern.PROPS; _i < _a.length; _i++) {\r\n            var prop = _a[_i];\r\n            var rule = this.rules[prop];\r\n            // Should have one value\r\n            if (rule === 1) {\r\n                setFrequency(prop, [day[prop]]);\r\n            }\r\n            // Can be any of the values in the array\r\n            if (Functions.isArray(rule)) {\r\n                setFrequency(prop, rule);\r\n            }\r\n            // Must not be present\r\n            if (!Functions.isDefined(rule)) {\r\n                removeFrequency(prop);\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Determines whether the given [[Schedule]] or [[ScheduleInput]] matches this\r\n     * pattern. Optionally a day can be provided to make sure the day matches the\r\n     * schedule and pattern together.\r\n     *\r\n     * @param schedule The schedule input to test.\r\n     * @param exactlyWith A day to further validate against for matching.\r\n     * @returns `true` if the schedule was a match to this pattern with the\r\n     *    day if one was provided, otherwise `false`.\r\n     */\r\n    Pattern.prototype.isMatch = function (schedule, exactlyWith) {\r\n        if (schedule instanceof Schedule_Schedule) {\r\n            return this.isMatchGeneric(function (prop) { return schedule[prop].input; }, exactlyWith);\r\n        }\r\n        else {\r\n            return this.isMatchGeneric(function (prop) { return schedule[prop]; }, exactlyWith);\r\n        }\r\n    };\r\n    /**\r\n     * Determines whether the given input matches this pattern. Optionally a day\r\n     * can be provided to make sure the day matches the schedule and pattern\r\n     * together.\r\n     *\r\n     * @param input The schedule input to test.\r\n     * @param exactlyWith A day to further validate against for matching.\r\n     * @returns `true` if the schedule input was a match to this pattern with the\r\n     *    day if one was provided, otherwise `false`.\r\n     */\r\n    Pattern.prototype.isMatchGeneric = function (getFrequency, exactlyWith) {\r\n        var exactly = Functions.isDefined(exactlyWith);\r\n        for (var _i = 0, _a = Pattern.PROPS; _i < _a.length; _i++) {\r\n            var prop = _a[_i];\r\n            var rule = this.rules[prop];\r\n            var curr = getFrequency(prop);\r\n            // Optional, skip it\r\n            if (rule === false) {\r\n                continue;\r\n            }\r\n            // Requires any value\r\n            if (rule === true && !curr) {\r\n                return false;\r\n            }\r\n            // Must not be present\r\n            if (!Functions.isDefined(rule) && curr) {\r\n                return false;\r\n            }\r\n            // Must be an array of the same size\r\n            if (Functions.isNumber(rule)) {\r\n                if (Functions.isArray(curr) && curr.length === rule) {\r\n                    if (exactly && curr.indexOf(exactlyWith[prop]) === -1) {\r\n                        return false;\r\n                    }\r\n                }\r\n                else {\r\n                    return false;\r\n                }\r\n            }\r\n            // Must be an array of the same values\r\n            if (Functions.isArray(rule)) {\r\n                if (!Functions.isArray(curr)) {\r\n                    return false;\r\n                }\r\n                if (rule.length !== curr.length) {\r\n                    return false;\r\n                }\r\n                for (var i = 0; i < rule.length; i++) {\r\n                    if (rule[i] !== curr[i]) {\r\n                        return false;\r\n                    }\r\n                }\r\n                if (exactly && rule.indexOf(exactlyWith[prop]) === -1) {\r\n                    return false;\r\n                }\r\n            }\r\n            // Must be an object with same over & offset.\r\n            if (Functions.isObject(rule)) {\r\n                if (!Functions.isObject(curr)) {\r\n                    return false;\r\n                }\r\n                var ruleOffset = rule.offset || 0;\r\n                var currOffset = curr.offset || 0;\r\n                if (currOffset !== ruleOffset || curr.every !== rule.every) {\r\n                    return false;\r\n                }\r\n                if (exactly && (exactlyWith[prop] % rule.every) !== ruleOffset) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    };\r\n    /**\r\n     * Returns the pattern with the given name if one exists. If you add your own\r\n     * patterns make sure to add them to [[PatternMap]].\r\n     *\r\n     * @param name The name of the pattern to return.\r\n     * @return The instance to the pattern with the same name.\r\n     */\r\n    Pattern.withName = function (name) {\r\n        return PatternMap[name];\r\n    };\r\n    /**\r\n     * Finds a matching pattern to the given input searching through [[Patterns]]\r\n     * for matches. Optionally it will only look at patterns where listed = `true`.\r\n     *\r\n     * @param input The schedule input to use.\r\n     * @param listedOnly When `true` only patterns with [[Pattern.listed]] set to\r\n     *    `true` will be looked at, otherwise all patterns are looked at.\r\n     * @param exactlyWith  A day to further validate against for matching.\r\n     * @see [[Pattern.isMatch]]\r\n     */\r\n    Pattern.findMatch = function (input, listedOnly, exactlyWith) {\r\n        if (listedOnly === void 0) { listedOnly = true; }\r\n        for (var _i = 0, Patterns_1 = Patterns; _i < Patterns_1.length; _i++) {\r\n            var pattern = Patterns_1[_i];\r\n            if ((pattern.listed || !listedOnly) && pattern.isMatch(input, exactlyWith)) {\r\n                return pattern;\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    /**\r\n     * The properties in the [[ScheduleInput]] which are compared against the\r\n     * rules of a pattern.\r\n     */\r\n    Pattern.PROPS = [\r\n        'dayOfWeek', 'dayOfMonth', 'lastDayOfMonth', 'dayOfYear',\r\n        'month', 'week', 'year',\r\n        'weekOfYear', 'weekspanOfYear', 'fullWeekOfYear', 'lastWeekspanOfYear', 'lastFullWeekOfYear',\r\n        'weekOfMonth', 'weekspanOfMonth', 'fullWeekOfMonth', 'lastWeekspanOfMonth', 'lastFullWeekOfMonth'\r\n    ];\r\n    return Pattern;\r\n}());\r\n\r\n/**\r\n * The list of patterns that can be searched through for matches to schedule\r\n * input.\r\n *\r\n * @see [[Pattern.findMatch]]\r\n */\r\nvar Patterns = [\r\n    new Pattern_Pattern('none', true, function (day) { return 'Does not repeat'; }, {\r\n        year: 1,\r\n        month: 1,\r\n        dayOfMonth: 1\r\n    }),\r\n    new Pattern_Pattern('daily', true, function (day) { return 'Daily'; }, {}),\r\n    new Pattern_Pattern('weekly', true, function (day) { return 'Weekly on ' + day.format('dddd'); }, {\r\n        dayOfWeek: 1\r\n    }),\r\n    new Pattern_Pattern('monthlyWeek', true, function (day) { return 'Monthly on the ' + Suffix.CACHE[day.weekspanOfMonth + 1] + ' ' + day.format('dddd'); }, {\r\n        dayOfWeek: 1,\r\n        weekspanOfMonth: 1\r\n    }),\r\n    new Pattern_Pattern('annually', true, function (day) { return 'Annually on ' + day.format('MMMM Do'); }, {\r\n        month: 1,\r\n        dayOfMonth: 1\r\n    }),\r\n    new Pattern_Pattern('annuallyMonthWeek', true, function (day) { return 'Annually on the ' + Suffix.CACHE[day.weekspanOfMonth + 1] + ' ' + day.format('dddd') + ' of ' + day.format('MMMM'); }, {\r\n        month: 1,\r\n        dayOfWeek: 1,\r\n        weekspanOfMonth: 1\r\n    }),\r\n    new Pattern_Pattern('weekday', true, function (day) { return 'Every weekday (Monday to Friday)'; }, {\r\n        dayOfWeek: [Weekday.MONDAY, Weekday.TUESDAY, Weekday.WEDNESDAY, Weekday.THURSDAY, Weekday.FRIDAY]\r\n    }),\r\n    new Pattern_Pattern('monthly', true, function (day) { return 'Monthly on the ' + day.format('Do') + ' day'; }, {\r\n        dayOfMonth: 1\r\n    }),\r\n    new Pattern_Pattern('custom', true, function (day) { return 'Custom...'; }, {\r\n        dayOfWeek: false,\r\n        dayOfMonth: false,\r\n        lastDayOfMonth: false,\r\n        dayOfYear: false,\r\n        year: false,\r\n        month: false,\r\n        week: false,\r\n        weekOfYear: false,\r\n        weekspanOfYear: false,\r\n        fullWeekOfYear: false,\r\n        lastWeekspanOfYear: false,\r\n        lastFullWeekOfYear: false,\r\n        weekOfMonth: false,\r\n        weekspanOfMonth: false,\r\n        fullWeekOfMonth: false,\r\n        lastWeekspanOfMonth: false,\r\n        lastFullWeekOfMonth: false\r\n    })\r\n];\r\n/**\r\n * The map of patterns keyed by their name.\r\n *\r\n * @see [[Pattern.withName]]\r\n */\r\nvar PatternMap = {};\r\nfor (var Pattern__i = 0, Patterns_2 = Patterns; Pattern__i < Patterns_2.length; Pattern__i++) {\r\n    var Pattern_pattern = Patterns_2[Pattern__i];\r\n    PatternMap[Pattern_pattern.name] = Pattern_pattern;\r\n}\r\n\n// CONCATENATED MODULE: ./src/Sort.ts\n\r\n/**\r\n * A class with [[SortEvent]] functions and functions which accept other\r\n * [[SortEvent]]s and return a new [[SortEvent]].\r\n *\r\n * ```typescript\r\n * // Sorts full day events first, then events in descending order based on start time.\r\n * Sorts.List([Sorts.FullDay, Sorts.Desc(Sorts.Start)]);\r\n * ```\r\n */\r\nvar Sorts = (function () {\r\n    function Sorts() {\r\n    }\r\n    /**\r\n     * Sorts the two events by their start time - the earliest event being first\r\n     * in order.\r\n     *\r\n     * @param a The first event.\r\n     * @param b The second event.\r\n     * @returns The difference in time between the start of `a` and `b`.\r\n     * @see [[CalendarEvent.time]]\r\n     */\r\n    Sorts.Start = function (a, b) {\r\n        return a.time.start.time - b.time.start.time;\r\n    };\r\n    /**\r\n     * Sorts the two events by their end time - the earliest to end being first\r\n     * in order.\r\n     *\r\n     * @param a The first event.\r\n     * @param b The second event.\r\n     * @returns The difference in time between the end of `a` and `b`.\r\n     * @see [[CalendarEvent.time]]\r\n     */\r\n    Sorts.End = function (a, b) {\r\n        return a.time.end.time - b.time.end.time;\r\n    };\r\n    /**\r\n     * Sorts the two events placing the full day events before the timed events.\r\n     *\r\n     * @param a The first event.\r\n     * @param b The second event.\r\n     * @returns If both are timed or both are full day then `0` is returned,\r\n     *    otherwise `-1` is returned if `a` is full day and `1` is returned if\r\n     *    `b` is full day.\r\n     * @see [[CalendarEvent.fullDay]]\r\n     */\r\n    Sorts.FullDay = function (a, b) {\r\n        var af = a.fullDay ? 0 : 1;\r\n        var bf = b.fullDay ? 0 : 1;\r\n        return af - bf;\r\n    };\r\n    /**\r\n     * Sorts the two events placing the shorter events before the longer events.\r\n     * Full day or multiple day events actually take up a day and will be ordered\r\n     * last.\r\n     *\r\n     * @param a The first event.\r\n     * @param b The second event.\r\n     * @returns The difference in milliseconds between `a` and `b`.\r\n     * @see [[CalendarEvent.time]]\r\n     * @see [[DaySpan.millis]]\r\n     */\r\n    Sorts.Duration = function (a, b) {\r\n        return a.time.millis() - b.time.millis();\r\n    };\r\n    /**\r\n     * Returns a [[SortEvent]] that effectively orders the given sorter in the\r\n     * opposite (often descending) order.\r\n     *\r\n     * @param sorter The sorter to reverse.\r\n     * @returns A new sorter which reverses the one passed in.\r\n     */\r\n    Sorts.Desc = function (sorter) {\r\n        return function (a, b) {\r\n            return sorter(b, a);\r\n        };\r\n    };\r\n    /**\r\n     * Returns a [[SortEvent]] that orders the events based on a string in each\r\n     * event. A function must be supplied which takes an event of type `T` and\r\n     * returns a string.\r\n     *\r\n     * @param getString A function which returns a string from the event.\r\n     * @returns A sorter which sorts strings alphabetically.\r\n     */\r\n    Sorts.Alphabetical = function (getString) {\r\n        return function (a, b) {\r\n            var as = getString(a.event) || '';\r\n            var bs = getString(b.event) || '';\r\n            return as.localeCompare(bs);\r\n        };\r\n    };\r\n    /**\r\n     * Returns a [[SortEvent]] that orders events based on a number in each event.\r\n     * A function must be supplied which takes an event of type `T` and returns\r\n     * a number.\r\n     *\r\n     * @param getOrder A function which returns a number from the event.\r\n     * @returns A sorter which sorts events based on a number in ascending order.\r\n     */\r\n    Sorts.Ordered = function (getOrder) {\r\n        return function (a, b) {\r\n            var ao = getOrder(a.event);\r\n            var bo = getOrder(b.event);\r\n            return ao - bo;\r\n        };\r\n    };\r\n    /**\r\n     * Returns a [[SortEvent]] that orders events based on an array of sorters.\r\n     * The first sorter which returns a non-zero result is used.\r\n     *\r\n     * @param sorters A list of sorting functions to test one at a time.\r\n     * @returns A sorter which sorts based on a list of sorters.\r\n     */\r\n    Sorts.List = function (sorters) {\r\n        return function (a, b) {\r\n            for (var _i = 0, sorters_1 = sorters; _i < sorters_1.length; _i++) {\r\n                var sorter = sorters_1[_i];\r\n                var compare = sorter(a, b);\r\n                if (compare !== 0) {\r\n                    return compare;\r\n                }\r\n            }\r\n            return 0;\r\n        };\r\n    };\r\n    return Sorts;\r\n}());\r\n\r\n\n// CONCATENATED MODULE: ./src/index.ts\n/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, \"Calendar\", function() { return Calendar_Calendar; });\n/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, \"CalendarDay\", function() { return CalendarDay_CalendarDay; });\n/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, \"CalendarEvent\", function() { return CalendarEvent_CalendarEvent; });\n/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, \"Event\", function() { return Event; });\n/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, \"Constants\", function() { return Constants; });\n/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, \"Day\", function() { return Day_Day; });\n/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, \"DaySpan\", function() { return DaySpan_DaySpan; });\n/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, \"Functions\", function() { return Functions; });\n/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, \"Identifier\", function() { return Identifier_Identifier; });\n/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, \"IteratorAction\", function() { return IteratorAction; });\n/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, \"Iterator\", function() { return Iterator_Iterator; });\n/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, \"Month\", function() { return Month; });\n/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, \"Op\", function() { return Op; });\n/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, \"operate\", function() { return operate; });\n/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, \"Parse\", function() { return Parse_Parse; });\n/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, \"Pattern\", function() { return Pattern_Pattern; });\n/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, \"Patterns\", function() { return Patterns; });\n/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, \"PatternMap\", function() { return PatternMap; });\n/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, \"Schedule\", function() { return Schedule_Schedule; });\n/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, \"ScheduleModifier\", function() { return ScheduleModifier_ScheduleModifier; });\n/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, \"Sorts\", function() { return Sorts; });\n/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, \"Suffix\", function() { return Suffix; });\n/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, \"Time\", function() { return Time_Time; });\n/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, \"Units\", function() { return Units; });\n/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, \"Weekday\", function() { return Weekday; });\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// dayspan.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap e076d78c7afd9cb5feab","module.exports = __WEBPACK_EXTERNAL_MODULE_0__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"commonjs\":\"moment\",\"commonjs2\":\"moment\",\"amd\":\"moment\",\"root\":\"moment\"}\n// module id = 0\n// module chunks = 0","\n/**\n * An operation that can be performed on a single number.\n */\nexport enum Op\n{\n  /**\n   * The number is returned unmodified.\n   */\n  NONE,\n\n  /**\n   * The number is rounded down to the nearest whole number.\n   */\n  FLOOR,\n\n  /**\n   * The number is rounded up to the nearest whole number.\n   */\n  CEIL,\n\n  /**\n   * The number is rounded up or down depending on if the fractional value is\n   * greater than or less than 0.5 respectively.\n   */\n  ROUND,\n\n  /**\n   * The fractional part of the number is dropped.\n   */\n  TRUNCATE,\n\n  /**\n   * The number is rounded up when positive and down when negative. This is\n   * effectively ceiling the absolute value where the result preserves the sign.\n   */\n  UP,\n\n  /**\n   * The number is rounded down when positive and up when negative. This is\n   * effectively floor the absolute value where the result preserves the sign.\n   */\n  DOWN\n}\n\n\n/**\n * Performs the requested operation on the given number, optionally taking\n * the absolute value of the number before the operation.\n *\n * @param value The number to operate on.\n * @param op The operation to perform.\n * @param absolute If the number should be positive before the operation.\n * @return The operated result, or the original value if its not a valid number.\n */\nexport function operate(value: number, op: Op, absolute: boolean = false)\n{\n  if (isFinite(value))\n  {\n    if (absolute)\n    {\n      value = Math.abs( value );\n    }\n\n    switch (op)\n    {\n    case Op.NONE:\n      return value;\n    case Op.FLOOR:\n      return Math.floor( value );\n    case Op.CEIL:\n      return Math.ceil( value );\n    case Op.ROUND:\n      return Math.round( value );\n    case Op.TRUNCATE:\n    case Op.DOWN:\n      return value < 0 ? Math.ceil( value ) : Math.floor( value );\n    case Op.UP:\n      return value < 0 ? Math.floor( value ) : Math.ceil( value );\n    }\n  }\n\n  return value;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/Operation.ts","\n\n/**\n * The class which contains commonly used functions by the library. These\n * functions and variables exist in a class so they may be overridden if\n * desired.\n */\nexport class Functions\n{\n\n  /**\n   * Determines whether the given input is an array.\n   *\n   * @param input The variable to test.\n   * @returns `true` if the variable is an array, otherwise `false`.\n   */\n  public static isArray(input: any): boolean\n  {\n    return input instanceof Array;\n  }\n\n  /**\n   * Determines whether the two arrays given are stricly equivalent. If the\n   * arrays are not the same length or contain the same values in the same order\n   * then `false` is returned.\n   *\n   * @param x The first array to test.\n   * @param y The second array to test.\n   * @returns `true` if they have the same exact values, otherwise `false`.\n   */\n  public static isArrayEquals(x: any[], y: any[]): boolean\n  {\n    if (x === y) return true;\n    if (x.length !== y.length) return false;\n\n    for (let i = 0; i < x.length; i++)\n    {\n      if (x[ i ] !== y[ i ])\n      {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Determines whether the given input is a string.\n   *\n   * @param input The variable to test.\n   * @returns `true` if the variable is a string, otherwise `false`.\n   */\n  public static isString(input: any): boolean\n  {\n    return typeof(input) === 'string';\n  }\n\n  /**\n   * Determines whether the given input is a finite number (a number which is\n   * not infinite or not the result of a divide-by-zero operation).\n   *\n   * @param input The variable to test.\n   * @returns `true` if the variable is a finite number, otherwise `false`.\n   */\n  public static isNumber(input: any): boolean\n  {\n    return isFinite(input) && typeof input === 'number';\n  }\n\n  /**\n   * Determines whether the given input is an object and NOT an array.\n   *\n   * @param input The variable to test.\n   * @returns `true` if the variable is a plain object, otherwise `false`.\n   */\n  public static isObject(input: any): boolean\n  {\n    return input !== null && !this.isArray(input) && typeof(input) === 'object';\n  }\n\n  /**\n   * Determines whether the given input is defined.\n   *\n   * @param input The variable to test.\n   * @return `true` if the variable is defined, otherwise `false`.\n   */\n  public static isDefined(input: any): boolean\n  {\n    return typeof(input) !== 'undefined';\n  }\n\n  /**\n   * Determines whether the given input is defined and not null.\n   *\n   * @param input The variable to test.\n   * @return `true` if the variable is defined and not null, otherwise `false`.\n   */\n  public static isValue(input: any): boolean\n  {\n    return input !== null && typeof(input) !== 'undefined';\n  }\n\n  /**\n   * Determines whether the given input appears to be a valid\n   * [[FrequencyValueEvery]].\n   *\n   * ```typescript\n   * Functions.isFrequencyValueEvery({});                   // false\n   * Functions.isFrequencyValueEvery([]);                   // false\n   * Functions.isFrequencyValueEvery([1]);                  // false\n   * Functions.isFrequencyValueEvery(null);                 // false\n   * Functions.isFrequencyValueEvery({every:2});            // true\n   * Functions.isFrequencyValueEvery({offset:1});           // false\n   * Functions.isFrequencyValueEvery({every:2, offset:1});  // true\n   * ```\n   *\n   * @param input The variable to test.\n   * @returns `true` if the variable appears to be a [[FrequencyValueEvery]],\n   *    otherwise false.\n   */\n  public static isFrequencyValueEvery(input: any): boolean\n  {\n    return this.isObject( input ) && this.isNumber( input.every );\n  }\n\n  /**\n   * Determines whether the given input appears to be a valid\n   * [[FrequencyValueOneOf]].\n   *\n   * ```typescript\n   * Functions.isFrequencyValueOneOf({});    // false\n   * Functions.isFrequencyValueOneOf([]);    // false\n   * Functions.isFrequencyValueOneOf([1]);   // true\n   * Functions.isFrequencyValueOneOf(null);  // false\n   * ```\n   *\n   * @param input The variable to test.\n   * @returns `true` if the variable appears to be a [[FrequencyValueOneOf]],\n   *    otherwise false.\n   */\n  public static isFrequencyValueOneOf(input: any): boolean\n  {\n    return this.isArray( input ) && input.length > 0;\n  }\n\n  /**\n   * Returns the first argument which is defined.\n   *\n   * ```typescript\n   * Functions.coalesce(3, 4);                // 3\n   * Functions.coalesce(undefined, 4);        // 4\n   * Functions.coalesce(null, 4);             // null\n   * Functions.coalesce(void 0, void 0, 5);   // 5\n   * ```\n   *\n   * @param a The first argument to look at.\n   * @param b The second argument to look at.\n   * @returns The first defined argument.\n   * @see [[Functions.isDefined]]\n   */\n  public static coalesce(a: any, b: any, c?: any): any\n  {\n    return this.isDefined( a ) ? a : (this.isDefined( b ) ? b : c);\n  }\n\n  /**\n   * Copies values from `from` object and sets them to the `target` object.\n   *\n   * @param target The object to set values to.\n   * @param from The object to copy value references from.\n   * @returns The reference to `target`.\n   */\n  public static extend(target: any, from: any): any\n  {\n    for (let prop in from)\n    {\n      target[ prop ] = from[ prop ];\n    }\n\n    return target;\n  }\n\n  /**\n   * Pads the string `x` up to `length` characters with the given `padding`\n   * optionally placing the `padding` `before` `x`.\n   *\n   * ```typescript\n   * Functions.pad('hey', 5, '_', false);   // 'hey__'\n   * Functions.pad('hey', 5, '_', true);    // '__hey'\n   * Functions.pad('heyman', 5, '_', true); // 'heyman'\n   * ```\n   *\n   * @param x The string to pad.\n   * @param length The length to pad to.\n   * @param padding The string to pad with.\n   * @param before If the padding should go before the string to pad.\n   * @returns The padded string if any padding needed be added.\n   */\n  public static pad(x: string, length: number, padding: string, before: boolean): string\n  {\n    while (x.length < length)\n    {\n      before ? x = padding + x : x = x + padding;\n    }\n\n    return x;\n  }\n\n  /**\n   * Pads the number `x` up to `length` digits where the padding is `0` and it\n   * goes before `x`. This function will only return the first `length`\n   * characters of the padding string representation of the number but can return\n   * an alternative number of `first` characters.\n   *\n   * ```typescript\n   * Functions.padNumber(29, 3);      // '029'\n   * Functions.padNumber(29, 3, 2);   // '02'\n   * Functions.padNumber(9573, 3);    // '957'\n   * ```\n   *\n   * @param x The number to pad with zeros in the beginning.\n   * @param length The number of digits the number should be padded to.\n   * @param first The number of digits to return from the start of the string.\n   * @returns A padded number.\n   */\n  public static padNumber(x: number, length: number, first: number = length)\n  {\n    return this.pad(x + '', length, '0', true).substring( 0, first );\n  }\n\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/Functions.ts","\n\n/**\n * Units of time that are compromised of 1 or more days for the [[Calendar]] class.\n */\nexport enum Units\n{\n  DAY,\n  WEEK,\n  MONTH,\n  YEAR\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/Units.ts","\n\n/**\n * A class that stores commonly used values.\n */\nexport class Constants\n{\n\n  /**\n   * The number of milliseconds in a second.\n   */\n  public static MILLIS_IN_SECOND: number = 1000;\n\n  /**\n   * The number of milliseconds in a minute.\n   */\n  public static MILLIS_IN_MINUTE: number = Constants.MILLIS_IN_SECOND * 60;\n\n  /**\n   * The number of milliseconds in an hour.\n   */\n  public static MILLIS_IN_HOUR: number = Constants.MILLIS_IN_MINUTE * 60;\n\n  /**\n   * The number of milliseconds in a day (not including DST days).\n   */\n  public static MILLIS_IN_DAY: number = Constants.MILLIS_IN_HOUR * 24;\n\n  /**\n   * The number of milliseconds in a week (not including ones that include DST).\n   */\n  public static MILLIS_IN_WEEK: number = Constants.MILLIS_IN_DAY * 7;\n\n  /**\n   * The number of minutes in an hour.\n   */\n  public static MINUTES_IN_HOUR = 60;\n\n  /**\n   * The number of minutes in a day (not including DST days).\n   */\n  public static MINUTES_IN_DAY = 60 * 24;\n\n  /**\n   * The number of days in a week.\n   */\n  public static DAYS_IN_WEEK: number = 7;\n\n\n  /**\n   * The number of months in a year.\n   */\n  public static MONTHS_IN_YEAR: number = 12;\n\n  /**\n   * The number of hours in a day (not including DST days).\n   */\n  public static HOURS_IN_DAY: number = 24;\n\n\n  /**\n   * The first month of the year.\n   */\n  public static MONTH_MIN: number = 0;\n\n  /**\n   * The last month of the year.\n   */\n  public static MONTH_MAX: number = 11;\n\n  /**\n   * The first day of a month.\n   */\n  public static DAY_MIN: number = 1;\n\n  /**\n   * The last day of the longest month.\n   */\n  public static DAY_MAX: number = 31;\n\n  /**\n   * The first hour of the day.\n   */\n  public static HOUR_MIN: number = 0;\n\n  /**\n   * The last hour of the day.\n   */\n  public static HOUR_MAX: number = 23;\n\n  /**\n   * The first minute of the hour.\n   */\n  public static MINUTE_MIN: number = 0;\n\n  /**\n   * The last minute of the hour.\n   */\n  public static MINUTE_MAX: number = 59;\n\n  /**\n   * The first second of the minute.\n   */\n  public static SECOND_MIN: number = 0;\n\n  /**\n   * The last second of the minute.\n   */\n  public static SECOND_MAX: number = 59;\n\n  /**\n   * The first millisecond of the second.\n   */\n  public static MILLIS_MIN: number = 0;\n\n  /**\n   * The last millisecond of the second.\n   */\n  public static MILLIS_MAX: number = 999;\n\n  /**\n   * The first day of the week.\n   */\n  public static WEEKDAY_MIN: number = 0;\n\n  /**\n   * The last day of the week.\n   */\n  public static WEEKDAY_MAX: number = 6;\n\n\n  /**\n   * The default duration for an event.\n   */\n  public static DURATION_DEFAULT: number = 1;\n\n  /**\n   * The default duration unit for an all day event.\n   */\n  public static DURATION_DEFAULT_UNIT_ALL: string = 'days';\n\n  /**\n   * The default duration unit for an event at a given time.\n   */\n  public static DURATION_DEFAULT_UNIT_TIMES: string = 'hours';\n\n  /**\n   * Computes the duration unit given its for an all day event.\n   *\n   * @param all If the event is all day.\n   * @return The default unit for the event.\n   */\n  public static DURATION_DEFAULT_UNIT: (all: boolean) => string =\n    all => all ? Constants.DURATION_DEFAULT_UNIT_ALL :\n                 Constants.DURATION_DEFAULT_UNIT_TIMES;\n\n  /**\n   * The number of milliseconds for various duration units. These are worse case\n   * scenario and do not include DST changes.\n   */\n  public static DURATION_TO_MILLIS = {\n    minute:   Constants.MILLIS_IN_MINUTE,\n    minutes:  Constants.MILLIS_IN_MINUTE,\n    hour:     Constants.MILLIS_IN_HOUR,\n    hours:    Constants.MILLIS_IN_HOUR,\n    day:      Constants.MILLIS_IN_DAY,\n    days:     Constants.MILLIS_IN_DAY,\n    week:     Constants.MILLIS_IN_WEEK,\n    weeks:    Constants.MILLIS_IN_WEEK,\n    month:    Constants.MILLIS_IN_DAY * Constants.DAY_MAX,\n    months:   Constants.MILLIS_IN_DAY * Constants.DAY_MAX\n  };\n\n  /**\n   * The maximum estimated number of events per day. This is used to calculate\n   * [[CalendarEvent.id]] to give each event a unique ID. If you think you will\n   * have more events than this per day, you can enlarge the value.\n   */\n  public static MAX_EVENTS_PER_DAY: number = 24;\n\n  /**\n   * The day of the week which determines the first week of the year or month.\n   * By default this day is Thursday.\n   */\n  public static WEEK_OF_MONTH_MINIMUM_WEEKDAY: number = 4;\n\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/Constants.ts","\nimport { Day } from './Day';\nimport { Op } from './Operation';\nimport { Units } from './Units';\nimport { Constants } from './Constants';\n\n\n\n/**\n * The calculated bounds of a DaySpan relative to a given day.\n */\nexport interface DaySpanBounds\n{\n\n  /**\n   * The top of the span within the rectangle of the given day.\n   */\n  top: number;\n\n  /**\n   * The bottom of the span within the rectangle of the givne day.\n   */\n  bottom: number;\n\n  /**\n   * The height of the span within the rectangle of the given day. This is\n   * equivalent by `bottom - top`.\n   */\n  height: number;\n\n  /**\n   * The left of the span within the rectangle of the given day.\n   */\n  left: number;\n\n  /**\n   * The right of the span within the rectangle of the given day.\n   */\n  right: number;\n\n  /**\n   * The width of the span within the rectangle of the given day. This is\n   * equivalent by `right - left`.\n   */\n  width: number;\n}\n\n/**\n * A class for a range of time between two [[Day]] timestamps.\n */\nexport class DaySpan\n{\n\n\n  /**\n   * The starting timestamp of the span (inclusive).\n   */\n  public start: Day;\n\n  /**\n   * The endind timestamp of the span (inclusive).\n   */\n  public end: Day;\n\n\n  /**\n   * Creates a new span of time.\n   *\n   * @param start The starting timestamp.\n   * @param end The ending timestamp.\n   */\n  public constructor(start: Day, end: Day)\n  {\n    this.start = start;\n    this.end = end;\n  }\n\n  /**\n   * Whether this span starts and ends on the same timestamp.\n   */\n  public get isPoint(): boolean\n  {\n    return this.start.time === this.end.time;\n  }\n\n  /**\n   * Determines whether the given timestamp lies between the start and end\n   * timestamp.\n   *\n   * @param day The timestamp to test.\n   * @returns True if the day is >= the start and <= the end of this span.\n   */\n  public contains(day: Day): boolean\n  {\n    return day.time >= this.start.time && day.time <= this.end.time;\n  }\n\n  /**\n   * Compares the given timestamp to this span. If the timestamp is before this\n   * span then `-1` is returned, if the timestamp is after this span then `1`\n   * us returned, otherwise `0` is returned when the timestamp is in this span.\n   *\n   * @param day The timestamp to compare to.\n   * @returns `-1`, `0`, or `1` depending on the given timestamp relative to\n   *    this span.\n   */\n  public compareTo(day: Day): number\n  {\n    return day.time < this.start.time ? -1 : (day.time > this.end.time ? 1 : 0);\n  }\n\n  /**\n   * Determines whether the given timestamp is between the start and end\n   * timestamp or lies on the same day as the start or end timestamp.\n   *\n   * @param day The timestamp to test.\n   * @see [[Day.sameDay]]\n   */\n  public matchesDay(day: Day): boolean\n  {\n    return this.contains( day ) || day.sameDay( this.start ) || day.sameDay( this.end );\n  }\n\n  /**\n   * Determines whether the given timestamp is between the start and end\n   * timestamp or lies on the same week as the start or end timestamp.\n   *\n   * @param day The timestamp to test.\n   * @see [[Day.sameWeek]]\n   */\n  public matchesWeek(day: Day): boolean\n  {\n    return this.contains( day ) || day.sameWeek( this.start ) || day.sameWeek( this.end );\n  }\n\n  /**\n   * Determines whether the given timestamp is between the start and end\n   * timestamp or lies on the same month as the start or end timestamp.\n   *\n   * @param day The timestamp to test.\n   * @see [[Day.sameMonth]]\n   */\n  public matchesMonth(day: Day): boolean\n  {\n    return this.contains( day ) || day.sameMonth( this.start ) || day.sameMonth( this.end );\n  }\n\n  /**\n   * Determines whether the given timestamp is between the start and end\n   * timestamp or lies on the same year as the start or end timestamp.\n   *\n   * @param day The timestamp to test.\n   * @see [[Day.sameYear]]\n   */\n  public matchesYear(day: Day): boolean\n  {\n    return this.contains( day ) || day.sameYear( this.start ) || day.sameYear( this.end );\n  }\n\n\n  /**\n   * Calculates the number of milliseconds between the start and end timestamp.\n   *\n   * @param op The operation to perform on the result.\n   * @param absolute Whether the result should always be positive.\n   * @returns The time between the start and end timestamp.\n   * @see [[Day.millisBetween]]\n   */\n  public millis(op: Op = Op.DOWN, absolute: boolean = true): number\n  {\n    return this.start.millisBetween(this.end, op, absolute);\n  }\n\n  /**\n   * Calculates the number of seconds between the start and end timestamp.\n   *\n   * @param op The operation to perform on the result.\n   * @param absolute Whether the result should always be positive.\n   * @returns The time between the start and end timestamp.\n   * @see [[Day.secondsBetween]]\n   */\n  public seconds(op: Op = Op.DOWN, absolute: boolean = true): number\n  {\n    return this.start.secondsBetween(this.end, op, absolute);\n  }\n\n  /**\n   * Calculates the number of minutes between the start and end timestamp.\n   *\n   * @param op The operation to perform on the result.\n   * @param absolute Whether the result should always be positive.\n   * @returns The time between the start and end timestamp.\n   * @see [[Day.minutesBetween]]\n   */\n  public minutes(op: Op = Op.DOWN, absolute: boolean = true): number\n  {\n    return this.start.minutesBetween(this.end, op, absolute);\n  }\n\n  /**\n   * Calculates the number of hours between the start and end timestamp.\n   *\n   * @param op The operation to perform on the result.\n   * @param absolute Whether the result should always be positive.\n   * @returns The time between the start and end timestamp.\n   * @see [[Day.hoursBetween]]\n   */\n  public hours(op: Op = Op.DOWN, absolute: boolean = true): number\n  {\n    return this.start.hoursBetween(this.end, op, absolute);\n  }\n\n  /**\n   * Calculates the number of days between the start and end timestamp.\n   *\n   * @param op The operation to perform on the result.\n   * @param absolute Whether the result should always be positive.\n   * @returns The time between the start and end timestamp.\n   * @see [[Day.daysBetween]]\n   */\n  public days(op: Op = Op.DOWN, absolute: boolean = true): number\n  {\n    return this.start.daysBetween(this.end, op, absolute);\n  }\n\n  /**\n   * Calculates the number of weeks between the start and end timestamp.\n   *\n   * @param op The operation to perform on the result.\n   * @param absolute Whether the result should always be positive.\n   * @returns The time between the start and end timestamp.\n   * @see [[Day.weeksBetween]]\n   */\n  public weeks(op: Op = Op.DOWN, absolute: boolean = true): number\n  {\n    return this.start.weeksBetween(this.end, op, absolute);\n  }\n\n  /**\n   * Calculates the number of months between the start and end timestamp.\n   *\n   * @param op The operation to perform on the result.\n   * @param absolute Whether the result should always be positive.\n   * @returns The time between the start and end timestamp.\n   * @see [[Day.monthsBetween]]\n   */\n  public months(op: Op = Op.DOWN, absolute: boolean = true): number\n  {\n    return this.start.monthsBetween(this.end, op, absolute);\n  }\n\n  /**\n   * Calculates the number of years between the start and end timestamp.\n   *\n   * @param op The operation to perform on the result.\n   * @param absolute Whether the result should always be positive.\n   * @returns The time between the start and end timestamp.\n   * @see [[Day.yearsBetween]]\n   */\n  public years(op: Op = Op.DOWN, absolute: boolean = true): number\n  {\n    return this.start.yearsBetween(this.end, op, absolute);\n  }\n\n  /**\n   * Returns a delta value between 0 and 1 which represents where the\n   * [[DaySpan.start]] is relative to the given day. The delta value would\n   * be less than 0 if the start of the event is before the given day.\n   *\n   * @param relativeTo The day to find the start delta relative to.\n   * @return A number between 0 and 1 if the start of this span is in the\n   *    24-hour period starting at the given timestamp, otherwise the value\n   *    returned may be less than 0 or greater than 1.\n   */\n  public startDelta(relativeTo: Day): number\n  {\n    return (this.start.time - relativeTo.time) / Constants.MILLIS_IN_DAY;\n  }\n\n  /**\n   * Returns a delta value between 0 and 1 which represents where the\n   * [[DaySpan.end]] is relative to the given day. The delta value would\n   * be greater than 1 if the end of the event is after the given day.\n   *\n   * @param relativeTo The day to find the end delta relative to.\n   * @return A number between 0 and 1 if the end of this span is in the\n   *    24-hour period starting at the given timestamp, otherwise the value\n   *    returned may be less than 0 or greater than 1.\n   */\n  public endDelta(relativeTo: Day): number\n  {\n    return (this.end.time - relativeTo.time) / Constants.MILLIS_IN_DAY;\n  }\n\n  /**\n   * Calculates the bounds for span event if it were placed in a rectangle which\n   * represents a day (24 hour period). By default the returned values are\n   * between 0 and 1 and can be scaled by the proper rectangle dimensions or the\n   * rectangle dimensions can be passed to this function.\n   *\n   * @param relativeTo The day to find the bounds relative to. If this is not the\n   *    start of the day the returned bounds is relative to the given time.\n   * @param dayHeight The height of the rectangle of the day.\n   * @param dayWidth The width of the rectangle of the day.\n   * @param columnOffset The offset in the rectangle of the day to adjust this\n   *    span by.\n   * @param columnWidth The width of event span\n   * @param clip `true` if the bounds should stay in the day rectangle, `false`\n   *    and the bounds may go outside the rectangle of the day for multi-day\n   *    spans.\n   * @param offsetX How much to translate the left & right properties by.\n   * @param offsetY How much to translate the top & bottom properties by.\n   * @returns The calculated bounds for this span.\n   */\n  public getBounds(relativeTo: Day, dayHeight: number = 1, dayWidth: number = 1, columnOffset: number = 0, columnWidth: number = 1, clip: boolean = true, offsetX: number = 0, offsetY: number = 0): DaySpanBounds\n  {\n    const startRaw: number = this.startDelta( relativeTo );\n    const endRaw: number = this.endDelta( relativeTo );\n\n    const start: number = clip ? Math.max(0, startRaw) : startRaw;\n    const end: number = clip ? Math.min(1, endRaw) : endRaw;\n\n    const left: number = columnOffset;\n    const right: number = dayWidth - left;\n\n    const width: number = columnWidth || 1;\n\n    const top: number = start * dayHeight;\n    const bottom: number = end * dayHeight;\n\n    return {\n      top: top + offsetY,\n      bottom: bottom + offsetY,\n      height: bottom - top,\n      left: left + offsetX,\n      right: right + offsetX,\n      width: width\n    };\n  }\n\n  /**\n   * Summarizes this span given an approximate unit of time and a few other\n   * options. If the start and end are on the same unit, a single value will\n   * be returned. Otherwise a start and end will be returned with a `delimiter`.\n   *\n   * @param type The unit of time this span is for.\n   * @param dayOfWeek When `true` the weekday of the start and end are included.\n   * @param short When `true` the short form of weekdays and months will be used.\n   * @param repeat When `true` the year will be repeated on the start and end\n   *  timestamp even if they are the same year.\n   * @param contextual When `true` the year will be hidden if it's the current\n   *  year.\n   * @param delimiter The string to separate the start and end timestamps with.\n   * @returns The summary of this span.\n   */\n  public summary(type: Units, dayOfWeek: boolean = true, short: boolean = false, repeat: boolean = false, contextual: boolean = true, delimiter: string = ' - '): string\n  {\n    let formats = DaySpan.SUMMARY_FORMATS[ type ];\n    let today: Day = Day.today();\n    let showStartYear: boolean = !contextual || !this.start.sameYear( today );\n    let showEndYear: boolean = !contextual || !this.end.sameYear( today );\n    let start: string = this.start.format( formats(short, dayOfWeek, showStartYear) );\n    let end: string = this.end.format( formats(short, dayOfWeek, showEndYear) );\n    let summary: string = start;\n\n    if (start !== end)\n    {\n      if (!repeat)\n      {\n        summary = this.start.format( formats(short, dayOfWeek, !this.start.sameYear(this.end)) );\n      }\n\n      summary += delimiter;\n      summary += end;\n    }\n    else\n    {\n      summary = start;\n    }\n\n    return summary;\n  }\n\n  /**\n   * Determines whether the gven span intersects with this span.\n   *\n   * @param span The span to test.\n   * @returns `true` if the spans intersect, otherwise `false`.\n   */\n  public intersects(span: DaySpan): boolean\n  {\n    return !(\n      this.end.time < span.start.time ||\n      this.start.time > span.end.time\n    );\n  }\n\n  /**\n   * Calculates the intersection between this span and the given span. If there\n   * is no intersection between the two spans then `null` is returned.\n   *\n   * @param span The span to calculate the intersection with.\n   * @returns The intersection or `null` if none exists.\n   */\n  public intersection(span: DaySpan): DaySpan\n  {\n    let start: Day = this.start.max( span.start );\n    let end: Day = this.end.min( span.end );\n\n    return start.isAfter( end ) ? null : new DaySpan(start, end);\n  }\n\n  /**\n   * Calculates the union between this span and the given span.\n   *\n   * @param span The span to calculate the union with.\n   * @returns The union of the two spans.\n   */\n  public union(span: DaySpan): DaySpan\n  {\n    let start: Day = this.start.min( span.start );\n    let end: Day = this.end.max( span.end );\n\n    return new DaySpan(start, end);\n  }\n\n  /**\n   * Returns a point [[DaySpan]] with the same start and end timestamp.\n   *\n   * @param day The timestamp which will be the start and end.\n   * @returns The new instance.\n   * @see [[DaySpan.isPoint]]\n   */\n  public static point(day: Day): DaySpan\n  {\n    return new DaySpan( day, day );\n  }\n\n\n  /**\n   * Formatting functions which assist the [[DaySpan.summary]] function.\n   */\n  public static SUMMARY_FORMATS =\n  {\n    [Units.DAY]: (short: boolean, dayOfWeek: boolean, year: boolean) => {\n      return (dayOfWeek ? (short ? 'ddd, ' : 'dddd, ') : '') + (short ? 'MMM ' : 'MMMM ') + 'Do' + (year ? ' YYYY' : '');\n    },\n    [Units.WEEK]: (short: boolean, dayOfWeek: boolean, year: boolean) => {\n      return (dayOfWeek ? (short ? 'ddd, ' : 'dddd, ') : '') + (short ? 'MMM ' : 'MMMM ') + 'Do' + (year ? ' YYYY' : '');\n    },\n    [Units.MONTH]: (short: boolean, dayOfWeek: boolean, year: boolean) => {\n      return (short ? 'MMM' : 'MMMM') + (year ? ' YYYY' : '');\n    },\n    [Units.YEAR]: (short: boolean, dayOfWeek: boolean, year: boolean) => {\n      return (year ? 'YYYY' : '');\n    }\n  };\n\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/DaySpan.ts","\nimport { Functions as fn } from './Functions';\nimport { Day } from './Day';\nimport { DaySpan } from './DaySpan';\n\n\n/**\n * The type for identifiers. Most of the time an identifier can be stored as a\n * number because the 4 digit year is first. However when the year is below\n * 1000 a string will be used with zero padding. Storing identifiers as numbers\n * enable very quick comparisons and using strings or numbers allows the\n * identifier to be used as a key to a map.\n */\nexport type IdentifierInput = number | string;\n\n/**\n * The possible properties which can be pulled from an identifier.\n */\nexport interface IdentifierObject\n{\n  /**\n   * The year pulled from an identifier (0-9999).\n   */\n  year?: number;\n  /**\n   * The quarter of the year pulled from an identifier (1-4)\n   */\n  quarter?: number;\n  /**\n   * The month of the year pulled from an identifier (0-11)\n   */\n  month?: number;\n  /**\n   * The week of the year pulled from an identifier (1-52)\n   */\n  week?: number;\n  /**\n   * The day of the month pulled from an identifier (1-31)\n   */\n  day?: number;\n  /**\n   * The hour of the day pulled from an identifier (0-23)\n   */\n  hour?: number;\n  /**\n   * The minute of the hour pulled from an identifier (0-59)\n   */\n  minute?: number;\n}\n\n\n/**\n * A class for detecting, parsing, and building identifiers to and from days.\n *\n * An identifier is a simple value which represents a span of time. It may\n * represent an entire year, a quarter (3 months) of a year, a week of a year,\n * a month in a year, a specific day of a month of a year, or a specific hour,\n * minute, day, and month of a year.\n *\n * For example:\n * - `2018`: The year 2018\n * - `201801`: January 2018\n * - `2014023`: The 23rd week of 2014\n * - `20170311`: March 11th, 2017\n * - `201406151651`: June 15th 2016 at 4:51 pm\n * - `'0525'`: Year 525 of the first age, Elrond and Elros are born\n */\nexport abstract class Identifier\n{\n\n  /**\n   * Determines whether the given identifier is this type.\n   *\n   * @param id The identifier to test.\n   * @returns `true` if the identifier is this type, otherwise `false`.\n   */\n  public is(id: IdentifierInput): boolean\n  {\n    return (id + '').length === this.getLength();\n  }\n\n  /**\n   * Returns the identifier of this type for the given day,\n   *\n   * @param day The day to get the identifier of.\n   * @returns The identifier for the day of this type.\n   */\n  abstract get(day: Day): IdentifierInput;\n\n  /**\n   * Converts the given identifier which has passed [[Identifier.is]] to an\n   * object with properties pulled from the identifier.\n   *\n   * @param id The identifier to parse.\n   * @returns The object with properties parsed from the identifer.\n   */\n  abstract object(id: IdentifierInput): IdentifierObject;\n\n  /**\n   * Returns the start of the time span the identifier represents.\n   *\n   * @param id The identifier to convert to a start day.\n   * @returns The start of the time span the identifier represents.\n   */\n  abstract start(id: IdentifierInput): Day;\n\n  /**\n   * Returns the span of time the identifier represents.\n   *\n   * @param id The identifier to convert to a span.\n   * @param endInclusive When `true` the end of the span will be the very last\n   *    millisecond that represents the timespan, otherwise `false` the end\n   *    will be the start of the very next span.\n   * @returns\n   */\n  abstract span(id: IdentifierInput, endInclusive: boolean): DaySpan;\n\n  /**\n   * Determines if the day matches the given identifier.\n   *\n   * @param day The day to test.\n   * @param id The identifier to compare to.\n   * @returns `true` if the day exists in the time span represented by the\n   *    identifier, otherwise `false`.\n   */\n  abstract matches(day: Day, id: IdentifierInput): boolean;\n\n  /**\n   * Describes the given identifier as a human friendly string.\n   *\n   * @param id The identifier to describe.\n   * @param short If the description should use shorter language or longer.\n   * @returns The human friendly string that describes the identifier.\n   */\n  abstract describe(id: IdentifierInput, short: boolean): string;\n\n  /**\n   * The scales for all the different values stored in an identifier.\n   */\n  protected abstract getScales(): number[];\n\n  /**\n   * The length of the identifier of this type in digits.\n   */\n  protected abstract getLength(): number;\n\n  /**\n   * Computes the identifier given values taken from a [[Day]].\n   *\n   * @param values The values to compute.\n   * @returns The computed identifier.\n   */\n  protected compute(...values: number[]): IdentifierInput\n  {\n    const scales: number[] = this.getScales();\n    let total: number = 0;\n\n    for (let i = 0; i < values.length; i++)\n    {\n      total += values[ i ] * scales[ i ];\n    }\n\n    return this.is( total ) ? total : fn.padNumber(total, this.getLength());\n  }\n\n  /**\n   * Decomputes the given identifier and returns values which describe a span\n   * of time.\n   *\n   * @param id The identifier to decompute.\n   * @returns The original values which computed the identifier.\n   */\n  protected decompute(id: IdentifierInput): number[]\n  {\n    const scales: number[] = this.getScales();\n    let total: number = fn.isNumber(id) ? <number>id : parseInt(<string>id);\n    let values: number[] = [];\n\n    for (let i = 0; i < scales.length - 1; i++)\n    {\n      let curr: number = scales[ i + 0 ];\n      let next: number = scales[ i + 1 ];\n      let mod: number = next / curr;\n      let value: number = total % mod;\n\n      values.push( value );\n      total = Math.floor( total / mod );\n    }\n\n    values.push( total );\n\n    return values;\n  }\n\n  /**\n   * The identifier type for an hour of time on a specific day.\n   */\n  public static Time: Identifier = null;\n\n  /**\n   * The identifier type for a specific day.\n   */\n  public static Day: Identifier = null;\n\n  /**\n   * The identifier type for a specific week of a year.\n   */\n  public static Week: Identifier = null;\n\n  /**\n   * The identifier type for a specific month of a year.\n   */\n  public static Month: Identifier = null;\n\n  /**\n   * The identifier type for a specific quarter of a year.\n   */\n  public static Quarter: Identifier = null;\n\n  /**\n   * The identifier type for a specific year.\n   */\n  public static Year: Identifier = null;\n\n\n  /**\n   * Finds which identifier type matches the given identifier, if any.\n   *\n   * @param id The identifier to find the type of.\n   * @returns The found identifier type, otherwise `null` if none exists.\n   */\n  public static find(id: IdentifierInput): Identifier\n  {\n    if (this.Time.is(id)) return this.Time;\n    if (this.Day.is(id)) return this.Day;\n    if (this.Week.is(id)) return this.Week;\n    if (this.Month.is(id)) return this.Month;\n    if (this.Year.is(id)) return this.Year;\n\n    return null;\n  }\n\n  /**\n   * Determines whether the given time span `outer` contains the time span\n   * `inner`.\n   *\n   * @param outer The potentially larger time span `inner` must be contained in.\n   * @param inner The time span to test is contained inside `outer`.\n   * @returns `true` if `inner` is equal to or contained in `outer`, otherwise\n   *    `false`.\n   */\n  public static contains(outer: IdentifierInput, inner: IdentifierInput): boolean\n  {\n    let outerString: string = outer + '';\n\n    return (inner + '').substring( 0, outerString.length ) === outerString;\n  }\n\n}\n\n// YYYYMMddHHmm (12)\nclass IdentifierTime extends Identifier\n{\n\n  public static DESCRIBE_FORMAT_LONG: string = 'LLL';\n  public static DESCRIBE_FORMAT_SHORT: string = 'lll';\n\n  private static SCALES: number[] = [\n    1           /* minute */,\n    100         /* hour   */,\n    10000       /* day    */,\n    1000000     /* month  */,\n    100000000   /* year   */];\n  private static LENGTH: number = 12;\n\n  protected getScales(): number[]\n  {\n    return IdentifierTime.SCALES;\n  }\n\n  protected getLength(): number\n  {\n    return IdentifierTime.LENGTH;\n  }\n\n  public get(day: Day): IdentifierInput\n  {\n    return this.compute(day.minute, day.hour, day.dayOfMonth, day.month + 1, day.year);\n  }\n\n  public object(id: IdentifierInput): IdentifierObject\n  {\n    let values: number[] = this.decompute(id);\n\n    return {\n      minute:   values[0],\n      hour:     values[1],\n      day:      values[2],\n      month:    values[3] - 1,\n      year:     values[4]\n    };\n  }\n\n  public start(id: IdentifierInput): Day\n  {\n    let obj: IdentifierObject = this.object(id);\n    let start: Day = Day.build( obj.year, obj.month, obj.day, obj.hour, obj.minute );\n\n    return start;\n  }\n\n  public span(id: IdentifierInput, endInclusive: boolean = false): DaySpan\n  {\n    let start: Day = this.start( id );\n    let end: Day = start.endOfHour( endInclusive );\n\n    return new DaySpan(start, end);\n  }\n\n  public describe(id: IdentifierInput, short: boolean = false): string\n  {\n    let start: Day = this.start( id );\n    let format: string = short ? IdentifierTime.DESCRIBE_FORMAT_SHORT : IdentifierTime.DESCRIBE_FORMAT_LONG;\n\n    return start.format( format );\n  }\n\n  public matches(day: Day, id: IdentifierInput): boolean\n  {\n    return day.timeIdentifier === id;\n    /*\n    let obj: IdentifierObject = this.object(id);\n\n    return (\n      day.year === obj.year &&\n      day.month === obj.month &&\n      day.dayOfMonth === obj.day &&\n      day.hour === obj.hour &&\n      day.minute === obj.minute\n    );\n    */\n  }\n\n}\n\n// YYYYMMdd (8)\nclass IdentifierDay extends Identifier\n{\n\n  public static DESCRIBE_FORMAT_LONG: string = 'LL';\n  public static DESCRIBE_FORMAT_SHORT: string = 'll';\n\n  private static SCALES: number[] = [\n    1           /* day     */,\n    100         /* month   */,\n    10000       /* year    */];\n  private static LENGTH: number = 8;\n\n  protected getScales(): number[]\n  {\n    return IdentifierDay.SCALES;\n  }\n\n  protected getLength(): number\n  {\n    return IdentifierDay.LENGTH;\n  }\n\n  public get(day: Day): IdentifierInput\n  {\n    return this.compute(day.dayOfMonth, day.month + 1, day.year);\n  }\n\n  public object(id: IdentifierInput): IdentifierObject\n  {\n    let values: number[] = this.decompute(id);\n\n    return {\n      day:      values[0],\n      month:    values[1] - 1,\n      year:     values[2]\n    };\n  }\n\n  public start(id: IdentifierInput): Day\n  {\n    let obj: IdentifierObject = this.object(id);\n    let start: Day = Day.build( obj.year, obj.month, obj.day );\n\n    return start;\n  }\n\n  public span(id: IdentifierInput, endInclusive: boolean = false): DaySpan\n  {\n    let start: Day = this.start( id );\n    let end: Day = start.end( endInclusive );\n\n    return new DaySpan(start, end);\n  }\n\n  public describe(id: IdentifierInput, short: boolean = false): string\n  {\n    let start: Day = this.start( id );\n    let format: string = short ? IdentifierDay.DESCRIBE_FORMAT_SHORT : IdentifierDay.DESCRIBE_FORMAT_LONG;\n\n    return start.format( format );\n  }\n\n  public matches(day: Day, id: IdentifierInput): boolean\n  {\n    return day.dayIdentifier === id;\n    /*\n    let obj: IdentifierObject = this.object(id);\n\n    return (\n      day.year === obj.year &&\n      day.month === obj.month &&\n      day.dayOfMonth === obj.day\n    );\n    */\n  }\n\n}\n\n// YYYY0ww (7)\nclass IdentifierWeek extends Identifier\n{\n\n  public static DESCRIBE_FORMAT_LONG: string = 'wo [week of] YYYY';\n  public static DESCRIBE_FORMAT_SHORT: string = 'wo [week of] YYYY';\n\n  private static SCALES: number[] = [\n    1           /* week   */,\n    1000        /* year   */];\n  private static LENGTH: number = 7;\n\n  protected getScales(): number[]\n  {\n    return IdentifierWeek.SCALES;\n  }\n\n  protected getLength(): number\n  {\n    return IdentifierWeek.LENGTH;\n  }\n\n  public get(day: Day): IdentifierInput\n  {\n    return this.compute(day.week, day.year);\n  }\n\n  public object(id: IdentifierInput): IdentifierObject\n  {\n    let values: number[] = this.decompute(id);\n\n    return {\n      week:     values[0],\n      year:     values[1]\n    };\n  }\n\n  public start(id: IdentifierInput): Day\n  {\n    let obj: IdentifierObject = this.object(id);\n    let start: Day = Day.build( obj.year, 0 ).withWeek( obj.week );\n\n    return start;\n  }\n\n  public span(id: IdentifierInput, endInclusive: boolean = false): DaySpan\n  {\n    let start: Day = this.start( id );\n    let end: Day = start.endOfWeek( endInclusive );\n\n    return new DaySpan(start, end);\n  }\n\n  public describe(id: IdentifierInput, short: boolean = false): string\n  {\n    let start: Day = this.start( id );\n    let format: string = short ? IdentifierWeek.DESCRIBE_FORMAT_SHORT : IdentifierWeek.DESCRIBE_FORMAT_LONG;\n\n    return start.format( format );\n  }\n\n  public matches(day: Day, id: IdentifierInput): boolean\n  {\n    return day.weekIdentifier === id;\n    /*\n    let obj: IdentifierObject = this.object(id);\n\n    return (\n      day.year === obj.year &&\n      day.week === obj.week\n    );\n    */\n  }\n\n}\n\n// YYYYMM (6)\nclass IdentifierMonth extends Identifier\n{\n\n  public static DESCRIBE_FORMAT_LONG: string = 'MMMM YYYY';\n  public static DESCRIBE_FORMAT_SHORT: string = 'MMM YYYY';\n\n  private static SCALES: number[] = [\n    1           /* month  */,\n    100         /* year   */];\n  private static LENGTH: number = 6;\n\n  protected getScales(): number[]\n  {\n    return IdentifierMonth.SCALES;\n  }\n\n  protected getLength(): number\n  {\n    return IdentifierMonth.LENGTH;\n  }\n\n  public get(day: Day): IdentifierInput\n  {\n    return this.compute(day.month + 1, day.year);\n  }\n\n  public object(id: IdentifierInput): IdentifierObject\n  {\n    let values: number[] = this.decompute(id);\n\n    return {\n      month:    values[0] - 1,\n      year:     values[1]\n    };\n  }\n\n  public start(id: IdentifierInput): Day\n  {\n    let obj: IdentifierObject = this.object(id);\n    let start: Day = Day.build( obj.year, obj.month );\n\n    return start;\n  }\n\n  public span(id: IdentifierInput, endInclusive: boolean = false): DaySpan\n  {\n    let start: Day = this.start( id );\n    let end: Day = start.endOfMonth( endInclusive );\n\n    return new DaySpan(start, end);\n  }\n\n  public describe(id: IdentifierInput, short: boolean = false): string\n  {\n    let start: Day = this.start( id );\n    let format: string = short ? IdentifierMonth.DESCRIBE_FORMAT_SHORT : IdentifierMonth.DESCRIBE_FORMAT_LONG;\n\n    return start.format( format );\n  }\n\n  public matches(day: Day, id: IdentifierInput): boolean\n  {\n    return day.monthIdentifier === id;\n    /*\n    let obj: IdentifierObject = this.object(id);\n\n    return (\n      day.year === obj.year &&\n      day.month === obj.month\n    );\n    */\n  }\n\n}\n\n// YYYYQ (5)\nclass IdentifierQuarter extends Identifier\n{\n\n  public static DESCRIBE_FORMAT_LONG: string = 'Qo [quarter] YYYY';\n  public static DESCRIBE_FORMAT_SHORT: string = 'Qo [quarter] YYYY';\n\n  private static SCALES: number[] = [\n    1           /* quarter  */,\n    10          /* year   */];\n  private static LENGTH: number = 5;\n\n  protected getScales(): number[]\n  {\n    return IdentifierQuarter.SCALES;\n  }\n\n  protected getLength(): number\n  {\n    return IdentifierQuarter.LENGTH;\n  }\n\n  public get(day: Day): IdentifierInput\n  {\n    return this.compute(day.quarter, day.year);\n  }\n\n  public object(id: IdentifierInput): IdentifierObject\n  {\n    let values: number[] = this.decompute(id);\n\n    return {\n      quarter:  values[0],\n      year:     values[1]\n    };\n  }\n\n  public start(id: IdentifierInput): Day\n  {\n    let obj: IdentifierObject = this.object(id);\n    let start: Day = Day.build( obj.year, (obj.quarter - 1) * 3 );\n\n    return start;\n  }\n\n  public span(id: IdentifierInput, endInclusive: boolean = false): DaySpan\n  {\n    let start: Day = this.start( id );\n    let end: Day = start.relativeMonths( 3 ).endOfMonth( endInclusive );\n\n    return new DaySpan(start, end);\n  }\n\n  public describe(id: IdentifierInput, short: boolean = false): string\n  {\n    let start: Day = this.start( id );\n    let format: string = short ? IdentifierQuarter.DESCRIBE_FORMAT_SHORT : IdentifierQuarter.DESCRIBE_FORMAT_LONG;\n\n    return start.format( format );\n  }\n\n  public matches(day: Day, id: IdentifierInput): boolean\n  {\n    return day.quarterIdentifier === id;\n    /*\n    let obj: IdentifierObject = this.object(id);\n\n    return (\n      day.year === obj.year &&\n      day.quarter === obj.quarter\n    );\n    */\n  }\n\n}\n\n// YYYY (4)\nclass IdentifierYear extends Identifier\n{\n\n  public static DESCRIBE_FORMAT_LONG: string = 'YYYY';\n  public static DESCRIBE_FORMAT_SHORT: string = 'YYYY';\n\n  private static SCALES: number[] = [\n    1           /* year  */];\n  private static LENGTH: number = 4;\n\n  protected getScales(): number[]\n  {\n    return IdentifierYear.SCALES;\n  }\n\n  protected getLength(): number\n  {\n    return IdentifierYear.LENGTH;\n  }\n\n  public get(day: Day): IdentifierInput\n  {\n    return this.compute(day.year);\n  }\n\n  public object(id: IdentifierInput): IdentifierObject\n  {\n    let values: number[] = this.decompute(id);\n\n    return {\n      year:     values[0]\n    };\n  }\n\n  public start(id: IdentifierInput): Day\n  {\n    let obj: IdentifierObject = this.object(id);\n    let start: Day = Day.build( obj.year, 0 );\n\n    return start;\n  }\n\n  public span(id: IdentifierInput, endInclusive: boolean = false): DaySpan\n  {\n    let start: Day = this.start( id );\n    let end: Day = start.endOfYear( endInclusive );\n\n    return new DaySpan(start, end);\n  }\n\n  public describe(id: IdentifierInput, short: boolean = false): string\n  {\n    let start: Day = this.start( id );\n    let format: string = short ? IdentifierYear.DESCRIBE_FORMAT_SHORT : IdentifierYear.DESCRIBE_FORMAT_LONG;\n\n    return start.format( format );\n  }\n\n  public matches(day: Day, id: IdentifierInput): boolean\n  {\n    return day.year === id;\n    /*\n    let obj: IdentifierObject = this.object(id);\n\n    return (\n      day.year === obj.year\n    );\n    */\n  }\n\n}\n\n// Sets the Identifier types\nIdentifier.Time = new IdentifierTime();\nIdentifier.Day = new IdentifierDay();\nIdentifier.Week = new IdentifierWeek();\nIdentifier.Month = new IdentifierMonth();\nIdentifier.Quarter = new IdentifierQuarter();\nIdentifier.Year = new IdentifierYear();\n\n\n\n// WEBPACK FOOTER //\n// ./src/Identifier.ts","\n/**\n * A class which takes a number and determines the suffix for that number.\n *\n * ```typescript\n * Suffix.CACHE[ 2 ];         // 2nd\n * Suffix.determine( 3 );     // rd\n * Suffix.get( 4 );           // th\n * Suffix.get( 4, true );     // 4th\n * ```\n */\nexport class Suffix\n{\n\n  /**\n   * The array of suffixes used.\n   */\n  public static MAP: string[] = [\n    'th', 'st', 'nd', 'rd', 'th', 'th', 'th', 'th', 'th', 'th'\n  ];\n\n  /**\n   * An internal cache of [[Suffix._CACHE_SIZE]] suffixes.\n   */\n  private static _CACHE: string[];\n\n  /**\n   * The number of values to store in the cache (inclusive).\n   */\n  private static _CACHE_SIZE: number = 366;\n\n\n  /**\n   * The cache of number & suffix pairs.\n   */\n  public static get CACHE(): string[]\n  {\n    if (!this._CACHE)\n    {\n      this._CACHE = [];\n\n      for (let i = 0; i <= this._CACHE_SIZE; i++)\n      {\n        this._CACHE[ i ] = this.get( i, true );\n      }\n    }\n\n    return this._CACHE;\n  }\n\n  /**\n   * Determines the suffix for a given number.\n   *\n   * @param value The number to find the suffix for.\n   * @returns The suffix determined.\n   */\n  public static determine(value: number): string\n  {\n    return value >= 11 && value <= 13 ? 'th' : this.MAP[ value % this.MAP.length ];\n  }\n\n  /**\n   * Gets the suffix for a number and optionally appends it before the suffix.\n   *\n   * @param value The number to get the suffix for.\n   * @param prepend When `true` the value is prepended to the suffix.\n   * @returns The suffix or value & suffix pair determined.\n   */\n  public static get(value: number, prepend: boolean = false): string\n  {\n    let suffix: string = this.determine(value);\n\n    return prepend ? value + suffix : suffix;\n  }\n\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/Suffix.ts","\nimport { Functions as fn } from './Functions';\n\n\n/**\n * The callback which is invoked for each item in the Iterator. The callback\n * can call [[Iterator.stop]] at anytime to stop iteration.\n *\n * @param item The item found in the iterator.\n * @param iterator The iterator with the item.\n * @returns The result of the callback.\n */\nexport type IteratorCallback<T, R> = (item: T, iterator: Iterator<T>) => R;\n\n/**\n * An [[Iterator]] source which handles iterating over items and calls\n * [[Iterator.act]] for each item, taking the requested action when possible.\n *\n * @param callback The function to invoke for each item.\n * @param iterator The iterator to check for early exists.\n */\nexport type IteratorSource<T> = (iterator: Iterator<T>) => any;\n\n/**\n * A filter to apply duration iteration to only look at certain items when this\n * function returns `true`.\n *\n * @param item The item being iterated.\n * @returns `true` if the item should be iterated, otherwise `false`.\n */\nexport type IteratorFilter<T> = (item: T) => boolean;\n\n/**\n * An action to perform on the source as instructed by the iterator.\n */\nexport enum IteratorAction\n{\n  /**\n   * Continue iteration.\n   */\n  Continue,\n\n  /**\n   * Stop iteration.\n   */\n  Stop,\n\n  /**\n   * Remove the current item if possible, and continue iteration.\n   */\n  Remove,\n\n  /**\n   * Replace the current item with the provided value.\n   */\n  Replace\n}\n\n/**\n * A class that allows an iteratable source to be iterated any number of times\n * by providing the following functionality:\n *\n * - [[Iterator.isEmpty]]: Determines whether the source contains any items.\n * - [[Iterator.first]]: Gets the first item in the source.\n * - [[Iterator.count]]: Counds the number of items in the source.\n * - [[Iterator.list]]: Builds a list of the items in the source.\n * - [[Iterator.object]]: Builds an object of the items in the source.\n * - [[Iterator.reduce]]: Reduces the items in the source down to a single value.\n * - [[Iterator.purge]]: Removes items from the source which meet some criteria.\n * - [[Iterator.filter]]: Returns a subset of items that meet some criteria by\n *    returning a new Iterator.\n * - [[Iterator.map]]: Maps each item in the source to another item by returning\n *    a new Iterator.\n * - [[Iterator.iterate]]: Invokes a function for each item in the source.\n *\n * The following static functions exist to help iterate simple sources:\n *\n * - [[Iterator.forArray]]: Iterates an array, optionally reverse\n * - [[Iterator.forObject]]: Iterates the properties of an object, optionally\n *    just the properties explicitly set on the object.\n *\n * ```typescript\n * let iter = object.iterateThings();\n * iter.isEmpty();              // no items?\n * iter.isEmpty(d => d.flag);   // no items that meet some criteria?\n * iter.count();                // number of items\n * iter.count(d => d.flag);     // number of items that meet some criteria\n * iter.first();                // first item\n * iter.first(d => d.flag);     // first item that meets some criteria\n * iter.list();                 // get all items as array\n * iter.list(myArray);          // add all items to given array\n * iter.list([], d => d.flag);  // get all items as array that meet some criteria\n * iter.object(d => d.id);      // get all items as an object keyed by a value (ex: id)\n * iter.object(d => d.id, {},\n *    d => d.flag);             // get all items as an object keyed by a value where the item meets some criteria (ex: key id if flag is truthy)\n * iter.purge(d => d.flag);     // remove all items from source that meet some criteria\n * iter.filter(d => d.flag);    // returns an iterator which iterates a subset of items which meet some criteria\n * iter.reduce<number>(0,\n *   (d, t) => t + d.size);     // reduces all items to a single value (ex: sums all size)\n * iter.reduce<number>(0,\n *   (d, t) => t + d.size,\n *   d => d.flag);              // reduces all items to a single value (ex: sums all size) where the item meets some criteria\n * iter.map<S>(d => d.subitem); // return an iterator for subitems if they exist\n * iter.iterate(d => log(d));   // do something for each item\n * ```\n *\n * @typeparam T The type of item being iterated.\n */\nexport class Iterator<T>\n{\n\n  /**\n   * A result of the iteration passed to [[Iterator.stop]].\n   */\n  public result: any = null;\n\n  /**\n   * The last action (if any) called on this iterator.\n   */\n  public action: IteratorAction;\n\n  /**\n   * The value to replace with the current item.\n   */\n  public replaceWith: T;\n\n  /**\n   * The current callback passed to the iterator.\n   */\n  public callback: IteratorCallback<T, any>;\n\n  /**\n   * The source of iterable items. This allows the iteration over any type of\n   * structure. The source must call the callback for each item and its\n   * recommended that the source checks the [[Iterator.iterating]] flag after\n   * each callback invokation.\n   */\n  private source: IteratorSource<T>;\n\n  /**\n   * Creates a new Iterator given a source.\n   *\n   * @param source The source of items to iterator.\n   */\n  public constructor(source: IteratorSource<T>)\n  {\n    this.source = source;\n  }\n\n  /**\n   * Returns a clone of this iterator with the same source. This is necessary\n   * if you want to iterate all or a portion of the source while already\n   * iterating it (like a nested loop).\n   */\n  public clone(): Iterator<T>\n  {\n    return new Iterator<T>( this.source );\n  }\n\n  /**\n   * Passes the given item to the iterator callback and returns the action\n   * requested at this point in iteration.\n   *\n   * @param item The current item being iterated.\n   */\n  public act(item: T): IteratorAction\n  {\n    this.action = IteratorAction.Continue;\n    this.replaceWith = null;\n\n    this.callback( item, this );\n\n    return this.action;\n  }\n\n  /**\n   * Stops iteration and optionally sets the result of the iteration.\n   *\n   * @param result The result of the iteration.\n   */\n  public stop(result?: any): this\n  {\n    this.result = result;\n    this.action = IteratorAction.Stop;\n\n    return this;\n  }\n\n  /**\n   * Stops iteration and optionally sets the result of the iteration.\n   *\n   * @param result The result of the iteration.\n   */\n  public replace(replaceWith: T): this\n  {\n    this.replaceWith = replaceWith;\n    this.action = IteratorAction.Replace;\n\n    return this;\n  }\n\n  /**\n   * Signals to the iterator source that the current item wants to be removed.\n   */\n  public remove(): this\n  {\n    this.action = IteratorAction.Remove;\n\n    return this;\n  }\n\n  /**\n   * Determines with this iterator is empty. A filter function can be specified\n   * to only check for items which match certain criteria.\n   *\n   * @param filter A function to the checks items for certain criteria.\n   * @returns `true` if no valid items exist in the source.\n   */\n  public isEmpty(filter: IteratorFilter<T> = null): boolean\n  {\n    let empty: boolean = true;\n\n    this.iterate((item, iterator) =>\n    {\n      if (filter && !filter( item ))\n      {\n        return;\n      }\n\n      empty = false;\n      iterator.stop();\n    });\n\n    return empty;\n  }\n\n  /**\n   * Counts the number of items in the iterator. A filter function can be\n   * specified to only count items which match certain criteria.\n   *\n   * @param filter A function to count items for certain criteria.\n   * @returns The number of items in the source that optionally match the given\n   *    criteria.\n   */\n  public count(filter: IteratorFilter<T> = null): number\n  {\n    let total: number = 0;\n\n    this.iterate((item, iterator) =>\n    {\n      if (filter && !filter( item ))\n      {\n        return;\n      }\n\n      total++;\n    });\n\n    return total;\n  }\n\n  /**\n   * Returns the first item in the iterator. A filter function can be specified\n   * to only return the first item which matches certain criteria.\n   *\n   * @param filter A function to compare items to to match certain criteria.\n   * @returns The first item found that optonally matches the given criteria.\n   */\n  public first(filter: IteratorFilter<T> = null): T\n  {\n    let first: T = null;\n\n    this.iterate((item, iterator) =>\n    {\n      if (filter && !filter( item ))\n      {\n        return;\n      }\n\n      first = item;\n      iterator.stop();\n    });\n\n    return first;\n  }\n\n  /**\n   * Builds a list of items from the source. A filter function can be specified\n   * so the resulting list only contain items that match certain criteria.\n   *\n   * @param out The array to place the items in.\n   * @param filter The function which determines which items are added to the list.\n   * @returns The reference to `out` which has had items added to it which\n   *    optionally match the given criteria.\n   */\n  public list(out: T[] = [], filter: IteratorFilter<T> = null): T[]\n  {\n    this.iterate((item, iterator) =>\n    {\n      if (filter && !filter( item ))\n      {\n        return;\n      }\n\n      out.push( item );\n    });\n\n    return out;\n  }\n\n  /**\n   * Builds an object of items from the source keyed by a result returned by\n   * a `getKey` function.\n   *\n   * @param getKey The function which returns the key of the object.\n   * @param out The object to place the items in.\n   * @param filter The function which determines which items are set on the object.\n   * @returns The reference to `out` which has had items set to it which\n   *    optionally match the given criteria.\n   */\n  public object(getKey: (item: T) => any, out: any = {}, filter: IteratorFilter<T> = null): any\n  {\n    this.iterate((item, iterator) =>\n    {\n      if (filter && !filter( item ))\n      {\n        return;\n      }\n\n      let key = getKey( item );\n\n      out[ key ] = item;\n    });\n\n    return out;\n  }\n\n  /**\n   * Returns a new iterator that only returns a maximum number of items.\n   *\n   * @param amount The maximum number of items to return.\n   * @returns A new iterator which returns a maximum number of items.\n   */\n  public take(amount: number): Iterator<T>\n  {\n    return new Iterator<T>(next =>\n    {\n      this.iterate((item, prev) =>\n      {\n        switch (next.act( item ))\n        {\n          case IteratorAction.Stop:\n            prev.stop();\n            break;\n          case IteratorAction.Remove:\n            prev.remove();\n            break;\n          case IteratorAction.Replace:\n            prev.replace( next.replaceWith );\n            break;\n        }\n\n        if (--amount <= 0)\n        {\n          prev.stop();\n        }\n      });\n    });\n  }\n\n  /**\n   * Returns a new iterator that skips the given number of items from the items\n   * in this iterator.\n   *\n   * @param amount The number of items to skip.\n   * @returns A new iterator which skipped the given number of items.\n   */\n  public skip(amount: number): Iterator<T>\n  {\n    return new Iterator<T>(next =>\n    {\n      let skipped: number = 0;\n\n      this.iterate((item, prev) =>\n      {\n        if (skipped >= amount)\n        {\n          switch (next.act( item ))\n          {\n            case IteratorAction.Stop:\n              prev.stop();\n              break;\n            case IteratorAction.Remove:\n              prev.remove();\n              break;\n            case IteratorAction.Replace:\n              prev.replace( next.replaceWith );\n              break;\n          }\n        }\n\n        skipped++;\n      });\n    });\n  }\n\n  /**\n   * Returns a new iterator thats items are the items in this iterator followed\n   * by the items in the given iterators.\n   *\n   * @param iterators The iterators to append after this one.\n   * @returns A new iterator based on this iterator followed by the given.\n   */\n  public append(...iterators: Iterator<T>[]): Iterator<T>\n  {\n    return Iterator.join<T>( this, ...iterators );\n  }\n\n  /**\n   * Returns a new iterator thats items are the items in the given iterators\n   * followed by the items in this iterator.\n   *\n   * @param iterators The iterators to prepend before this one.\n   * @returns A new iterator based on the given iterators followed by this.\n   */\n  public prepend(...iterators: Iterator<T>[]): Iterator<T>\n  {\n    return Iterator.join<T>( ...iterators, this );\n  }\n\n  /**\n   * Removes items from the source that match certain criteria.\n   *\n   * @param filter The function which determines which items to remove.\n   */\n  public purge(filter: IteratorFilter<T>): this\n  {\n    this.iterate((item, iterator) =>\n    {\n      if (filter(item))\n      {\n        iterator.remove();\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Returns an iterator which takes items from this iterator and presents them\n   * in reverse.\n   *\n   * @returns A new iterator with the items in this iterator in reverse.\n   */\n  public reverse(): Iterator<T>\n  {\n    return new Iterator<T>(iterator =>\n    {\n      let items: T[] = this.list();\n      let modifies: boolean = false;\n      let actions: IteratorAction[] = [];\n      let replaces: T[] = [];\n\n      for (let i = items.length - 1; i >= 0; i--)\n      {\n        let item: T = items[ i ];\n        let action: IteratorAction = iterator.act( item );\n\n        if (action === IteratorAction.Stop)\n        {\n          break;\n        }\n\n        if (action !== IteratorAction.Continue)\n        {\n          modifies = true;\n\n          actions[ i ] = action;\n          replaces[ i ] = iterator.replaceWith;\n        }\n      }\n\n      if (modifies)\n      {\n        let index: number = 0;\n\n        this.iterate((item, iterator) =>\n        {\n          switch (actions[ index ])\n          {\n            case IteratorAction.Remove:\n              iterator.remove();\n              break;\n            case IteratorAction.Replace:\n              iterator.replace( replaces[ index ] );\n              break;\n          }\n\n          index++;\n        });\n      }\n    });\n  }\n\n  /**\n   * Reduces all the items in the source to a single value given the initial\n   * value and a function to convert an item and the current reduced value\n   */\n  public reduce<R>(initial: R, reducer: (item: T, reduced: R) => R, filter: IteratorFilter<T> = null): R\n  {\n    let reduced: R = initial;\n\n    this.iterate((item, iterator) =>\n    {\n      if (filter && !filter( item ))\n      {\n        return;\n      }\n\n      reduced = reducer( item, reduced );\n    });\n\n    return reduced;\n  }\n\n  /**\n   * Returns an iterator where this iterator is the source and the returned\n   * iterator is built on a subset of items which pass a `filter` function.\n   *\n   * @param filter The function which determines if an item should be iterated.\n   * @returns A new iterator for the filtered items from this iterator.\n   */\n  public filter(filter: IteratorFilter<T>): Iterator<T>\n  {\n    return new Iterator<T>(next =>\n    {\n      this.iterate((prevItem, prev) =>\n      {\n        if (filter(prevItem))\n        {\n          switch (next.act( prevItem ))\n          {\n            case IteratorAction.Stop:\n              prev.stop();\n              break;\n            case IteratorAction.Remove:\n              prev.remove();\n              break;\n            case IteratorAction.Replace:\n              prev.replace( next.replaceWith );\n              break;\n          }\n        }\n      });\n    });\n  }\n\n  /**\n   * Returns an iterator where this iterator is the source and the returned\n   * iterator is built from mapped items pulled from items in the source\n   * of this iterator. If the given callback `outerCallback` does not return\n   * a mapped value then the returned iterator will not see the item. A filter\n   * function can be specified to only look at mapping items which match\n   * certain criteria.\n   *\n   * @param mapper The function which maps an item to another.\n   * @param filter The function which determines if an item should be mapped.\n   * @param unmapper The function which unmaps a value when replace is called.\n   * @returns A new iterator for the mapped items from this iterator.\n   */\n  public map<W>(mapper: IteratorCallback<T, W>,\n    filter: IteratorFilter<T> = null,\n    unmapper: (replaceWith: W, current: W, item: T) => T = null): Iterator<W>\n  {\n    return new Iterator<W>(next =>\n    {\n      this.iterate((prevItem, prev) =>\n      {\n        if (filter && !filter( prevItem ))\n        {\n          return;\n        }\n\n        let nextItem: W = mapper( prevItem, prev );\n\n        if (fn.isDefined( nextItem ))\n        {\n          switch (next.act( nextItem ))\n          {\n            case IteratorAction.Stop:\n              prev.stop();\n              break;\n            case IteratorAction.Remove:\n              prev.remove();\n              break;\n            case IteratorAction.Replace:\n              if (unmapper) {\n                prev.replace( unmapper( next.replaceWith, nextItem, prevItem ) );\n              }\n              break;\n          }\n        }\n      });\n    });\n  }\n\n  /**\n   * Invokes the callback for each item in the source of this iterator. The\n   * second argument in the callback is the reference to this iterator and\n   * [[Iterator.stop]] can be called at anytime to cease iteration.\n   *\n   * @param callback The function to invoke for each item in this iterator.\n   */\n  public iterate(callback: IteratorCallback<T, any>): this\n  {\n    this.result = undefined;\n    this.callback = callback;\n    this.action = IteratorAction.Continue;\n    this.source( this );\n    this.callback = null;\n\n    return this;\n  }\n\n  /**\n   * Passes the result of the iteration to the given function if a truthy\n   * result was passed to [[Iterator.stop]].\n   *\n   * @param getResult The function to pass the result to if it exists.\n   */\n  public withResult(getResult: (result: any) => any): this\n  {\n    if (this.result)\n    {\n      getResult( this.result );\n    }\n\n    return this;\n  }\n\n  /**\n   * Returns an iterator for the given array optionally iterating it in reverse.\n   *\n   * @param items The array of items to iterate.\n   * @param reverse If the array should be iterated in reverse.\n   * @returns A new iterator for the given array.\n   */\n  public static forArray<T>(items: T[], reverse: boolean = false): Iterator<T>\n  {\n    return new Iterator<T>(iterator =>\n    {\n      if (reverse)\n      {\n        for (let i = items.length - 1; i >= 0; i--)\n        {\n          switch (iterator.act(items[ i ]))\n          {\n            case IteratorAction.Stop:\n              return;\n            case IteratorAction.Remove:\n              items.splice(i, 1);\n              break;\n            case IteratorAction.Replace:\n              items.splice(i, 1, iterator.replaceWith);\n              break;\n          }\n        }\n      }\n      else\n      {\n        for (let i = 0; i < items.length; i++)\n        {\n          switch (iterator.act(items[ i ]))\n          {\n            case IteratorAction.Stop:\n              return;\n            case IteratorAction.Remove:\n              items.splice(i, 1);\n              i--;\n              break;\n            case IteratorAction.Replace:\n              items.splice(i, 1, iterator.replaceWith);\n              break;\n          }\n        }\n      }\n    });\n  }\n\n  /**\n   * Returns an iterator for the given object optionally checking the\n   * `hasOwnProperty` function on the given object.\n   *\n   * @param items The object to iterate.\n   * @param hasOwnProperty If `hasOwnProperty` should be checked.\n   * @returns A new iterator for the given object.\n   */\n  public static forObject<T>(items: { [key: string]: T }, hasOwnProperty: boolean = true): Iterator<T>\n  {\n    return new Iterator<T>(iterator =>\n    {\n      for (let key in items)\n      {\n        if (hasOwnProperty && !items.hasOwnProperty( key ))\n        {\n          continue;\n        }\n\n        switch (iterator.act(items[ key ]))\n        {\n          case IteratorAction.Stop:\n            return;\n          case IteratorAction.Remove:\n            delete items[ key ];\n            break;\n          case IteratorAction.Replace:\n            items[ key ] = iterator.replaceWith;\n            break;\n        }\n      }\n    });\n  }\n\n  /**\n   * Joins all the given iterators into a single iterator where the items\n   * returned are in the same order as passed to this function. If any items\n   * are removed from the returned iterator they will be removed from the given\n   * iterator if it supports removal.\n   *\n   * @param iterators The array of iterators to join as one.\n   * @returns A new iterator for the given iterators.\n   */\n  public static join<T>(...iterators: Iterator<T>[]): Iterator<T>\n  {\n    return new Iterator<T>(parent =>\n    {\n      for (let child of iterators)\n      {\n        child.iterate((item, childIterator) =>\n        {\n          switch (parent.act( item ))\n          {\n            case IteratorAction.Remove:\n              childIterator.remove();\n              break;\n            case IteratorAction.Stop:\n              childIterator.stop();\n              break;\n            case IteratorAction.Replace:\n              childIterator.replace( parent.replaceWith );\n              break;\n          }\n        });\n\n        if (child.action === IteratorAction.Stop)\n        {\n          return;\n        }\n      }\n    });\n  }\n\n  /**\n   * Returns a new iterator with no items.\n   *\n   * @returns A new iterator with no items.\n   */\n  public static empty<T>(): Iterator<T>\n  {\n    return new Iterator<T>(parent => {});\n  }\n\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/Iterator.ts","\nimport { Functions as fn } from './Functions';\nimport { Day, DayProperty } from './Day';\nimport { Suffix } from './Suffix';\nimport { Weekday } from './Weekday';\nimport { FrequencyValueEvery, FrequencyValue } from './Frequency';\nimport { Schedule, ScheduleInput } from './Schedule';\n\n\n/**\n * Describes a [[Pattern]] given a [[Day]] to base it on.\n *\n * @param day The day to base the description on.\n * @returns The description of the pattern.\n */\nexport type DescribePattern = (day: Day) => string;\n\n/**\n * A rule helps parse [[ScheduleInput]] and determines whether it matches the\n * given pattern.\n *\n * - When a number is given, the input MUST be an array of the same length and contain any values.\n * - When an array of numbers is given, the input MUST be an array containing the same values.\n * - When a TRUE is given the input MUST contain that property and can be any value.\n * - When a FALSE is given the input MAY contain that property (optional).\n * - When a property is NOT specified, the input MUST NOT contain that property.\n * - When an object with every is given, the input must match the every and offset values (have the same frequency).\n */\nexport type PatternRule =\n  number |                // has array with this number of elements\n  number[] |              // is array with same values\n  boolean |               // is true or false\n  FrequencyValueEvery;    // is object with matching every and offset\n\n/**\n * The set of rules you can specify for determining if a [[ScheduleInput]]\n * matches a pattern.\n */\nexport interface PatternRules\n{\n  dayOfWeek?: PatternRule;\n  dayOfMonth?: PatternRule;\n  lastDayOfMonth?: PatternRule;\n  dayOfYear?: PatternRule;\n  month?: PatternRule;\n  week?: PatternRule;\n  year?: PatternRule;\n  weekOfYear?: PatternRule;\n  weekspanOfYear?: PatternRule;\n  fullWeekOfYear?: PatternRule;\n  lastWeekspanOfYear?: PatternRule;\n  lastFullWeekOfYear?: PatternRule;\n  weekOfMonth?: PatternRule;\n  weekspanOfMonth?: PatternRule;\n  fullWeekOfMonth?: PatternRule;\n  lastWeekspanOfMonth?: PatternRule;\n  lastFullWeekOfMonth?: PatternRule;\n}\n\n\n/**\n * A class which helps describe [[ScheduleInput]] if it matches a pattern.\n */\nexport class Pattern\n{\n\n  /**\n   * The properties in the [[ScheduleInput]] which are compared against the\n   * rules of a pattern.\n   */\n  public static PROPS: DayProperty[] =\n  [\n    'dayOfWeek', 'dayOfMonth', 'lastDayOfMonth', 'dayOfYear',\n    'month', 'week', 'year',\n    'weekOfYear', 'weekspanOfYear', 'fullWeekOfYear', 'lastWeekspanOfYear', 'lastFullWeekOfYear',\n    'weekOfMonth', 'weekspanOfMonth', 'fullWeekOfMonth', 'lastWeekspanOfMonth', 'lastFullWeekOfMonth'\n  ];\n\n  /**\n   * Whether this pattern should be \"listed\" or not. Visual schedulers may\n   * provide a shortcut to describing and changing a [[Schedule]] through\n   * patterns and any pattern where listed is `true` could be an option in a\n   * list. The default patterns are all listed.\n   */\n  public listed: boolean;\n\n  /**\n   * The function which describes this pattern given a [[Day]] to base it on.\n   */\n  public describe: DescribePattern;\n\n  /**\n   * The name of this pattern. This is not typically displayed to a user, just\n   * to uniquely identify a pattern.\n   */\n  public name: string;\n\n  /**\n   * The rules for matching a pattern to a [[Schedule]] or applying a pattern to\n   * a schedule.\n   */\n  public rules: PatternRules;\n\n\n  /**\n   * Creates a new pattern.\n   *\n   * @param name The unique name of the pattern.\n   * @param listed If the pattern is \"listed\" [[Pattern.listed]].\n   * @param describe A function to describe the pattern given a [[Day]].\n   * @param rules The rules which describe how to detect and apply the pattern\n   *    to schedule input.\n   */\n  public constructor(name: string, listed: boolean, describe: DescribePattern, rules: PatternRules)\n  {\n    this.name = name;\n    this.listed = listed;\n    this.describe = describe;\n    this.rules = rules;\n  }\n\n  /**\n   * Applies this pattern to a [[Schedule]] or [[ScheduleInput]] removing and\n   * adding any necessary properties from the input to match this pattern -\n   * based around the day provided.\n   *\n   * @param schedule The schedule to update to match this pattern.\n   * @param day The day to base the schedule on.\n   * @returns The reference to the input passed in.\n   */\n  public apply<M, I extends ScheduleInput<M> | Schedule<M>>(schedule: I, day: Day): I\n  {\n    if (schedule instanceof Schedule)\n    {\n      this.applyGeneric(day,\n        (prop, frequency) => schedule.setFrequency( prop, frequency ),\n        (prop) => schedule.setFrequency( prop )\n      );\n\n      schedule.updateChecks();\n    }\n    else\n    {\n      this.applyGeneric(day,\n        (prop, frequency) => schedule[ prop ] = frequency,\n        (prop) => delete schedule[ prop ]\n      );\n    }\n\n    return schedule;\n  }\n\n  /**\n   * Applies this pattern to any object provided they implement the\n   * `setFrequency` and `removeFrequency` functions.\n   *\n   * @param day The day to base the schedule on.\n   * @param setFrequency The function which sets the frequency on the object.\n   * @param removeFrequency The function to remove a frequency from the object.\n   */\n  public applyGeneric(day: Day,\n    setFrequency: (property: DayProperty, frequency: any) => any,\n    removeFrequency: (property: DayProperty) => any): void\n  {\n    for (let prop of Pattern.PROPS)\n    {\n      let rule = this.rules[ prop ];\n\n      // Should have one value\n      if (rule === 1)\n      {\n        setFrequency( prop, [day[ prop ]] );\n      }\n\n      // Can be any of the values in the array\n      if (fn.isArray(rule))\n      {\n        setFrequency( prop, rule );\n      }\n\n      // Must not be present\n      if (!fn.isDefined(rule))\n      {\n        removeFrequency( prop );\n      }\n    }\n  }\n\n  /**\n   * Determines whether the given [[Schedule]] or [[ScheduleInput]] matches this\n   * pattern. Optionally a day can be provided to make sure the day matches the\n   * schedule and pattern together.\n   *\n   * @param schedule The schedule input to test.\n   * @param exactlyWith A day to further validate against for matching.\n   * @returns `true` if the schedule was a match to this pattern with the\n   *    day if one was provided, otherwise `false`.\n   */\n  public isMatch<M, I extends ScheduleInput<M> | Schedule<M>>(schedule: I, exactlyWith?: Day): boolean\n  {\n    if (schedule instanceof Schedule)\n    {\n      return this.isMatchGeneric((prop) => schedule[ prop ].input, exactlyWith);\n    }\n    else\n    {\n      return this.isMatchGeneric((prop) => schedule[ prop ], exactlyWith);\n    }\n  }\n\n  /**\n   * Determines whether the given input matches this pattern. Optionally a day\n   * can be provided to make sure the day matches the schedule and pattern\n   * together.\n   *\n   * @param input The schedule input to test.\n   * @param exactlyWith A day to further validate against for matching.\n   * @returns `true` if the schedule input was a match to this pattern with the\n   *    day if one was provided, otherwise `false`.\n   */\n  public isMatchGeneric(getFrequency: (property: DayProperty) => FrequencyValue, exactlyWith?: Day): boolean\n  {\n    let exactly: boolean = fn.isDefined( exactlyWith );\n\n    for (let prop of Pattern.PROPS)\n    {\n      let rule = this.rules[ prop ];\n      let curr = getFrequency( prop );\n\n      // Optional, skip it\n      if (rule === false)\n      {\n        continue;\n      }\n\n      // Requires any value\n      if (rule === true && !curr)\n      {\n        return false;\n      }\n\n      // Must not be present\n      if (!fn.isDefined(rule) && curr)\n      {\n        return false;\n      }\n\n      // Must be an array of the same size\n      if (fn.isNumber(rule))\n      {\n        if (fn.isArray(curr) && (<number[]>curr).length === rule)\n        {\n          if (exactly && (<number[]>curr).indexOf( <number>exactlyWith[ prop ] ) === -1)\n          {\n            return false;\n          }\n        }\n        else\n        {\n          return false;\n        }\n      }\n\n      // Must be an array of the same values\n      if (fn.isArray(rule))\n      {\n        if (!fn.isArray(curr))\n        {\n          return false;\n        }\n\n        if (rule.length !== (<number[]>curr).length)\n        {\n          return false;\n        }\n\n        for (var i = 0; i < rule.length; i++)\n        {\n          if (rule[ i ] !== curr[ i ])\n          {\n            return false;\n          }\n        }\n\n        if (exactly && rule.indexOf( exactlyWith[ prop ] ) === -1)\n        {\n          return false;\n        }\n      }\n\n      // Must be an object with same over & offset.\n      if (fn.isObject(rule))\n      {\n        if (!fn.isObject(curr))\n        {\n          return false;\n        }\n\n        var ruleOffset = rule.offset || 0;\n        var currOffset = (<FrequencyValueEvery>curr).offset || 0;\n\n        if (currOffset !== ruleOffset || curr.every !== rule.every)\n        {\n          return false;\n        }\n\n        if (exactly && (<number>exactlyWith[ prop ] % rule.every) !== ruleOffset)\n        {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Returns the pattern with the given name if one exists. If you add your own\n   * patterns make sure to add them to [[PatternMap]].\n   *\n   * @param name The name of the pattern to return.\n   * @return The instance to the pattern with the same name.\n   */\n  public static withName(name: string): Pattern\n  {\n    return PatternMap[ name ];\n  }\n\n  /**\n   * Finds a matching pattern to the given input searching through [[Patterns]]\n   * for matches. Optionally it will only look at patterns where listed = `true`.\n   *\n   * @param input The schedule input to use.\n   * @param listedOnly When `true` only patterns with [[Pattern.listed]] set to\n   *    `true` will be looked at, otherwise all patterns are looked at.\n   * @param exactlyWith  A day to further validate against for matching.\n   * @see [[Pattern.isMatch]]\n   */\n  public static findMatch<M, I extends ScheduleInput<M> | Schedule<M>>(input: I, listedOnly: boolean = true, exactlyWith?: Day): Pattern\n  {\n    for (let pattern of Patterns)\n    {\n      if ((pattern.listed || !listedOnly) && pattern.isMatch<M, I>( input, exactlyWith ))\n      {\n        return pattern;\n      }\n    }\n\n    return null;\n  }\n\n}\n\n\n/**\n * The list of patterns that can be searched through for matches to schedule\n * input.\n *\n * @see [[Pattern.findMatch]]\n */\nexport let Patterns: Pattern[] = [\n  new Pattern(\n    'none', true,\n    (day: Day) => 'Does not repeat',\n    {\n      year: 1,\n      month: 1,\n      dayOfMonth: 1\n    }\n  ),\n  new Pattern(\n    'daily', true,\n    (day: Day) => 'Daily',\n    {\n\n    }\n  ),\n  new Pattern(\n    'weekly', true,\n    (day: Day) =>  'Weekly on ' + day.format('dddd'),\n    {\n      dayOfWeek: 1\n    }\n  ),\n  new Pattern(\n    'monthlyWeek', true,\n    (day: Day) => 'Monthly on the ' + Suffix.CACHE[day.weekspanOfMonth + 1] + ' ' + day.format('dddd'),\n    {\n      dayOfWeek: 1,\n      weekspanOfMonth: 1\n    }\n  ),\n  new Pattern(\n    'annually', true,\n    (day: Day) => 'Annually on ' + day.format('MMMM Do'),\n    {\n      month: 1,\n      dayOfMonth: 1\n    }\n  ),\n  new Pattern(\n    'annuallyMonthWeek', true,\n    (day: Day) => 'Annually on the ' + Suffix.CACHE[day.weekspanOfMonth + 1] + ' ' + day.format('dddd') + ' of ' + day.format('MMMM'),\n    {\n      month: 1,\n      dayOfWeek: 1,\n      weekspanOfMonth: 1\n    }\n  ),\n  new Pattern(\n    'weekday', true,\n    (day: Day) => 'Every weekday (Monday to Friday)',\n    {\n      dayOfWeek: [Weekday.MONDAY, Weekday.TUESDAY, Weekday.WEDNESDAY, Weekday.THURSDAY, Weekday.FRIDAY]\n    }\n  ),\n  new Pattern(\n    'monthly', true,\n    (day: Day) => 'Monthly on the ' + day.format('Do') + ' day',\n    {\n      dayOfMonth: 1\n    }\n  ),\n  new Pattern(\n    'custom', true,\n    (day: Day) => 'Custom...',\n    {\n      dayOfWeek: false,\n      dayOfMonth: false,\n      lastDayOfMonth: false,\n      dayOfYear: false,\n      year: false,\n      month: false,\n      week: false,\n      weekOfYear: false,\n      weekspanOfYear: false,\n      fullWeekOfYear: false,\n      lastWeekspanOfYear: false,\n      lastFullWeekOfYear: false,\n      weekOfMonth: false,\n      weekspanOfMonth: false,\n      fullWeekOfMonth: false,\n      lastWeekspanOfMonth: false,\n      lastFullWeekOfMonth: false\n    }\n  )\n];\n\n/**\n * The map of patterns keyed by their name.\n *\n * @see [[Pattern.withName]]\n */\nexport let PatternMap: { [name: string]: Pattern } = {};\n\nfor (let pattern of Patterns)\n{\n  PatternMap[ pattern.name ] = pattern;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/Pattern.ts","\nimport { Functions as fn } from './Functions';\nimport { Identifier, IdentifierInput } from './Identifier';\nimport { Day } from './Day';\nimport { Time } from './Time';\nimport { DaySpan } from './DaySpan';\nimport { Iterator, IteratorAction } from './Iterator';\n\n\n/**\n * A map of values in the [[ScheduleModifier]] keyed by the descriptions of the\n * identifiers.\n */\nexport interface ScheduleModifierDescription<T>\n{\n  [description: string]: T\n}\n\n/**\n * An object which carries the span taken from an identifier and the value\n * mapped to it in a [[ScheduleModifier]].\n */\nexport interface ScheduleModifierSpan<T>\n{\n  span: DaySpan,\n  value: T\n}\n\n/**\n * A class that can modify the events of a schedule by storing [[Identifier]]s\n * and an associated value.\n *\n * @typeparam T The type of data that modifies the schedule.\n */\nexport class ScheduleModifier<T>\n{\n\n  /**\n   * The map of values mapped by their [[Identifier]]s.\n   */\n  public map: { [id: string]: T };\n\n\n  /**\n   * Creates a new schedule modifier.\n   */\n  public constructor()\n  {\n    this.map = {};\n  }\n\n  /**\n   * Clears the modifier of all modifications.\n   */\n  public clear(): this\n  {\n    this.map = {};\n\n    return this;\n  }\n\n  /**\n   * Returns `true` if this modifier lacks any modifications, otherwise `false`.\n   */\n  public isEmpty(): boolean\n  {\n    // @ts-ignore\n    for (let id in this.map)\n    {\n      return !id;\n    }\n\n    return true;\n  }\n\n  /**\n   * Gets the most specific value in this modifier for the given day, if none\n   * exists `otherwise` is returned. A modifier can have multiple values for a\n   * given day because [[Identifier]]s represent a span of time.\n   *\n   * @param day The day to get a value for.\n   * @param otherwise What to return if no value exists for the given day.\n   * @param lookAtTime If the specific time of the given day should be looked at.\n   * @returns The most specific value for the given day, or `otherwise`.\n   */\n  public get(day: Day, otherwise: T, lookAtTime: boolean = true): T\n  {\n    let map = this.map;\n\n    return (lookAtTime && map[ day.timeIdentifier ]) ||\n      map[ day.dayIdentifier ] ||\n      map[ day.monthIdentifier ] ||\n      map[ day.weekIdentifier ] ||\n      map[ day.quarterIdentifier ] ||\n      otherwise;\n  }\n\n  /**\n   * Gets the most specific identifier type for the span over the given day.\n   * If the day does not have a modification, `null` is returned.\n   *\n   * @param day The day to get the type for.\n   * @param lookAtTime If the specific time of the given day should be looked at.\n   * @returns The most specific identifier for the given day, otherwise `null`.\n   */\n  public getIdentifier(day: Day, lookAtTime: boolean = true): Identifier\n  {\n    let map = this.map;\n\n    if (lookAtTime && fn.isDefined( map[ day.timeIdentifier ] )) return Identifier.Time;\n    if (fn.isDefined( map[ day.dayIdentifier ] )) return Identifier.Day;\n    if (fn.isDefined( map[ day.monthIdentifier ] )) return Identifier.Month;\n    if (fn.isDefined( map[ day.weekIdentifier ] )) return Identifier.Week;\n    if (fn.isDefined( map[ day.quarterIdentifier ] )) return Identifier.Quarter;\n    if (fn.isDefined( map[ day.year ] )) return Identifier.Year;\n\n    return null;\n  }\n\n  /**\n   * Gets all values in this modifier for the given day. If none exist, an empty\n   * array is returned. The values returned in the array are returned in most\n   * specific to least specific.\n   *\n   * @param day The day to get the values for.\n   * @returns An array of values (modifications) for the given day.\n   */\n  public getAll(day: Day): T[]\n  {\n    let map = this.map;\n    let all: T[] = [];\n\n    if (map[ day.timeIdentifier ]) all.push( map[ day.timeIdentifier ] );\n    if (map[ day.dayIdentifier ]) all.push( map[ day.dayIdentifier ] );\n    if (map[ day.monthIdentifier ]) all.push( map[ day.monthIdentifier ] );\n    if (map[ day.weekIdentifier ]) all.push( map[ day.weekIdentifier ] );\n    if (map[ day.quarterIdentifier ]) all.push( map[ day.quarterIdentifier ] );\n\n    return all;\n  }\n\n  /**\n   * Moves the value/modification from one identifier to another.\n   *\n   * @param from The day to take the identifier from.\n   * @param fromType The identifier type.\n   * @param to The day to move the value to.\n   * @param toType The identifier type to move the value to.\n   */\n  public move(from: Day, fromType: Identifier, to: Day, toType: Identifier): this\n  {\n    let fromIdentifier = fromType.get( from );\n    let toIdentifier = toType.get( to );\n\n    this.map[ toIdentifier ] = this.map[ fromIdentifier ];\n\n    delete this.map[ fromIdentifier ];\n\n    return this;\n  }\n\n  /**\n   * Moves any identifiers with the matching time `fromTime` to `toTime` and\n   * returns the number of moves.\n   *\n   * @param fromTime The time to move from.\n   * @param toTime The time to move to.\n   * @returns The number of modifiers moved.\n   */\n  public moveTime(fromTime: Time, toTime: Time): number\n  {\n    let type: Identifier = Identifier.Time;\n    let moveIds: IdentifierInput[] = [];\n\n    this.iterate().iterate(([id, value]) =>\n    {\n      if (type.is( id ))\n      {\n        let start: Day = type.start( id );\n\n        if (start.sameTime( fromTime ))\n        {\n          moveIds.push( id );\n        }\n      }\n    });\n\n    let moved: number = 0;\n\n    for (let id of moveIds)\n    {\n      let value: T = this.map[ id ];\n      let start: Day = type.start( id );\n      let newStart: Day = start.withTime( toTime );\n      let newId: IdentifierInput = type.get( newStart );\n\n      if (!this.map[ newId ])\n      {\n        this.map[ newId ] = value;\n        delete this.map[ id ];\n        moved++;\n      }\n    }\n\n    return moved;\n  }\n\n  /**\n   * Removes any identifiers and modifications that are at the given time.\n   *\n   * @param time The time to remove.\n   * @returns The number of modifiers removed.\n   */\n  public removeTime(time: Time): number\n  {\n    let type: Identifier = Identifier.Time;\n    let removed: number = 0;\n\n    this.iterate().iterate(([id,], iterator) =>\n    {\n      if (type.is( id ))\n      {\n        let start: Day = type.start( id );\n\n        if (start.sameTime( time ))\n        {\n          iterator.remove();\n          removed++;\n        }\n      }\n    });\n\n    return removed;\n  }\n\n  /**\n   * Sets the value/modification in this map given a day, the value, and the\n   * identifier type.\n   *\n   * @param day The day to take an identifier from.\n   * @param value The value/modification to set.\n   * @param type The identifier type.\n   */\n  public set(day: Day, value: T, type: Identifier): this\n  {\n    this.map[ type.get( day ) ] = value;\n\n    return this;\n  }\n\n  /**\n   * Removes the value/modification from this modifier based on the identifier\n   * pulled from the day.\n   *\n   * @param day The day to take an identifier from.\n   * @param type The identifier type.\n   */\n  public unset(day: Day, type: Identifier): this\n  {\n    delete this.map[ type.get( day ) ];\n\n    return this;\n  }\n\n  /**\n   * Iterates through the modifiers passing the identifier and the related value.\n   *\n   * @returns A new instance of an [[Iterator]].\n   */\n  public iterate(): Iterator<[IdentifierInput, T]>\n  {\n    return new Iterator<[IdentifierInput, T]>(iterator =>\n    {\n      let map = this.map;\n\n      for (let rawId in map)\n      {\n        let asNumber: number = parseInt( rawId );\n        let validAsNumber: boolean = asNumber + '' === rawId;\n        let id: IdentifierInput = validAsNumber ? asNumber : rawId;\n\n        switch (iterator.act([id, map[ rawId ]]))\n        {\n          case IteratorAction.Stop:\n            return;\n          case IteratorAction.Remove:\n            delete map[ rawId ];\n            break;\n        }\n      }\n    });\n  }\n\n  /**\n   * Queries the modifier for all values/modifications which fall in the time\n   * span that the given identifier represents. All identifiers and their value\n   * are passed to the given callback.\n   *\n   * @param prefix The identifier\n   * @returns A new instance of an [[Iterator]].\n   */\n  public query(query: IdentifierInput): Iterator<[IdentifierInput, T]>\n  {\n    return this.iterate()\n      .filter(([id, value]) => Identifier.contains( query, id ));\n    ;\n  }\n\n  /**\n   * Returns all identifiers stored in this modifier.\n   */\n  public identifiers(filter?: (value: T, id: IdentifierInput) => boolean): Iterator<IdentifierInput>\n  {\n    return this.iterate()\n      .filter(([id, value]) => !filter || filter( value, id ))\n      .map<IdentifierInput>(([id, ]) => id)\n    ;\n  }\n\n  /**\n   * Builds a list of spans and the associated values. The spans are calculated\n   * from the identiier key via [[Identifier.span]].\n   *\n   * @param endInclusive If the end date in the spans should be the last\n   *    millisecond of the timespan or the first millisecond of the next.\n   * @returns An array of spans calculated from the identifiers with the\n   *    associated values/modifications.\n   */\n  public spans(endInclusive: boolean = false): Iterator<ScheduleModifierSpan<T>>\n  {\n    return this.iterate()\n      .map(([id, value]) =>\n      {\n        let type: Identifier = Identifier.find(id);\n\n        if (type)\n        {\n          let span = type.span( id, endInclusive );\n\n          return { span, value };\n        }\n      })\n    ;\n  }\n\n  /**\n   * Builds a list of the descriptions of the identifiers in this modifier.\n   *\n   * @param short If the description should use shorter language or longer.\n   * @returns The built list of descriptions.\n   */\n  public describe(short: boolean = false): Iterator<string>\n  {\n    return this.iterate()\n      .map<string>( ([id, ]) =>\n      {\n        let type: Identifier = Identifier.find( id );\n\n        if (type)\n        {\n          return type.describe( id, short );\n        }\n      })\n    ;\n  }\n\n  /**\n   * Builds a map of the values/modifications keyed by the descripton of the\n   * identifier computed via [[Identifier.describe]].\n   *\n   * @param short If the description should use shorter language or longer.\n   * @returns The built map of description to values/modifications.\n   */\n  public describeMap(short: boolean = false): ScheduleModifierDescription<T>\n  {\n    let map = this.map;\n    let out: ScheduleModifierDescription<T> = {};\n\n    for (let id in map)\n    {\n      let type: Identifier = Identifier.find(id);\n\n      if (type)\n      {\n        out[ type.describe( id, short ) ] = map[ id ];\n      }\n    }\n\n    return out;\n  }\n\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/ScheduleModifier.ts","\nimport { Functions as fn } from './Functions';\nimport { FrequencyValue, FrequencyCheck, FrequencyValueEvery, FrequencyValueOneOf } from './Frequency';\nimport { Day, DayInput, DurationInput, DayProperty } from './Day';\nimport { Identifier, IdentifierInput } from './Identifier';\nimport { DaySpan } from './DaySpan';\nimport { Constants } from './Constants';\nimport { Parse } from './Parse';\nimport { Time, TimeInput } from './Time';\nimport { Suffix } from './Suffix';\nimport { ScheduleModifier, ScheduleModifierSpan } from './ScheduleModifier';\nimport { Units } from './Units';\nimport { Iterator, IteratorAction } from './Iterator';\n\n// @ts-ignore\nimport * as moment from 'moment';\n\n\n/**\n * A tuple which identifies an event on the schedule. The tuple contains the\n * total span of the event occurrence, the day of the event (could be the start\n * day, end day, or any days in between for multi-day events) as well as the\n * identifier for the event.\n */\nexport type ScheduleEventTuple = [DaySpan, Day, IdentifierInput];\n\n/**\n * Input given by a user which describes an event schedule.\n *\n * @typeparam M The type of metadata stored in the schedule.\n */\nexport interface ScheduleInput<M>\n{\n\n  /**\n   * @see [[Schedule.start]]\n   */\n  start?: DayInput;\n\n  /**\n   * @see [[Schedule.end]]\n   */\n  end?: DayInput;\n\n  /**\n   * A shortcut to setting the [[Schedule.start]], [[Schedule.end]],\n   * [[Schedule.year]], [[Schedule.month]], and [[Schedule.dayOfMonth]].\n   */\n  on?: DayInput;\n\n  /**\n   * @see [[Schedule.times]]\n   */\n  times?: TimeInput[];\n\n  /**\n   * @see [[Schedule.duration]]\n   */\n  duration?: number;\n\n  /**\n   * @see [[Schedule.durationUnit]]\n   */\n  durationUnit?: DurationInput;\n\n  /**\n   * An array of days or identifiers which should be excluded from the schedule.\n   *\n   * @see [[Schedule.exclude]]\n   */\n  exclude?: (Day | IdentifierInput)[];\n\n  /**\n   * An array of days or identifiers which should be included in the schedule.\n   *\n   * @see [[Schedule.include]]\n   */\n  include?: (Day | IdentifierInput)[];\n\n  /**\n   * An array of days or identifiers which should be canceled in the schedule.\n   *\n   * @see [[Schedule.cancel]]\n   */\n  cancel?: (Day | IdentifierInput)[];\n\n  /**\n   * @see [[Schedule.meta]]\n   */\n  meta?: { [identifier: string]: M };\n\n  /**\n   * @see [[Schedule.month]]\n   */\n  month?: FrequencyValue;\n\n  /**\n   * @see [[Schedule.year]]\n   */\n  year?: FrequencyValue;\n\n  /**\n   * @see [[Schedule.week]]\n   */\n  week?: FrequencyValue;\n\n  /**\n   * @see [[Schedule.dayOfWeek]]\n   */\n  dayOfWeek?: FrequencyValue;\n\n  /**\n   * @see [[Schedule.dayOfMonth]]\n   */\n  dayOfMonth?: FrequencyValue;\n\n  /**\n   * @see [[Schedule.lastDayOfMonth]]\n   */\n  lastDayOfMonth?: FrequencyValue;\n\n  /**\n   * @see [[Schedule.dayOfYear]]\n   */\n  dayOfYear?: FrequencyValue;\n\n  /**\n   * @see [[Schedule.weekOfYear]]\n   */\n  weekOfYear?: FrequencyValue;\n\n  /**\n   * @see [[Schedule.weekspanOfYear]]\n   */\n  weekspanOfYear?: FrequencyValue;\n\n  /**\n   * @see [[Schedule.fullWeekOfYear]]\n   */\n  fullWeekOfYear?: FrequencyValue;\n\n  /**\n   * @see [[Schedule.lastWeekspanOfYear]]\n   */\n  lastWeekspanOfYear?: FrequencyValue;\n\n  /**\n   * @see [[Schedule.lastFullWeekOfYear]]\n   */\n  lastFullWeekOfYear?: FrequencyValue;\n\n  /**\n   * @see [[Schedule.weekOfMonth]]\n   */\n  weekOfMonth?: FrequencyValue;\n\n  /**\n   * @see [[Schedule.weekspanOfMonth]]\n   */\n  weekspanOfMonth?: FrequencyValue;\n\n  /**\n   * @see [[Schedule.fullWeekOfMonth]]\n   */\n  fullWeekOfMonth?: FrequencyValue;\n\n  /**\n   * @see [[Schedule.lastWeekspanOfMonth]]\n   */\n  lastWeekspanOfMonth?: FrequencyValue;\n\n  /**\n   * @see [[Schedule.lastFullWeekOfMonth]]\n   */\n  lastFullWeekOfMonth?: FrequencyValue;\n\n  /**\n   * The function to parse metadata with.\n   */\n  parseMeta?: (input: any) => M;\n}\n\n\n/**\n * A class which describes when an event occurs over what time and if it repeats.\n *\n * @typeparam M The type of metadata stored in the schedule.\n */\nexport class Schedule<M>\n{\n\n  /**\n   * The earliest an event can occur in the schedule, or `null` if there are no\n   * restrictions when the earliest event can occur. This day is inclusive.\n   */\n  public start: Day;\n\n  /**\n   * The latest an event can occur in the schedule, or `null` if there are no\n   * restrictions when the latest event can occur. This day is inclusive.\n   */\n  public end: Day;\n\n  /**\n   * The length of events in this schedule.\n   */\n  public duration: number;\n\n  /**\n   * The unit which describes the duration of the event.\n   */\n  public durationUnit: DurationInput;\n\n  /**\n   * The times at which the events occur on the days they should. If there are\n   * no times specified its assumed to be an all day event - potentially over\n   * multiple days or weeks based on [[Schedule.duration]] and\n   * [[Schedule.durationUnit]].\n   */\n  public times: Time[];\n\n  /**\n   * The number of days an event in this schedule lasts PAST the starting day.\n   * If this is a full day event with a duration greater than zero this value\n   * will be greater than one. If this event occurs at a specific time with a\n   * given duration that is taken into account and if it passes over into the\n   * next day this value will be greater than one. This value is used to look\n   * back in time when trying to figure out what events start or overlap on a\n   * given day.\n   */\n  public durationInDays: number;\n\n  /**\n   * A set of identifiers which mark what days or times are excluded on the\n   * schedule. This typically represents the set of event occurrences removed.\n   */\n  public exclude: ScheduleModifier<boolean>;\n\n  /**\n   * A set of identifiers which mark what days or times are included outside\n   * the normal series of days on the schedule. This typically represents\n   * an event occurrence which is moved so its added to the exclude and include\n   * sets.\n   */\n  public include: ScheduleModifier<boolean>;\n\n  /**\n   * A set of identifiers which mark what days, times, weeks, months, etc that\n   * should have all event occurrences cancelled.\n   */\n  public cancel: ScheduleModifier<boolean>;\n\n  /**\n   * A map of metadata keyed by an identifier. The metadata is placed in\n   * [[CalendarEvent]].\n   */\n  public meta: ScheduleModifier<M>;\n\n  /**\n   * How frequent the event occurs based on [[Day.dayOfWeek]].\n   */\n  public dayOfWeek: FrequencyCheck;\n\n  /**\n   * How frequent the event occurs based on [[Day.dayOfMonth]].\n   */\n  public dayOfMonth: FrequencyCheck;\n\n  /**\n   * How frequent the event occurs based on [[Day.lastDayOfMonth]].\n   */\n  public lastDayOfMonth: FrequencyCheck;\n\n  /**\n   * How frequent the event occurs based on [[Day.dayOfYear]].\n   */\n  public dayOfYear: FrequencyCheck;\n\n  /**\n   * How frequent the event occurs based on [[Day.month]].\n   */\n  public month: FrequencyCheck;\n\n  /**\n   * How frequent the event occurs based on [[Day.week]].\n   */\n  public week: FrequencyCheck;\n\n  /**\n   * How frequent the event occurs based on [[Day.weekOfYear]].\n   */\n  public weekOfYear: FrequencyCheck;\n\n  /**\n   * How frequent the event occurs based on [[Day.weekspanOfYear]].\n   */\n  public weekspanOfYear: FrequencyCheck;\n\n  /**\n   * How frequent the event occurs based on [[Day.fullWeekOfYear]].\n   */\n  public fullWeekOfYear: FrequencyCheck;\n\n  /**\n   * How frequent the event occurs based on [[Day.lastWeekspanOfYear]].\n   */\n  public lastWeekspanOfYear: FrequencyCheck;\n\n  /**\n   * How frequent the event occurs based on [[Day.lastFullWeekOfYear]].\n   */\n  public lastFullWeekOfYear: FrequencyCheck;\n\n  /**\n   * How frequent the event occurs based on [[Day.weekOfMonth]].\n   */\n  public weekOfMonth: FrequencyCheck;\n\n  /**\n   * How frequent the event occurs based on [[Day.weekspanOfMonth]].\n   */\n  public weekspanOfMonth: FrequencyCheck;\n\n  /**\n   * How frequent the event occurs based on [[Day.fullWeekOfMonth]].\n   */\n  public fullWeekOfMonth: FrequencyCheck;\n\n  /**\n   * How frequent the event occurs based on [[Day.lastWeekspanOfMonth]].\n   */\n  public lastWeekspanOfMonth: FrequencyCheck;\n\n  /**\n   * How frequent the event occurs based on [[Day.lastFullWeekOfMonth]].\n   */\n  public lastFullWeekOfMonth: FrequencyCheck;\n\n  /**\n   * How frequent the event occurs based on [[Day.year]].\n   */\n  public year: FrequencyCheck;\n\n  /**\n   * The array of frequency functions which had valid frequencies.\n   *\n   * @see [[FrequencyCheck.given]]\n   */\n  public checks: FrequencyCheck[];\n\n\n  /**\n   * Creates a schedule based on the given input.\n   *\n   * @param input The input which describes the schedule of events.\n   */\n  public constructor(input?: ScheduleInput<M>)\n  {\n    this.exclude = new ScheduleModifier<boolean>();\n    this.include = new ScheduleModifier<boolean>();\n    this.cancel = new ScheduleModifier<boolean>();\n    this.meta = new ScheduleModifier<M>();\n\n    if (fn.isDefined(input))\n    {\n      this.set(input);\n    }\n  }\n\n  /**\n   * Sets the schedule with the given input.\n   *\n   * @param input The input or schedule which describes the schedule of events.\n   * @param parseMeta A function to use when parsing meta input into the desired type.\n   * @see [[Parse.schedule]]\n   */\n  public set(input: ScheduleInput<M> | Schedule<M>,\n    parseMeta: (input: any) => M = (x => <M>x)): this\n  {\n    if (input instanceof Schedule)\n    {\n      Parse.schedule<M>( input.toInput(), undefined, this);\n    }\n    else\n    {\n      Parse.schedule<M>(input, fn.coalesce( input.parseMeta, parseMeta ), this);\n    }\n\n    return this;\n  }\n\n  /**\n   * Returns the last event time specified or `undefined` if this schedule is\n   * for an all day event.\n   */\n  public get lastTime(): Time\n  {\n    return this.times[ this.times.length - 1 ];\n  }\n\n  /**\n   * The [[Identifier]] for this schedule. Either [[Identifier.Day]] or\n   * [[Identifier.Time]].\n   */\n  public get identifierType(): Identifier\n  {\n    return this.isFullDay() ? Identifier.Day : Identifier.Time;\n  }\n\n  /**\n   * Updates the [[Schedule.durationInDays]] variable based on the\n   * [[Schedule.lastTime]] (if any), the [[Schedule.duration]] and it's\n   * [[Schedule.durationUnit]].\n   */\n  public updateDurationInDays(): this\n  {\n    let start: number = this.lastTime ? this.lastTime.toMilliseconds() : 0;\n    let duration: number = this.duration * (Constants.DURATION_TO_MILLIS[ this.durationUnit ] || 0);\n    let exclude: number = Constants.MILLIS_IN_DAY;\n    let day: number = Constants.MILLIS_IN_DAY;\n\n    this.durationInDays = Math.max(0, Math.ceil((start + duration - exclude) / day));\n\n    return this;\n  }\n\n  /**\n   * Updates [[Schedule.checks]] based on the frequencies that were specified\n   * in the schedule input.\n   */\n  public updateChecks(): this\n  {\n    this.checks = Parse.givenFrequency([\n      this.year,\n      this.month,\n      this.week,\n      this.weekOfYear,\n      this.fullWeekOfYear,\n      this.weekspanOfYear,\n      this.lastFullWeekOfYear,\n      this.lastWeekspanOfYear,\n      this.weekOfMonth,\n      this.weekspanOfMonth,\n      this.fullWeekOfMonth,\n      this.lastWeekspanOfMonth,\n      this.lastFullWeekOfMonth,\n      this.dayOfWeek,\n      this.dayOfMonth,\n      this.lastDayOfMonth,\n      this.dayOfYear\n    ]);\n\n    return this;\n  }\n\n  /**\n   * Determines whether the given day lies between the earliest and latest\n   * valid day in the schedule.\n   *\n   * @param day The day to test.\n   * @returns `true` if the day lies in the schedule, otherwise `false`.\n   * @see [[Schedule.start]]\n   * @see [[Schedule.end]]\n   */\n  public matchesSpan(day: Day): boolean\n  {\n    return (this.start === null || day.isSameOrAfter(this.start)) &&\n      (this.end === null || day.isBefore(this.end));\n  }\n\n  /**\n   * Determines whether the given range overlaps with the earliest and latest\n   * valid days in this schedule (if any).\n   *\n   * @param start The first day in the range.\n   * @param end The last day in the range.\n   * @returns `true` if the range intersects with the schedule, otherwise `false`.\n   * @see [[Schedule.start]]\n   * @see [[Schedule.end]]\n   */\n  public matchesRange(start: Day, end: Day): boolean\n  {\n    if (this.start && end.isBefore(this.start))\n    {\n      return false;\n    }\n\n    if (this.end && start.isAfter(this.end))\n    {\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Determines whether the given day is explicitly excluded in the schedule.\n   *\n   * @param day The day to test.\n   * @param lookAtTime lookAtTime If the specific time of the given day should\n   *    be looked at.\n   * @returns `true` if the day was excluded, otherwise `false`.\n   */\n  public isExcluded(day: Day, lookAtTime: boolean = true): boolean\n  {\n    return this.exclude.get( day, false, lookAtTime );\n  }\n\n  /**\n   * Determines whether the given day is explicitly included in the schedule.\n   *\n   * @param day The day to test.\n   * @param lookAtTime lookAtTime If the specific time of the given day should\n   *    be looked at.\n   * @returns `true` if the day is NOT explicitly included, otherwise `false`.\n   */\n  public isIncluded(day: Day, lookAtTime: boolean = true): boolean\n  {\n    return this.include.get( day, false, lookAtTime );\n  }\n\n  /**\n   * Determines whether the given day is cancelled in the schedule.\n   *\n   * @param day The day to test.\n   * @param lookAtTime lookAtTime If the specific time of the given day should\n   *    be looked at.\n   * @returns `true` if the day was cancelled, otherwise `false`.\n   */\n  public isCancelled(day: Day, lookAtTime: boolean = true): boolean\n  {\n    return this.cancel.get( day, false, lookAtTime );\n  }\n\n  /**\n   * Returns the metadata for the given day or `null` if there is none.\n   *\n   * @param day The day to return the metadata for.\n   * @param otherwise The data to return if none exists for the given day.\n   * @param lookAtTime lookAtTime If the specific time of the given day should\n   *    be looked at.\n   * @returns The metadata or `null`.\n   */\n  public getMeta(day: Day, otherwise: M = null, lookAtTime: boolean = true): M\n  {\n    return this.meta.get( day, otherwise, lookAtTime );\n  }\n\n  /**\n   * Returns all metadata for the given day or an empty array if there is none.\n   *\n   * @param day The day to return the metadata for.\n   * @returns The array of metadata ordered by priority or an empty array.\n   */\n  public getMetas(day: Day): M[]\n  {\n    return this.meta.getAll( day );\n  }\n\n  /**\n   * Returns whether the events in the schedule are all day long or start at\n   * specific times. Full day events start at the start of the day and end at\n   * the start of the next day (if the duration = `1` and durationUnit = 'days').\n   * Full day events have no times specified and should have a durationUnit of\n   * either `days` or `weeks`.\n   */\n  public isFullDay(): boolean\n  {\n    return this.times.length === 0;\n  }\n\n  /**\n   * Sets whether this schedule is a full day event if it is not already. If\n   * this schedule is a full day event and `false` is passed to this function\n   * a single timed event will be added based on `defaultTime`. If this schedule\n   * has timed events and `true` is passed to make the schedule full day, the\n   * timed events are removed from this schedule. If the durationUnit is not the\n   * expected unit based on the new full day flag - the duration is reset to 1\n   * and the duration unit is set to the expected unit.\n   *\n   * @param fullDay Whether this schedule should represent a full day event or\n   *    timed events.\n   * @param defaultTime If `fullDay` is `false` and this schedule is currently\n   *    a full day event - this time will be used as the time of the first event.\n   */\n  public setFullDay(fullDay: boolean = true, defaultTime: TimeInput = '08:00'): this\n  {\n    if (fullDay !== this.isFullDay())\n    {\n      if (fullDay)\n      {\n        this.times = [];\n\n        if (this.durationUnit !== 'days' && this.durationUnit !== 'day')\n        {\n          this.duration = 1;\n          this.durationUnit = 'days';\n        }\n      }\n      else\n      {\n        this.times = [Parse.time( defaultTime )];\n\n        if (this.durationUnit !== 'hours' && this.durationUnit !== 'hour')\n        {\n          this.duration = 1;\n          this.durationUnit = 'hours';\n        }\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * Adjusts the [[Schedule.start]] and [[Schedule.end]] dates specified on this\n   * schedule if this schedule represents a single event and the `start` and\n   * `end` are already set or `addSpan` is `true`.\n   *\n   * @param addSpan If `true`, the `start` and `end` dates will always be\n   *    adjusted if this schedule is a single event.\n   */\n  public adjustDefinedSpan(addSpan: boolean = false): this\n  {\n    let single: DaySpan = this.getSingleEventSpan();\n\n    if (single && (addSpan || (this.start && this.end)))\n    {\n      this.start = single.start.start();\n      this.end = single.end.end();\n    }\n\n    return this;\n  }\n\n  /**\n   * Returns a span of time for a schedule with full day events starting on the\n   * start of the given day with the desired duration in days or weeks.\n   *\n   * @param day The day the span starts on.\n   * @returns The span of time starting on the given day.\n   */\n  public getFullSpan(day: Day): DaySpan\n  {\n    let start: Day = day.start();\n    let end: Day = start.add( this.duration, this.durationUnit );\n\n    return new DaySpan( start, end );\n  }\n\n  /**\n   * Returns a span of time starting on the given day at the given day with the\n   * duration specified on this schedule.\n   *\n   * @param day The day the span starts on.\n   * @param time The time of day the span starts.\n   * @returns The span of time calculated.\n   */\n  public getTimeSpan(day: Day, time: Time): DaySpan\n  {\n    let start: Day = day.withTime( time );\n    let end: Day = start.add( this.duration, this.durationUnit );\n\n    return new DaySpan( start, end );\n  }\n\n  /**\n   * Determines whether the given day is a day on the schedule for the start\n   * of an event. If an event is more than one day and the day given is not the\n   * start this may return `false`. This does not test for event instances\n   * that exist through [[Schedule.include]].\n   *\n   * @param day The day to test.\n   * @returns `true` if the day marks the start of an event on the schedule.\n   * @see [[Schedule.isIncluded]]\n   * @see [[Schedule.isFullyExcluded]]\n   * @see [[Schedule.matchesSpan]]\n   */\n  public matchesDay(day: Day): boolean\n  {\n    if (this.isIncluded( day, false ))\n    {\n      return true;\n    }\n\n    if (!this.matchesSpan( day) || this.isFullyExcluded( day ))\n    {\n      return false;\n    }\n\n    for (let check of this.checks)\n    {\n      if (!check( <number>day[ check.property ] ))\n      {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Determines whether the given day has events added through\n   * [[Schedule.include]].\n   *\n   * @param day The day to look for included times on.\n   * @returns `true` if there are included event instances on the given day,\n   *    otherwise `false`.\n   */\n  public hasIncludedTime(day: Day): boolean\n  {\n    return !this.iterateIncludeTimes( day ).isEmpty();\n  }\n\n  /**\n   * Determines whether the given day is fully excluded from the schedule. A\n   * fully excluded day is one that has a day-wide exclusion, or the schedule\n   * is not an all-day event and all times in the schedule are specifically\n   * excluded.\n   *\n   * @param day The day to test.*\n   * @returns `true` if he day is fully excluded, otherwise `false`.\n   */\n  public isFullyExcluded(day: Day): boolean\n  {\n    if (this.isExcluded(day, false))\n    {\n      return true;\n    }\n\n    if (this.isFullDay())\n    {\n      return false;\n    }\n\n    for (let time of this.times)\n    {\n      if (!this.isExcluded( day.withTime( time ) ))\n      {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Finds the next day an event occurs on the schedule given a day to start,\n   * optionally including it, and a maximum number of days to look ahead.\n   *\n   * @param day The day to start to search from.\n   * @param includeDay If the given day should be included in the search.\n   * @param lookAhead The maximum number of days to look ahead from the given\n   *     day for event occurrences.\n   * @returns The next day on the schedule or `null` if none exists.\n   */\n  public nextDay(day: Day, includeDay: boolean = false, lookAhead: number = 366): Day\n  {\n    return this.iterateDaycast(day, 1, true, includeDay, lookAhead).first();\n  }\n\n  /**\n   * Finds the next specified number of days that events occur on the schedule\n   * given a day to start, optionally including it, and a maximum number of days\n   * to look ahead.\n   *\n   * @param day The day to start to search from.\n   * @param max The maximum number of days to return in the result.\n   * @param includeDay If the given day should be included in the search.\n   * @param lookAhead The maximum number of days to look ahead from the given\n   *     day for event occurrences.\n   * @returns An array containing the next days on the schedule that events\n   *    start or an empty array if there are none.\n   */\n  public nextDays(day: Day, max: number, includeDay: boolean = false, lookAhead: number = 366): Iterator<Day>\n  {\n    return this.iterateDaycast(day, max, true, includeDay, lookAhead);\n  }\n\n  /**\n   * Finds the previous day an event occurs on the schedule given a day to start,\n   * optionally including it, and a maximum number of days to look behind.\n   *\n   * @param day The day to start to search from.\n   * @param includeDay If the given day should be included in the search.\n   * @param lookBack The maximum number of days to look behind from the given\n   *     day for event occurrences.\n   * @returns The previous day on the schedule or `null` if none exists.\n   */\n  public prevDay(day: Day, includeDay: boolean = false, lookBack: number = 366): Day\n  {\n    return this.iterateDaycast(day, 1, false, includeDay, lookBack).first();\n  }\n\n  /**\n   * Finds the previous specified number of days that events occur on the\n   * schedule given a day to start, optionally including it, and a maximum\n   * number of days to look behind.\n   *\n   * @param day The day to start to search from.\n   * @param max The maximum number of days to return in the result.\n   * @param includeDay If the given day should be included in the search.\n   * @param lookAhead The maximum number of days to look behind from the given\n   *     day for event occurrences.\n   * @returns An array containing the previous days on the schedule that events\n   *    start or an empty array if there are none.\n   */\n  public prevDays(day: Day, max: number, includeDay: boolean = false, lookBack: number = 366): Iterator<Day>\n  {\n    return this.iterateDaycast(day, max, false, includeDay, lookBack);\n  }\n\n  /**\n   * Iterates over days that events start in the schedule given a day to start,\n   * a maximum number of days to find, and a direction to look.\n   *\n   * @param day The day to start to search from.\n   * @param max The maximum number of days to iterate.\n   * @param next If `true` this searches forward, otherwise `false` is backwards.\n   * @param includeDay If the given day should be included in the search.\n   * @param lookup The maximum number of days to look through from the given\n   *     day for event occurrences.\n   * @returns A new Iterator for the days found in the cast.\n   * @see [[Schedule.iterateSpans]]\n   */\n  public iterateDaycast(day: Day, max: number, next: boolean, includeDay: boolean = false, lookup: number = 366): Iterator<Day>\n  {\n    return new Iterator<Day>(iterator =>\n    {\n      let iterated: number = 0;\n\n      for (let days = 0; days < lookup; days++)\n      {\n        if (!includeDay || days > 0)\n        {\n          day = next ? day.next() : day.prev();\n        }\n\n        if (!this.iterateSpans( day, false ).isEmpty())\n        {\n          let action: IteratorAction = iterator.act( day );\n\n          if (action === IteratorAction.Stop || ++iterated >= max)\n          {\n            return;\n          }\n        }\n      }\n    });\n  }\n\n  /**\n   * Iterates through the spans (event instances) that start on or covers the\n   * given day.\n   *\n   * @param day The day to look for spans on.\n   * @param covers If `true` spans which span multiple days will be looked at\n   *    to see if they intersect with the given day, otherwise `false` will\n   *    only look at the given day for the start of events.\n   * @returns A new Iterator for all the spans found.\n   */\n  public iterateSpans(day: Day, covers: boolean = false): Iterator<DaySpan>\n  {\n    return new Iterator<DaySpan>(iterator =>\n    {\n      let current: Day = day;\n      let lookBehind: number = covers ? this.durationInDays : 0;\n\n      // If the events start at the end of the day and may last multiple days....\n      if (this.isFullDay())\n      {\n        // If the schedule has events which span multiple days we need to look\n        // backwards for events that overlap with the given day.\n        while (lookBehind >= 0)\n        {\n          // If the current day matches the schedule rules...\n          if (this.matchesDay( current))\n          {\n            // Build a DaySpan with the given start day and the schedules duration.\n            let span: DaySpan = this.getFullSpan( current);\n\n            // If that dayspan intersects with the given day, it's a winner!\n            if (span.matchesDay( day ))\n            {\n              switch (iterator.act( span ))\n              {\n                case IteratorAction.Stop:\n                  return;\n              }\n            }\n          }\n\n          current = current.prev();\n          lookBehind--;\n        }\n      }\n      // This schedule has events which start at certain times\n      else\n      {\n        // If the schedule has events which span multiple days we need to look\n        // backwards for events that overlap with the given day.\n        while (lookBehind >= 0)\n        {\n          // If the current day matches the schedule rules...\n          if (this.matchesDay( current ))\n          {\n            // Iterate through each daily occurrence in the schedule...\n            for (let time of this.times)\n            {\n              let span: DaySpan = this.getTimeSpan( current, time );\n\n              // If the event intersects with the given day and the occurrence\n              // has not specifically been excluded...\n              if (span.matchesDay( day ) && !this.isExcluded( span.start, true ))\n              {\n                switch (iterator.act( span ))\n                {\n                  case IteratorAction.Stop:\n                    return;\n                }\n              }\n            }\n          }\n          else\n          {\n            // The current day does not match the schedule, however the schedule\n            // might have moved/random event occurrents on the current day.\n            // We only want the ones that overlap with the given day.\n            this.iterateIncludeTimes(current, day).iterate((span, timeIterator) =>\n            {\n              switch (iterator.act( span ))\n              {\n                case IteratorAction.Stop:\n                  timeIterator.stop();\n                  break;\n              }\n            })\n\n            if (iterator.action === IteratorAction.Stop)\n            {\n              return;\n            }\n          }\n\n          current = current.prev();\n          lookBehind--;\n        }\n      }\n    });\n  }\n\n  /**\n   * Determines if the given day is on the schedule and the time specified on\n   * the day matches one of the times on the schedule.\n   *\n   * @param day The day to test.\n   * @returns `true` if the day and time match the schedule, otherwise false.\n   */\n  public matchesTime(day: Day): boolean\n  {\n    return !!this.iterateSpans( day, true ).first( span => span.start.sameMinute( day ) );\n  }\n\n  /**\n   * Determines if the given day is covered by this schedule. A schedule can\n   * specify events that span multiple days - so even though the day does not\n   * match the starting day of a span - it can be a day that is within the\n   * schedule.\n   *\n   * @param day The day to test.\n   * @returns `true` if the day is covered by an event on this schedule,\n   *    otherwise `false`.\n   */\n  public coversDay(day: Day): boolean\n  {\n    return !this.iterateSpans( day, true ).isEmpty();\n  }\n\n  /**\n   * Determines if the given timestamp lies in an event occurrence on this\n   * schedule.\n   *\n   * @param day The timestamp to test against the schedule.\n   * @return `true` if the timestamp lies in an event occurrent start and end\n   *    timestamps, otherwise `false`.\n   */\n  public coversTime(day: Day): boolean\n  {\n    return !!this.iterateSpans( day, true ).first( span => span.contains( day ) );\n  }\n\n  /**\n   * Sets the frequency for the given property. This does not update the\n   * [[Schedule.checks]] array, the [[Schedule.updateChecks]] function needs\n   * to be called.\n   *\n   * @param property The frequency to update.\n   * @param frequency The new frequency.\n   */\n  public setFrequency(property: DayProperty, frequency?: FrequencyValue): this\n  {\n    this[ property ] = Parse.frequency( frequency, property );\n\n    return this;\n  }\n\n  /**\n   * Changes the exclusion status of the event at the given time. By default\n   * this excludes this event - but `false`  may be passed to undo an exclusion.\n   *\n   * @param time The start time of the event occurrence to exclude or include.\n   * @param excluded Whether the event should be excluded.\n   */\n  public setExcluded(time: Day, excluded: boolean = true): this\n  {\n    let type: Identifier = this.identifierType;\n\n    this.exclude.set( time, excluded, type );\n    this.include.set( time, !excluded, type );\n\n    return this;\n  }\n\n  /**\n   * Changes the cancellation status of the event at the given start time. By\n   * default this cancels the event occurrence - but `false` may be passed to\n   * undo a cancellation.\n   *\n   * @param time The start time of the event occurrence to cancel or uncancel.\n   * @param cancelled Whether the event should be cancelled.\n   */\n  public setCancelled(time: Day, cancelled: boolean = true): this\n  {\n    this.cancel.set( time, cancelled, this.identifierType );\n\n    return this;\n  }\n\n  /**\n   * Removes the time from this schedule and all related included, excluded,\n   * cancelled instances as well as metadata.\n   *\n   * @param time The time to remove from the schedule.\n   * @param removeInclude If any included instances should be removed as well.\n   * @returns `true` if the time was removed, otherwise `false`.\n   */\n  public removeTime(time: Time, removeInclude: boolean = true): boolean\n  {\n    let found: boolean = false;\n\n    for (let i = 0; i < this.times.length && !found; i++)\n    {\n      if (found = time.matches( this.times[ i ] ))\n      {\n        this.times.splice( i, 1 );\n      }\n    }\n\n    if (found)\n    {\n      if (removeInclude)\n      {\n        this.include.removeTime( time );\n      }\n\n      this.exclude.removeTime( time );\n      this.cancel.removeTime( time );\n      this.meta.removeTime( time );\n    }\n\n    return found;\n  }\n\n  /**\n   * Moves the event instance starting at `fromTime` to `toTime` optionally\n   * placing `meta` in the schedules metadata for the new time `toTime`.\n   * If this schedule has a single event ([[Schedule.isSingleEvent]]) then the\n   * only value needed is `toTime` and not `fromTime`.\n   *\n   * @param toTime The timestamp of the new event.\n   * @param fromTime The timestamp of the event on the schedule to move if this\n   *    schedule generates multiple events.\n   * @returns `true` if the schedule had the event moved, otherwise `false`.\n   */\n  public move(toTime: Day, fromTime?: Day, meta?: M): boolean\n  {\n    if (!this.moveSingleEvent( toTime ) && fromTime)\n    {\n      return this.moveInstance( fromTime, toTime );\n    }\n\n    return false;\n  }\n\n  /**\n   * Moves a time specified in this schedule to the given time, adjusting\n   * any cancelled event instances, metadata, and any excluded and included\n   * event instances.\n   *\n   * @param fromTime The time to move.\n   * @param toTime The new time in the schedule.\n   * @returns `true` if time was moved, otherwise `false`.\n   */\n  public moveTime(fromTime: Time, toTime: Time): boolean\n  {\n    let found: boolean = false;\n\n    for (let i = 0; i < this.times.length && !found; i++)\n    {\n      if (found = fromTime.matches( this.times[ i ] ))\n      {\n        this.times.splice( i, 1, toTime );\n      }\n    }\n\n    if (found)\n    {\n      this.include.moveTime( fromTime, toTime );\n      this.exclude.moveTime( fromTime, toTime );\n      this.cancel.moveTime( fromTime, toTime );\n      this.meta.moveTime( fromTime, toTime );\n\n      this.adjustDefinedSpan( false );\n    }\n\n    return found;\n  }\n\n  /**\n   * Moves the event instance starting at `fromTime` to `toTime` optionally\n   * placing `meta` in the schedules metadata for the new time `toTime`. A move\n   * is accomplished by excluding the current event and adding an inclusion of\n   * the new day & time.\n   *\n   * @param fromTime The timestamp of the event on the schedule to move.\n   * @param toTime The timestamp of the new event.\n   * @returns `true`.\n   * @see [[Schedule.move]]\n   */\n  public moveInstance(fromTime: Day, toTime: Day): boolean\n  {\n    let type: Identifier = this.identifierType;\n\n    this.exclude.set( fromTime, true, type );\n    this.exclude.set( toTime, false, type );\n\n    this.include.set( toTime, true, type );\n    this.include.set( fromTime, false, type );\n\n    if (this.cancel.get( fromTime, false ) && !this.cancel.get( toTime, false ))\n    {\n      this.cancel.set( toTime, true, type );\n\n      if (this.cancel.getIdentifier( fromTime ) === type)\n      {\n        this.cancel.unset( fromTime, type );\n      }\n    }\n\n    let meta: M = this.meta.get( fromTime, null );\n\n    if (meta && meta !== this.meta.get( toTime, null ))\n    {\n      this.meta.set( toTime, meta, type );\n\n      if (this.meta.getIdentifier( fromTime ) === type)\n      {\n        this.meta.unset( fromTime, type );\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Moves the single event in this schedule to the given day/time if applicable.\n   * If this schedule is not a single event schedule then `false` is returned.\n   * If this schedule is a timed event the time will take the time of the given\n   * `toTime` of `takeTime` is `true`.\n   *\n   * @param toTime The time to move the single event to.\n   * @param takeTime If this schedule has a single timed event, should the time\n   *    of the event be changed to the time of the given `toTime`?\n   * @returns `true` if the schedule was adjusted, otherwise `false`.\n   * @see [[Schedule.move]]\n   */\n  public moveSingleEvent(toTime: Day, takeTime: boolean = true): boolean\n  {\n    if (!this.isSingleEvent())\n    {\n      return false;\n    }\n\n    for (let check of this.checks)\n    {\n      let prop: DayProperty  = check.property;\n      let value = toTime[ prop ];\n      let frequency: FrequencyCheck = Parse.frequency( [value], prop );\n\n      this[ prop ] = frequency;\n    }\n\n    if (this.times.length === 1 && takeTime)\n    {\n      this.times = [toTime.asTime()];\n    }\n\n    this.updateChecks();\n\n    let span: DaySpan = this.getSingleEventSpan();\n\n    if (this.start)\n    {\n      this.start = span.start.start();\n    }\n\n    if (this.end)\n    {\n      this.end = span.end.end();\n    }\n\n    return true;\n  }\n\n  /**\n   * Returns the span of the single event in this schedule if it's that type of\n   * schedule, otherwise `null` is returned.\n   *\n   * @returns A span of the single event, otherwise `null`.\n   * @see [[Schedule.isSingleEvent]]\n   */\n  public getSingleEventSpan(): DaySpan\n  {\n    if (!this.isSingleEvent())\n    {\n      return null;\n    }\n\n    let startOfYear: Day = Day.build( this.year.input[0], 0, 1 );\n    let start: Day = this.iterateDaycast( startOfYear, 1, true, true, 366 ).first();\n\n    if (!start)\n    {\n      return null;\n    }\n\n    return this.isFullDay() ?\n      this.getFullSpan( start ) :\n      this.getTimeSpan( start, this.times[ 0 ] );\n  }\n\n  /**\n   * Determines whether this schedule produces a single event, and no more.\n   * If this schedule has any includes, it's assumed to be a multiple event\n   * schedule. A single event can be detected in the following scenarios where\n   * each frequency has a single occurrence (see [[Schedule.isSingleFrequency]]).\n   *\n   * - year, day of year\n   * - year, month, day of month\n   * - year, month, week of month, day of week\n   * - year, week of year, day of week\n   *\n   * @returns `true` if this schedule produces a single event, otherwise `false`.\n   */\n  public isSingleEvent(): boolean\n  {\n    // 0 = full day, 1 = once a day, 1+ = multiple events a day\n    if (this.times.length > 1)\n    {\n      return false;\n    }\n\n    // Let's assume if there are includes, this is not a single event.\n    if (!this.include.isEmpty())\n    {\n      return false;\n    }\n\n    // If this can occur on multiple years, not a single event.\n    if (!this.isSingleYear())\n    {\n      return false;\n    }\n\n    // If this is a specific year and day of the year: single!\n    if (this.isSingleDayOfYear())\n    {\n      return true;\n    }\n\n    // If this is a specific year, month, and day of month: single!\n    if (this.isSingleMonth() && this.isSingleDayOfMonth())\n    {\n      return true;\n    }\n\n    // If this is a specific year, month, week of the month, day of the week: single!\n    if (this.isSingleMonth() && this.isSingleWeekOfMonth() && this.isSingleDayOfWeek())\n    {\n      return true;\n    }\n\n    // If this is a specific year, week of the year, day of the week: single!\n    if (this.isSingleWeekOfYear() && this.isSingleDayOfWeek())\n    {\n      return true;\n    }\n\n    // Doesn't look like a single event.\n    return false;\n  }\n\n  /**\n   * @returns `true` if this schedule produces events only in a specific year.\n   * @see [[Schedule.year]]\n   */\n  public isSingleYear(): boolean\n  {\n    return this.isSingleFrequency( this.year );\n  }\n\n  /**\n   * @returns `true` if this schedule produces events only in a specific month.\n   * @see [[Schedule.month]]\n   */\n  public isSingleMonth(): boolean\n  {\n    return this.isSingleFrequency( this.month );\n  }\n\n  /**\n   * @returns `true` if this schedule produces events only in a specific day of\n   *    the month.\n   * @see [[Schedule.dayOfMonth]]\n   * @see [[Schedule.lastDayOfMonth]]\n   */\n  public isSingleDayOfMonth(): boolean\n  {\n    return this.isSingleFrequency( this.dayOfMonth ) ||\n      this.isSingleFrequency( this.lastDayOfMonth );\n  }\n\n  /**\n   * @returns `true` if this schedule produces events only in a specific day of\n   *    the week.\n   * @see [[Schedule.dayOfWeek]]\n   */\n  public isSingleDayOfWeek(): boolean\n  {\n    return this.isSingleFrequency( this.dayOfWeek );\n  }\n\n  /**\n   * @returns `true` if this schedule produces events only in a specific day of\n   *    the year.\n   * @see [[Schedule.dayOfYear]]\n   */\n  public isSingleDayOfYear(): boolean\n  {\n    return this.isSingleFrequency( this.dayOfYear );\n  }\n\n  /**\n   * @returns `true` if this schedule produces events only in a specific week of\n   *    the month.\n   * @see [[Schedule.weekspanOfMonth]]\n   * @see [[Schedule.fullWeekOfMonth]]\n   * @see [[Schedule.weekOfMonth]]\n   * @see [[Schedule.lastFullWeekOfMonth]]\n   * @see [[Schedule.lastWeekspanOfMonth]]\n   */\n  public isSingleWeekOfMonth(): boolean\n  {\n    return this.isSingleFrequency( this.weekspanOfMonth ) ||\n      this.isSingleFrequency( this.fullWeekOfMonth ) ||\n      this.isSingleFrequency( this.weekOfMonth ) ||\n      this.isSingleFrequency( this.lastFullWeekOfMonth ) ||\n      this.isSingleFrequency( this.lastWeekspanOfMonth );\n  }\n\n  /**\n   * @returns `true` if this schedule produces events only in a specific week of\n   *    the year.\n   * @see [[Schedule.weekspanOfYear]]\n   * @see [[Schedule.fullWeekOfYear]]\n   * @see [[Schedule.week]]\n   * @see [[Schedule.weekOfYear]]\n   * @see [[Schedule.lastFullWeekOfYear]]\n   * @see [[Schedule.lastWeekspanOfYear]]\n   */\n  public isSingleWeekOfYear(): boolean\n  {\n    return this.isSingleFrequency( this.weekspanOfYear ) ||\n      this.isSingleFrequency( this.fullWeekOfYear ) ||\n      this.isSingleFrequency( this.week ) ||\n      this.isSingleFrequency( this.weekOfYear ) ||\n      this.isSingleFrequency( this.lastFullWeekOfYear ) ||\n      this.isSingleFrequency( this.lastWeekspanOfYear );\n  }\n\n  /**\n   * Determines if the given [[FrequencyCheck]] results in a single occurrence.\n   *\n   * @returns `true` if the frequency results in a single event, otherwise `false`.\n   */\n  public isSingleFrequency(frequency: FrequencyCheck): boolean\n  {\n    return fn.isArray( frequency.input ) && (<number[]>frequency.input).length === 1;\n  }\n\n  /**\n   * Creates a forecast for this schedule which returns a number of event\n   * occurrences around a given day. A single item could be returned per day, or\n   * you could get an item for each timed event occurrence.\n   *\n   * @param around The day to find a forecast around.\n   * @param covers If `true` spans which span multiple days will be looked at\n   *    to see if they intersect with the given day, otherwise `false` will\n   *    only look at the given day for the start of events.\n   * @param daysAfter The number of events to return before the given day.\n   * @param daysBefore The number of events to return after the given day.\n   * @param times If timed events should be returned, or only one for each day.\n   * @param lookAround How many days to look before and after the given day for\n   *    event occurrences.\n   * @returns A new iterator which provides the event occurence span, the day it\n   *    starts (or is covered if `covers` is `true`), and the identifier for the\n   *    event.\n   */\n  public forecast(around: Day,\n    covers: boolean = true,\n    daysAfter: number,\n    daysBefore: number = daysAfter,\n    times: boolean = false,\n    lookAround: number = 366): Iterator<ScheduleEventTuple>\n  {\n    let type: Identifier = this.identifierType;\n\n    let tuplesForDay = (day: Day, tuples: Iterator<ScheduleEventTuple>): boolean =>\n    {\n      let spans: DaySpan[] = this.iterateSpans( day, covers ).list();\n      let last: number = times ? spans.length : Math.min( 1, spans.length );\n      let offset: number = times ? 0 : spans.length - 1;\n\n      for (let i = 0; i < last; i++)\n      {\n        let span: DaySpan = spans[ i + offset ];\n        let id: IdentifierInput = type.get( span.start );\n\n        if (tuples.act( [ span, day, id ] ) === IteratorAction.Stop)\n        {\n          return false;\n        }\n      }\n\n      return true;\n    };\n\n    let prev = new Iterator<ScheduleEventTuple>(iterator =>\n    {\n      let curr: Day = around;\n\n      for (let i = 0; i < lookAround; i++)\n      {\n        if (!tuplesForDay( curr, iterator ))\n        {\n          break;\n        }\n\n        curr = curr.prev();\n      }\n    });\n\n    let next = new Iterator<ScheduleEventTuple>(iterator =>\n    {\n      let curr: Day = around;\n\n      for (let i = 0; i < lookAround; i++)\n      {\n        curr = curr.next();\n\n        if (!tuplesForDay( curr, iterator ))\n        {\n          break;\n        }\n      }\n    });\n\n    return prev.take( daysBefore + 1 ).reverse().append( next.take( daysAfter ) );\n  }\n\n  /**\n   * Iterates timed events that were explicitly specified on the given day.\n   * Those events could span multiple days so may be tested against another day.\n   *\n   * @param day The day to look for included timed events.\n   * @param matchAgainst The day to test against the timed event.\n   * @returns A new Iterator for all the included spans found.\n   */\n  public iterateIncludeTimes(day: Day, matchAgainst: Day = day): Iterator<DaySpan>\n  {\n    let isIncludedTime = (result: [IdentifierInput, boolean]) =>\n    {\n      let [id, included] = result;\n\n      return included && Identifier.Time.is( id );\n    };\n\n    let getSpan = (result: [IdentifierInput, boolean]) =>\n    {\n      let [id] = result;\n      let time: Day = Identifier.Time.start( id );\n      let span: DaySpan = this.getTimeSpan( time, time.asTime() );\n\n      if (span.matchesDay( matchAgainst ))\n      {\n        return span;\n      }\n    };\n\n    return this.include.query( day.dayIdentifier ).map<DaySpan>( getSpan, isIncludedTime );\n  }\n\n  /**\n   * Clones this schedule.\n   *\n   * @returns A new schedule which matches this schedule.\n   */\n  public clone(): Schedule<M>\n  {\n    return new Schedule<M>( this.toInput() );\n  }\n\n  /**\n   * Converts the schedule instance back into input.\n   *\n   * @param returnDays When `true` the start, end, and array of exclusions will\n   *    have [[Day]] instances, otherwise the UTC timestamp and dayIdentifiers\n   *    will be used when `false`.\n   * @param returnTimes When `true` the times returned in the input will be\n   *    instances of [[Time]] otherwise the `timeFormat` is used to convert the\n   *    times to strings.\n   * @param timeFormat The time format to use when returning the times as strings.\n   * @param alwaysDuration If the duration values (`duration` and\n   *    `durationUnit`) should always be returned in the input.\n   * @returns The input that describes this schedule.\n   * @see [[Time.format]]\n   */\n  public toInput(returnDays: boolean = false, returnTimes: boolean = false, timeFormat: string = '', alwaysDuration: boolean = false): ScheduleInput<M>\n  {\n    let defaultUnit: string = Constants.DURATION_DEFAULT_UNIT( this.isFullDay() );\n    let exclusions: IdentifierInput[] = this.exclude.identifiers(v => v).list();\n    let inclusions: IdentifierInput[] = this.include.identifiers(v => v).list();\n    let cancels: IdentifierInput[] = this.cancel.identifiers(v => v).list();\n    let hasMeta: boolean = !this.meta.isEmpty();\n    let out: ScheduleInput<M> = {};\n    let times: TimeInput[]  = [];\n\n    for (let time of this.times)\n    {\n      times.push( returnTimes ? time : (timeFormat ? time.format( timeFormat ) : time.toString()) );\n    }\n\n    if (this.start) out.start = returnDays ? this.start : this.start.time;\n    if (this.end) out.end = returnDays ? this.end : this.end.time;\n    if (times.length) out.times = times;\n    if (alwaysDuration || this.duration !== Constants.DURATION_DEFAULT) out.duration = this.duration;\n    if (alwaysDuration || this.durationUnit !== defaultUnit) out.durationUnit = this.durationUnit;\n    if (exclusions.length) out.exclude = exclusions;\n    if (inclusions.length) out.include = inclusions;\n    if (cancels.length) out.cancel = cancels;\n    if (hasMeta) out.meta = fn.extend( {}, this.meta.map );\n    if (this.dayOfWeek.input) out.dayOfWeek = this.dayOfWeek.input;\n    if (this.dayOfMonth.input) out.dayOfMonth = this.dayOfMonth.input;\n    if (this.lastDayOfMonth.input) out.lastDayOfMonth = this.lastDayOfMonth.input;\n    if (this.dayOfYear.input) out.dayOfYear = this.dayOfYear.input;\n    if (this.year.input) out.year = this.year.input;\n    if (this.month.input) out.month = this.month.input;\n    if (this.week.input) out.week = this.week.input;\n    if (this.weekOfYear.input) out.weekOfYear = this.weekOfYear.input;\n    if (this.weekspanOfYear.input) out.weekspanOfYear = this.weekspanOfYear.input;\n    if (this.fullWeekOfYear.input) out.fullWeekOfYear = this.fullWeekOfYear.input;\n    if (this.lastWeekspanOfYear.input) out.lastWeekspanOfYear = this.lastWeekspanOfYear.input;\n    if (this.lastFullWeekOfYear.input) out.lastFullWeekOfYear = this.lastFullWeekOfYear.input;\n    if (this.weekOfMonth.input) out.weekOfMonth = this.weekOfMonth.input;\n    if (this.weekspanOfMonth.input) out.weekspanOfMonth = this.weekspanOfMonth.input;\n    if (this.fullWeekOfMonth.input) out.fullWeekOfMonth = this.fullWeekOfMonth.input;\n    if (this.lastWeekspanOfMonth.input) out.lastWeekspanOfMonth = this.lastWeekspanOfMonth.input;\n    if (this.lastFullWeekOfMonth.input) out.lastFullWeekOfMonth = this.lastFullWeekOfMonth.input;\n\n    return out;\n  }\n\n  /**\n   * Describes the schedule in a human friendly string taking into account all\n   * possible values specified in this schedule.\n   *\n   * @param thing A brief description of the things (events) on the schedule.\n   * @param includeRange When `true` the [[Schedule.start]] and [[Schedule.end]]\n   *    are possibly included in the description if they have values.\n   * @param includeTimes When `true` the [[Schedule.times]] are possibly included\n   *    in the description.\n   * @param includeDuration When `true` the [[Schedule.duration]] and\n   *    [[Schedule.durationUnit]] are added to the description if\n   *    [[Schedule.duration]] is not equal to `1`.\n   * @param includeExcludes When `true` the [[Schedule.exclude]] are added\n   *    to the description if there are any.\n   * @param includeIncludes When `true` the [[Schedule.include]] are added\n   *    to the description if there are any.\n   * @param includeCancels When `true` the [[Schedule.cancel]] are added\n   *    to the description if there are any.\n   * @returns The descroption of the schedule.\n   */\n  public describe(thing: string = 'event',\n    includeRange: boolean = true,\n    includeTimes: boolean = true,\n    includeDuration: boolean = false,\n    includeExcludes: boolean = false,\n    includeIncludes: boolean = false,\n    includeCancels: boolean = false): string\n  {\n    let out: string = '';\n\n    if (includeRange)\n    {\n      if (this.start)\n      {\n        out += 'Starting on ' + this.start.format('dddd Do, YYYY');\n\n        if (this.end)\n        {\n          out += ' and ending on ' + this.end.format('dddd Do, YYYY');\n        }\n      }\n      else if (this.end)\n      {\n        out += 'Up until ' + this.end.format('dddd Do, YYYY');\n      }\n    }\n\n    if (out)\n    {\n      out += ' the ' + thing + ' will occur';\n    }\n    else\n    {\n      out += 'The ' + thing + ' will occur';\n    }\n\n    out += this.describeRule( this.dayOfWeek.input, 'day of the week', x => moment.weekdays()[x], 1, false);\n    out += this.describeRule( this.lastDayOfMonth.input, 'last day of the month', x => Suffix.CACHE[x] );\n    out += this.describeRule( this.dayOfMonth.input, 'day of the month', x => Suffix.CACHE[x] );\n    out += this.describeRule( this.dayOfYear.input, 'day of the year', x => Suffix.CACHE[x], 1 );\n    out += this.describeRule( this.year.input, 'year', x => x, 0, false, ' in ' );\n    out += this.describeRule( this.month.input, 'month', x => moment.months()[x], 0, false, ' in ' );\n    out += this.describeRule( this.weekOfYear.input, 'week of the year', x => Suffix.CACHE[x] );\n    out += this.describeRule( this.weekspanOfYear.input, 'weekspan of the year', x => Suffix.CACHE[x + 1], 1 );\n    out += this.describeRule( this.fullWeekOfYear.input, 'full week of the year', x => Suffix.CACHE[x] );\n    out += this.describeRule( this.lastWeekspanOfYear.input, 'last weekspan of the year', x => Suffix.CACHE[x + 1], 1 );\n    out += this.describeRule( this.lastFullWeekOfYear.input, 'last full week of the year', x => Suffix.CACHE[x] );\n    out += this.describeRule( this.weekOfMonth.input, 'week of the month', x => Suffix.CACHE[x] );\n    out += this.describeRule( this.fullWeekOfMonth.input, 'full week of the month', x => Suffix.CACHE[x] );\n    out += this.describeRule( this.weekspanOfMonth.input, 'weekspan of the month', x => Suffix.CACHE[x + 1], 1 );\n    out += this.describeRule( this.lastFullWeekOfMonth.input, 'last full week of the month', x => Suffix.CACHE[x] );\n    out += this.describeRule( this.lastWeekspanOfMonth.input, 'last weekspan of the month', x => Suffix.CACHE[x + 1], 1 );\n\n    if (includeTimes && this.times.length)\n    {\n      out += ' at ';\n      out += this.describeArray( this.times, x => x.format('hh:mm a') );\n    }\n\n    if (includeDuration && this.duration !== Constants.DURATION_DEFAULT)\n    {\n      out += ' lasting ' + this.duration + ' ';\n\n      if (this.durationUnit)\n      {\n        out += this.durationUnit + ' ';\n      }\n    }\n\n    if (includeExcludes)\n    {\n      let excludes: ScheduleModifierSpan<boolean>[] = this.exclude.spans().list();\n\n      if (excludes.length)\n      {\n        out += ' excluding ';\n        out += this.describeArray( excludes, x => x.span.summary(Units.DAY) );\n      }\n    }\n\n    if (includeIncludes)\n    {\n      let includes: ScheduleModifierSpan<boolean>[] = this.include.spans().list();\n\n      if (includes.length)\n      {\n        out += ' including ';\n        out += this.describeArray( includes, x => x.span.summary(Units.DAY) );\n      }\n    }\n\n    if (includeCancels)\n    {\n      let cancels: ScheduleModifierSpan<boolean>[] = this.cancel.spans().list();\n\n      if (cancels.length)\n      {\n        out += ' with cancellations on ';\n        out += this.describeArray( cancels, x => x.span.summary(Units.DAY) );\n      }\n    }\n\n    return out;\n  }\n\n  /**\n   * Describes the given frequency.\n   *\n   * @param value The frequency to describe.\n   * @param unit The unit of the frequency.\n   * @param map How the values in the frequency should be described.\n   * @param everyOffset A value to add to a [[FrequencyValueEvery]] offset to\n   *    account for zero-based values that should be shifted for human\n   *    friendliness.\n   * @param the If the word 'the' should be used to describe the unit.\n   * @param on The word which preceeds values of the given unit.\n   * @param required If the description should always return a non-empty string\n   *    even if the frequency was not specified in the original input.\n   * @returns A string description of the frequency.\n   */\n  private describeRule(value: FrequencyValue, unit: string, map: (x: number) => any, everyOffset: number = 0, the: boolean = true, on: string = ' on ', required: boolean = false): string\n  {\n    let out: string = '';\n    let suffix: string = the ? ' ' + unit : '';\n\n    if (fn.isFrequencyValueEvery(value))\n    {\n      let valueEvery: FrequencyValueEvery = <FrequencyValueEvery>value;\n\n      out += ' every ' + Suffix.CACHE[ valueEvery.every ] + ' ' + unit;\n\n      if (valueEvery.offset)\n      {\n        out += ' starting at ' + map( valueEvery.offset + everyOffset ) + suffix;\n      }\n    }\n    else if (fn.isFrequencyValueOneOf(value))\n    {\n      let valueOne: FrequencyValueOneOf = <FrequencyValueOneOf>value;\n\n      if (valueOne.length)\n      {\n        out += on + (the ? 'the ' : '');\n        out += this.describeArray( valueOne, map );\n        out += suffix;\n      }\n    }\n    else if (required)\n    {\n      out +=  on + 'any ' + unit;\n    }\n\n    return out;\n  }\n\n  /**\n   * Describes the array by adding commas where appropriate and 'and' before the\n   * last value of the array (if its more than `1`).\n   *\n   * @param array The array of items to describe.\n   * @param map The function which converts an item to a string.\n   * @returns The final description of the array items.\n   */\n  private describeArray<T>(array: T[], map: (item: T) => string): string\n  {\n    let out: string = '';\n    let last: number = array.length - 1;\n\n    out += map( array[ 0 ] );\n\n    for (let i = 1; i < last; i++)\n    {\n      out += ', ' + map( array[ i ] );\n    }\n\n    if (last > 0)\n    {\n      out += ' and ' + map( array[ last ] );\n    }\n\n    return out;\n  }\n\n  /**\n   * Generates a schedule for an event which occurs once all day for a given day\n   * optionally spanning multiple days starting on the given day.\n   *\n   * @param input The day the event starts.\n   * @param days The number of days the event lasts.\n   * @returns A new schedule that starts on the given day.\n   */\n  public static forDay<M>(input: DayInput, days: number = 1): Schedule<M>\n  {\n    let day: Day = Day.parse( input );\n\n    if (!day)\n    {\n      return null;\n    }\n\n    return new Schedule<M>({\n      year: [ day.year ],\n      month: [ day.month ],\n      dayOfMonth: [ day.dayOfMonth ],\n      duration: days,\n      durationUnit: 'days'\n    });\n  }\n\n  /**\n   * Generates a schedule for an event which occurs once at a given time on a\n   * given day optionally spanning any amount of time (default is 1 hour).\n   *\n   * @param input The day the event starts.\n   * @param time The time the event starts.\n   * @param duration The duration of the event.\n   * @param durationUnit The unit for the duration of the event.\n   * @returns A new schedule that starts on the given day and time.\n   */\n  public static forTime<M>(input: DayInput, time: TimeInput, duration: number = 1, durationUnit: DurationInput = 'hours'): Schedule<M>\n  {\n    let day: Day = Day.parse( input );\n\n    if (!day)\n    {\n      return null;\n    }\n\n    return new Schedule<M>({\n      year: [ day.year ],\n      month: [ day.month ],\n      dayOfMonth: [ day.dayOfMonth ],\n      times: [ time ],\n      duration: duration,\n      durationUnit: durationUnit\n    });\n  }\n\n  /**\n   * Generates a schedule for an event which occurs once over a given span.\n   *\n   * @param span The span of the event.\n   * @returns A new schedule that starts and ends at the given timestamps.\n   */\n  public static forSpan<M>(span: DaySpan): Schedule<M>\n  {\n    let start = span.start;\n    let minutes = span.minutes();\n    let isDay = minutes % Constants.MINUTES_IN_DAY === 0;\n    let isHour = minutes % Constants.MINUTES_IN_HOUR === 0;\n    let duration = isDay ? minutes / Constants.MINUTES_IN_DAY : (isHour ? minutes / Constants.MINUTES_IN_HOUR : minutes);\n    let durationUnit: DurationInput = isDay ? 'days' : (isHour ? 'hours' : 'minutes');\n\n    return this.forTime<M>( start, start.asTime(), duration, durationUnit );\n  }\n\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/Schedule.ts","\nimport { Schedule, ScheduleInput } from './Schedule';\n\n/**\n * The input which can be passed to the calendar when adding a schedule and event.\n *\n * @typeparam T The type of data stored in the [[Event]] class.\n * @typeparam M The type of metadata stored in the schedule.\n */\nexport interface EventInput<T, M>\n{\n  id?: any;\n  data?: T;\n  schedule: ScheduleInput<M> | Schedule<M>;\n}\n\n/**\n * A pairing of a user specified event object and the schedule which defines\n * when it occurs on a calendar.\n *\n * @typeparam T The type of data stored in the [[Event]] class.\n * @typeparam M The type of metadata stored in the schedule.\n */\nexport class Event<T, M>\n{\n\n  /**\n   * User specified ID which can be used to find or remove this event from a\n   * Calendar.\n   */\n  public id: any;\n\n  /**\n   * User specified object which describes this event.\n   */\n  public data: T;\n\n  /**\n   * The schedule which defines when this event occurs.\n   */\n  public schedule: Schedule<M>;\n\n  /**\n   * If the event is visible on the calendar.\n   */\n  public visible: boolean;\n\n  /**\n   * Creates a new event.\n   *\n   * @param schedule The schedule which defines when the event occurs.\n   * @param data User specified object which describes this event.\n   * @param id User specified ID which identifies this event.\n   */\n  public constructor(schedule: Schedule<M>, data?: T, id?: any, visible: boolean = true)\n  {\n    this.schedule = schedule;\n    this.data = data;\n    this.id = id;\n    this.visible = visible;\n  }\n\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/Event.ts","\nimport { Functions as fn } from './Functions';\nimport { Constants } from './Constants';\nimport { Parse } from './Parse';\n\n\n/**\n * A value that can possibly be parsed into a Time instance.\n *\n * @see [[Time.parse]]\n */\nexport type TimeInput = Time | number | string | {hour: number, minute?: number, second?: number, millisecond?: number};\n\n/**\n * A class which holds a specific time during in any day.\n */\nexport class Time\n{\n\n  /**\n   * The regular expression used to parse a time from a string.\n   *\n   * - ## = hour\n   * - ##:## = hour & minute\n   * - ##:##:## = hour, minute, & second\n   * - ##:##:##.### = hour, minute, second, and milliseconds\n   */\n  public static REGEX = /^(\\d\\d?):?(\\d\\d)?:?(\\d\\d)?\\.?(\\d\\d\\d)?$/;\n\n  /**\n   * The hour between 0 and 23\n   */\n  public hour: number;\n\n  /**\n   * The minute between 0 and 59\n   */\n  public minute: number;\n\n  /**\n   * The second between 0 and 59\n   */\n  public second: number;\n\n  /**\n   * The millisecond between 0 and 999\n   */\n  public millisecond: number;\n\n\n  /**\n   * Creates a new Time instance given an hour and optionally a minute, second,\n   * and millisecond. If they have not been specified they default to 0.\n   *\n   * @param hour The hour.\n   * @param minute The minute.\n   * @param second The second.\n   * @param millisecond The millisecond.\n   */\n  public constructor(hour: number, minute: number = Constants.MINUTE_MIN, second: number = Constants.SECOND_MIN, millisecond: number = Constants.MILLIS_MIN)\n  {\n    this.hour = hour;\n    this.minute = minute;\n    this.second = second;\n    this.millisecond = millisecond;\n  }\n\n  /**\n   * Formats this time into a string. The following list describes the available\n   * formatting patterns:\n   *\n   * ### Hour\n   * - H: 0-23\n   * - HH: 00-23\n   * - h: 12,1-12,1-11\n   * - hh: 12,01-12,01-11\n   * - k: 1-24\n   * - kk: 01-24\n   * - a: am,pm\n   * - A: AM,PM\n   * ### Minute\n   * - m: 0-59\n   * - mm: 00-59\n   * ### Second\n   * - s: 0-59\n   * - ss: 00-59\n   * ### Millisecond\n   * - S: 0-9\n   * - SS: 00-99\n   * - SSS: 000-999\n   *\n   * @param format The format to output.\n   * @returns The formatted time.\n   */\n  public format(format: string): string\n  {\n    let formatterEntries = Time.FORMATTERS;\n    let out: string = '';\n\n    for (let i = 0; i < format.length; i++)\n    {\n      let handled: boolean = false;\n\n      for (let k = 0; k < formatterEntries.length && !handled; k++)\n      {\n        let entry = formatterEntries[ k ];\n        let part: string = format.substring( i, i + entry.size );\n\n        if (part.length === entry.size)\n        {\n          let formatter = entry.formats[ part ];\n\n          if (formatter)\n          {\n            out += formatter(this);\n            i += entry.size - 1;\n            handled = true;\n          }\n        }\n      }\n\n      if (!handled)\n      {\n        out += format.charAt(i);\n      }\n    }\n\n    return out;\n  }\n\n  /**\n   * Determines whether this time is an exact match for the given time.\n   *\n   * @param time The given time to test against.\n   * @returns `true` if the time matches this time, otherwise `false`.\n   */\n  public matches(time: Time): boolean\n  {\n    return this.hour === time.hour &&\n      this.minute === time.minute &&\n      this.second === time.second &&\n      this.millisecond === time.millisecond;\n  }\n\n  /**\n   * Determines whether this time has the same hour as the given time.\n   *\n   * @param time The given time to test against.\n   * @returns `true` if the given hour matches this hour, otherwise `false`.\n   */\n  public matchesHour(time: Time): boolean\n  {\n    return this.hour === time.hour;\n  }\n\n  /**\n   * Determines whether this time has the same hour and minute as the given time.\n   *\n   * @param time The given time to test against.\n   * @returns `true` if the given hour and minute matches, otherwise `false`.\n   */\n  public matchesMinute(time: Time): boolean\n  {\n    return this.hour === time.hour &&\n      this.minute === time.minute;\n  }\n\n  /**\n   * Determines whether this time has the same hour, minute, and second as the\n   * given time.\n   *\n   * @param time The given time to test against.\n   * @returns `true` if the given hour, minute, and second matches, otherwise\n   *    `false`.\n   */\n  public matchesSecond(time: Time): boolean\n  {\n    return this.hour === time.hour &&\n      this.minute === time.minute &&\n      this.second === time.second;\n  }\n\n  /**\n   * Sets the time of this instance to the same time of the given input.\n   *\n   * @param input The time to set this to.\n   * @returns `true` if this time was set, otherwise `false` (invalid input).\n   */\n  public set(input: TimeInput): boolean\n  {\n    let parsed: Time = Time.parse( input );\n    let valid: boolean = !!parsed;\n\n    if (valid)\n    {\n      this.hour = parsed.hour;\n      this.minute = parsed.minute;\n      this.second = parsed.second;\n      this.millisecond = parsed.millisecond;\n    }\n\n    return valid;\n  }\n\n  /**\n   * @returns The number of milliseconds from the start of the day until this\n   *  time.\n   */\n  public toMilliseconds(): number\n  {\n    return this.hour * Constants.MILLIS_IN_HOUR +\n      this.minute * Constants.MILLIS_IN_MINUTE +\n      this.second * Constants.MILLIS_IN_SECOND +\n      this.millisecond;\n  }\n\n  /**\n   * @returns The time formatted using the smallest format that completely\n   *  represents this time.\n   */\n  public toString(): string\n  {\n    if (this.millisecond) return this.format('HH:mm:ss.SSS');\n    if (this.second) return this.format('HH:mm:ss');\n    if (this.minute) return this.format('HH:mm');\n\n    return this.format('HH');\n  }\n\n  /**\n   * @returns A unique identifier for this time. The number returned is in the\n   *  following format: SSSssmmHH\n   */\n  public toIdentifier(): number\n  {\n    return this.hour +\n      this.minute * 100 +\n      this.second * 10000 +\n      this.millisecond * 10000000;\n  }\n\n  /**\n   * @returns An object with hour, minute, second, a millisecond properties if\n   *  they are non-zero on this time.\n   */\n  public toObject(): TimeInput\n  {\n    let out: TimeInput = {\n      hour: this.hour\n    };\n\n    if (this.minute) out.minute = this.minute;\n    if (this.second) out.second = this.second;\n    if (this.millisecond) out.millisecond = this.millisecond;\n\n    return out;\n  }\n\n  /**\n   * Parses a value and tries to convert it to a Time instance.\n   *\n   * @param input The input to parse.\n   * @returns The instance parsed or `null` if it was invalid.\n   * @see [[Parse.time]]\n   */\n  public static parse(input: any): Time\n  {\n    return Parse.time(input);\n  }\n\n  /**\n   * Parses a string and converts it to a Time instance. If the string is not\n   * in a valid format `null` is returned.\n   *\n   * @param time The string to parse.\n   * @returns The instance parsed or `null` if it was invalid.\n   * @see [[Time.REGEX]]\n   */\n  public static fromString(time: string): Time\n  {\n    let matches: string[] = this.REGEX.exec( time );\n\n    if (!matches)\n    {\n      return null;\n    }\n\n    let h: number = parseInt(matches[1]) || 0;\n    let m: number = parseInt(matches[2]) || 0;\n    let s: number = parseInt(matches[3]) || 0;\n    let l: number = parseInt(matches[4]) || 0;\n\n    return this.build(h, m, s, l);\n  }\n\n  /**\n   * Parses a number and converts it to a Time instance. The number is assumed\n   * to be in the [[Time.toIdentifier]] format.\n   *\n   * @param time The number to parse.\n   * @returns The instance parsed.\n   */\n  public static fromIdentifier(time: number): Time\n  {\n    let h: number = time % 100;\n    let m: number = Math.floor(time / 100) % 100;\n    let s: number = Math.floor(time / 10000) % 100;\n    let l: number = Math.floor(time / 10000000) % 1000;\n\n    return this.build(h, m, s, l);\n  }\n\n  /**\n   * Returns a new instance given an hour and optionally a minute, second,\n   * and millisecond. If they have not been specified they default to 0.\n   *\n   * @param hour The hour.\n   * @param minute The minute.\n   * @param second The second.\n   * @param millisecond The millisecond.\n   * @returns A new instance.\n   */\n  public static build(hour: number, minute: number = Constants.MINUTE_MIN, second: number = Constants.SECOND_MIN, millisecond: number = Constants.MILLIS_MIN): Time\n  {\n    return new Time(hour, minute, second, millisecond)\n  }\n\n  /**\n   * A set of formatting functions keyed by their format string.\n   */\n  public static FORMATTERS = [\n    {\n      size: 3,\n      formats: {\n        SSS: (t: Time) => fn.padNumber(t.millisecond, 3)\n      }\n    },\n    {\n      size: 2,\n      formats: {\n        HH: (t: Time) => fn.padNumber(t.hour, 2),\n        hh: (t: Time) => fn.padNumber((t.hour % 12) || 12, 2),\n        kk: (t: Time) => fn.padNumber(t.hour + 1, 2),\n        mm: (t: Time) => fn.padNumber(t.minute, 2),\n        ss: (t: Time) => fn.padNumber(t.second, 2),\n        SS: (t: Time) => fn.padNumber(t.millisecond, 3, 2)\n      }\n    },\n    {\n      size: 1,\n      formats: {\n        A: (t: Time) => t.hour < 12 ? 'AM' : 'PM',\n        a: (t: Time) => t.hour < 12 ? 'am' : 'pm',\n        H: (t: Time) => t.hour + '',\n        h: (t: Time) => ((t.hour % 12) || 12) + '',\n        k: (t: Time) => (t.hour + 1) + '',\n        m: (t: Time) => t.minute + '',\n        s: (t: Time) => t.second + '',\n        S: (t: Time) => fn.padNumber(t.millisecond, 3, 1)\n      }\n    }\n  ];\n\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/Time.ts","\nimport { Functions as fn } from './Functions';\nimport { FrequencyCheck } from './Frequency';\nimport { Schedule, ScheduleInput } from './Schedule';\nimport { ScheduleModifier } from './ScheduleModifier';\nimport { Constants } from './Constants';\nimport { Day, DayProperty, DayInput, DurationInput } from './Day';\nimport { Event } from './Event';\nimport { Time } from './Time';\n\n\n/**\n * The class which takes user input and parses it to specific structures.\n */\nexport class Parse\n{\n\n  /**\n   * Parses a value and converts it to a [[FrequencyCheck]].\n   *\n   * @param input The input to parse into a function.\n   * @param property The [[Day]] property the frequency is for.\n   * @returns A function which determines whether a value matches a frequency.\n   * @see [[Schedule]]\n   */\n  public static frequency(input: any, property: DayProperty): FrequencyCheck\n  {\n    let check: FrequencyCheck = (value: number) => {\n      return true;\n    };\n\n    check.given = false;\n\n    if (fn.isFrequencyValueEvery(input))\n    {\n      let every: number = input.every;\n      let offset: number = (input.offset || 0) % every;\n\n      check = (value: number) => {\n        return value % every === offset;\n      };\n      check.given = true;\n    }\n\n    if (fn.isFrequencyValueOneOf(input))\n    {\n      let map: object = {};\n\n      for (let i = 0; i < input.length; i++) {\n        map[ input[ i ] ] = true;\n      }\n\n      check = (value: number) => {\n        return !!map[ value ];\n      };\n      check.given = true;\n    }\n\n    check.input = fn.coalesce( input, null );\n    check.property = property;\n\n    return check;\n  }\n\n  /**\n   * Parses [[DayInput]] into a [[Day]] instance.\n   *\n   * ```typescript\n   * Parse.day( 65342300 );               // UTC timestamp\n   * Parse.day( '01/02/2014' );           // strings in many formats\n   * Parse.day( day );                    // return a passed instance\n   * Parse.day( [2018, 0, 2] );           // array: 01/02/2018\n   * Parse.day( {year: 2018, month: 2} ); // object: 03/01/2018\n   * Parse.day( true );                   // today\n   * ```\n   *\n   * @param input The input to parse.\n   * @returns The Day parsed or `null` if the value is not valid.\n   */\n  public static day(input: DayInput): Day\n  {\n    if (fn.isNumber(input))\n    {\n      return Day.unix( <number>input );\n    }\n    else if (fn.isString(input))\n    {\n      return Day.fromString( <string>input );\n    }\n    else if (input instanceof Day)\n    {\n      return input;\n    }\n    else if (fn.isArray( input ))\n    {\n      return Day.fromArray( <number[]>input );\n    }\n    else if (fn.isObject( input ))\n    {\n      return Day.fromObject( <object>input );\n    }\n    else if (input === true)\n    {\n      return Day.today();\n    }\n\n    return null;\n  }\n\n  /**\n   * Parses a value and tries to convert it to a Time instance.\n   *\n   * ```typescript\n   * Parse.time( time );      // return a passed instance\n   * Parse.time( 9 );         // 09:00:00.000\n   * Parse.time( 3009 );      // 09:30:00.000\n   * Parse.time( 593009 );    // 09:30:59.000\n   * Parsetime( '09' );       // 09:00:00.000\n   * Parse.time( '9:30' );    // 09:30:00.000\n   * Parse.time( '9:30:59' ); // 09:30:59.000\n   * Parse.time( {hour: 2} ); // 02:00:00.000\n   * ```\n   *\n   * @param input The input to parse.\n   * @returns The instance parsed or `null` if it was invalid.\n   * @see [[Time.fromIdentifier]]\n   * @see [[Time.fromString]]\n   */\n  public static time(input: any): Time\n  {\n    if (input instanceof Time)\n    {\n      return input;\n    }\n    if (fn.isNumber(input))\n    {\n      return Time.fromIdentifier( <number>input );\n    }\n    if (fn.isString(input))\n    {\n      return Time.fromString( <string>input );\n    }\n    if (fn.isObject(input) && fn.isNumber(input.hour))\n    {\n      return new Time(input.hour, input.minute, input.second, input.millisecond);\n    }\n\n    return null;\n  }\n\n  /**\n   * Parses a value and tries to convert it to an array of Time instances.\n   * If any of the given values are not a valid time value then the resulting\n   * array will not contain a time instance.\n   *\n   * @param input The input to parse.\n   * @returns A non-null array of time instances.\n   * @see [[Parse.time]]\n   */\n  public static times(input: any): Time[]\n  {\n    let times: Time[] = [];\n\n    if (fn.isArray(input))\n    {\n      for (let timeInput of input)\n      {\n        let time = this.time( timeInput );\n\n        if (time)\n        {\n          times.push( time );\n        }\n      }\n\n      // Sort times from earliest to latest.\n      times.sort((a, b) =>\n      {\n        return a.toMilliseconds() - b.toMilliseconds();\n      });\n    }\n\n    return times;\n  }\n\n  /**\n   * Parses an array of excluded days into a map of excluded days where the\n   * array value and returned object key are [[Day.dayIdentifier]].\n   *\n   * ```typescript\n   * Parse.modifier( [ 20180101, 20140506 ] );            // {'20180101': true, '20140506': true}\n   * Parse.modifier( [ 20180101, Day.build(2014,4,6) ] ); // {'20180101': true, '20140506': true}\n   * ```\n   *\n   * @param input The input to parse.\n   * @param value The default value if the input given is an array of identifiers.\n   * @param parseMeta A function to use to parse a modifier.\n   * @param out The modifier to set the identifiers and values of and return.\n   * @returns The object with identifier keys and `true` values.\n   * @see [[Day.dayIdentifier]]\n   */\n  public static modifier<T>(input: any, value: T,\n    parseMeta: (input: any) => T = (x => <T>x),\n    out: ScheduleModifier<T> = new ScheduleModifier<T>()): ScheduleModifier<T>\n  {\n    let map = {};\n\n    if (fn.isArray(input))\n    {\n      for (let identifier of input)\n      {\n        if (identifier instanceof Day)\n        {\n          map[ identifier.dayIdentifier ] = value;\n        }\n        else if (fn.isNumber(identifier))\n        {\n          map[ <number>identifier ] = value;\n        }\n        else if (fn.isString(identifier))\n        {\n          map[ <string>identifier ] = value;\n        }\n      }\n    }\n\n    if (fn.isObject(input))\n    {\n      for (let identifier in input)\n      {\n        map[ identifier ] = parseMeta( input[ identifier ] );\n      }\n    }\n\n    out.map = map;\n\n    return out;\n  }\n\n  /**\n   * Parses an object which specifies a schedule where events may or may not\n   * repeat and they may be all day events or at specific times.\n   *\n   * @param input The input to parse into a schedule.\n   * @param parseMeta A function to use when parsing meta input into the desired type.\n   * @param out The schedule to set the values of and return.\n   * @returns An instance of the parsed [[Schedule]].\n   */\n  public static schedule<M>(input: ScheduleInput<M> | Schedule<M>,\n    parseMeta: (input: any) => M = (x => <M>x),\n    out: Schedule<M> = new Schedule<M>()): Schedule<M>\n  {\n    if (input instanceof Schedule)\n    {\n      return input;\n    }\n\n    let on: Day = this.day( input.on );\n    let times: Time[] = this.times( input.times );\n    let fullDay: boolean = times.length === 0;\n\n    if (on)\n    {\n      input.start = on.start();\n      input.end = on.end();\n      input.year = [on.year];\n      input.month = [on.month];\n      input.dayOfMonth = [on.dayOfMonth];\n    }\n\n    out.times = times;\n    out.duration = fn.coalesce( input.duration, Constants.DURATION_DEFAULT );\n    out.durationUnit = <DurationInput>fn.coalesce( input.durationUnit, Constants.DURATION_DEFAULT_UNIT( fullDay ) );\n    out.start = this.day( input.start );\n    out.end = this.day( input.end );\n    out.exclude = this.modifier( input.exclude, true, undefined, out.exclude );\n    out.include = this.modifier( input.include, true, undefined, out.include );\n    out.cancel = this.modifier( input.cancel, true, undefined, out.cancel );\n    out.meta = this.modifier( input.meta, null, parseMeta, out.meta );\n    out.year = this.frequency( input.year, 'year' );\n    out.month = this.frequency( input.month, 'month' );\n    out.week = this.frequency( input.week, 'week' );\n    out.weekOfYear = this.frequency( input.weekOfYear, 'weekOfYear' );\n    out.weekspanOfYear = this.frequency( input.weekspanOfYear, 'weekspanOfYear' );\n    out.fullWeekOfYear = this.frequency( input.fullWeekOfYear, 'fullWeekOfYear' );\n    out.lastWeekspanOfYear = this.frequency( input.lastWeekspanOfYear, 'lastWeekspanOfYear' );\n    out.lastFullWeekOfYear = this.frequency( input.lastFullWeekOfYear, 'lastFullWeekOfYear' );\n    out.weekOfMonth = this.frequency( input.weekOfMonth, 'weekOfMonth' );\n    out.weekspanOfMonth = this.frequency( input.weekspanOfMonth, 'weekspanOfMonth' );\n    out.fullWeekOfMonth = this.frequency( input.fullWeekOfMonth, 'fullWeekOfMonth' );\n    out.lastWeekspanOfMonth = this.frequency( input.lastWeekspanOfMonth, 'lastWeekspanOfMonth' );\n    out.lastFullWeekOfMonth = this.frequency( input.lastFullWeekOfMonth, 'lastFullWeekOfMonth' );\n    out.dayOfWeek = this.frequency( input.dayOfWeek, 'dayOfWeek' );\n    out.dayOfMonth = this.frequency( input.dayOfMonth, 'dayOfMonth' );\n    out.lastDayOfMonth = this.frequency( input.lastDayOfMonth, 'lastDayOfMonth' );\n    out.dayOfYear = this.frequency( input.dayOfYear, 'dayOfYear' );\n    out.updateDurationInDays();\n    out.updateChecks();\n\n    return out;\n  }\n\n  /**\n   * Parses an array of [[FrequencyCheck]] functions and returns an array of\n   * functions for only the checks that were specified by the user.\n   *\n   * @param checks The array of check functions to filter through.\n   * @returns The array of user specified checks.\n   */\n  public static givenFrequency(checks: FrequencyCheck[]): FrequencyCheck[]\n  {\n    let out: FrequencyCheck[] = [];\n\n    for (let check of checks)\n    {\n      if (check.given)\n      {\n        out.push( check );\n      }\n    }\n\n    return out;\n  }\n\n  /**\n   * Parses [[EventInput]] and returns an [[Event]].\n   *\n   * @param input The input to parse.\n   * @param parseData A function to use when parsing data input into the desired type.\n   * @param parseMeta A function to use when parsing meta input into the desired type.\n   * @returns The parsed value.\n   */\n  public static event<T, M>(input: any,\n    parseData: (input: any) => T = (x => <T>x),\n    parseMeta: (input: any) => M = (x => <M>x)): Event<T, M>\n  {\n    if (input instanceof Event)\n    {\n      return input;\n    }\n\n    if (!input.schedule)\n    {\n      return null;\n    }\n\n    let schedule: Schedule<M> = this.schedule<M>( input.schedule, parseMeta );\n\n    return new Event( schedule, parseData( input.data ), input.id, input.visible );\n  }\n\n  /**\n   * Parses a schedule from a CRON pattern. TODO\n   */\n  public static cron<M>(pattern: string, out: Schedule<M> = new Schedule<M>()): Schedule<M>\n  {\n    return out;\n  }\n\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/Parse.ts","\nimport { Identifier, IdentifierInput } from './Identifier';\nimport { Constants } from './Constants';\nimport { Op, operate } from './Operation';\nimport { Parse } from './Parse';\nimport { Time } from './Time';\n\n// @ts-ignore\nimport * as moment from 'moment';\n\n\n/**\n * Valid durations that can be specified.\n */\nexport type DurationInput = moment.unitOfTime.DurationConstructor;\n\n/**\n * All valid types which may be converted to a [[Day]] instance.\n *\n * - `number`: A UNIX timestamp.\n * - `string`: A string representation of a date.\n * - `Day`: An existing [[Day]] instance.\n * - `number[]`: An array of numbers specifying any of: [year, month, dayOfMonth, hour, minute, second, millisecond].\n * - `object`: An object with any of the following properties: year, month, dayOfMonth, hour, minute, second, millisecond.\n * - `true`: This will be interpreted as [[Day.today]]\n */\nexport type DayInput = number | string | Day | number[] | object | true;\n\n/**\n * One of the properties on the [[Day]] object.\n */\nexport type DayProperty = keyof Day;\n\n/**\n * A class which represents a point in time as\n */\nexport class Day\n{\n\n  /**\n   *\n   */\n  public readonly date: moment.Moment;\n\n  /**\n   *\n   */\n  public readonly time: number;\n\n  /**\n   *\n   */\n  public readonly millis: number;\n\n  /**\n   *\n   */\n  public readonly seconds: number;\n\n  /**\n   *\n   */\n  public readonly minute: number;\n\n  /**\n   *\n   */\n  public readonly hour: number;\n\n  /**\n   *\n   */\n  public readonly month: number;\n\n  /**\n   *\n   */\n  public readonly year: number;\n\n  /**\n   *\n   */\n  public readonly quarter: number;\n\n\n  /**\n   *\n   */\n  public readonly dayOfWeek: number;\n\n  /**\n   *\n   */\n  public readonly dayOfMonth: number;\n\n  /**\n   *\n   */\n  public readonly lastDayOfMonth: number;\n\n  /**\n   *\n   */\n  public readonly dayOfYear: number;\n\n\n  /**\n   *\n   */\n  public readonly week: number;\n\n  /**\n   *\n   */\n  public readonly weekOfYear: number;\n\n  /**\n   *\n   */\n  public readonly weekspanOfYear: number;\n\n  /**\n   *\n   */\n  public readonly fullWeekOfYear: number;\n\n  /**\n   *\n   */\n  public readonly lastWeekspanOfYear: number;\n\n  /**\n   *\n   */\n  public readonly lastFullWeekOfYear: number;\n\n\n  /**\n   *\n   */\n  public readonly weekOfMonth: number;\n\n  /**\n   *\n   */\n  public readonly weekspanOfMonth: number;\n\n  /**\n   *\n   */\n  public readonly fullWeekOfMonth: number;\n\n  /**\n   *\n   */\n  public readonly lastWeekspanOfMonth: number;\n\n  /**\n   *\n   */\n  public readonly lastFullWeekOfMonth: number;\n\n\n  /**\n   *\n   */\n  public readonly timeIdentifier: IdentifierInput;\n\n  /**\n   *\n   */\n  public readonly dayIdentifier: IdentifierInput;\n\n  /**\n   *\n   */\n  public readonly weekIdentifier: IdentifierInput;\n\n  /**\n   *\n   */\n  public readonly monthIdentifier: IdentifierInput;\n\n  /**\n   *\n   */\n  public readonly quarterIdentifier: IdentifierInput;\n\n\n\n  /**\n   *\n   */\n  public constructor(date: moment.Moment)\n  {\n    this.date                 = date;\n    this.time                 = date.valueOf();\n    this.millis               = date.millisecond();\n    this.seconds              = date.second();\n    this.minute               = date.minute();\n    this.hour                 = date.hour();\n    this.month                = date.month();\n    this.year                 = date.year();\n    this.quarter              = date.quarter();\n    this.dayOfWeek            = date.day();\n    this.dayOfMonth           = date.date();\n    this.dayOfYear            = date.dayOfYear();\n    this.week                 = date.week();\n\n    this.lastDayOfMonth       = Day.getLastDayOfMonth( date );\n    this.weekOfYear           = Day.getWeekOfYear( date );\n    this.weekspanOfYear       = Day.getWeekspanOfYear( date );\n    this.fullWeekOfYear       = Day.getFullWeekOfYear( date );\n    this.lastWeekspanOfYear   = Day.getLastWeekspanOfYear( date );\n    this.lastFullWeekOfYear   = Day.getLastFullWeekOfYear( date );\n\n    this.weekOfMonth          = Day.getWeekOfMonth( date );\n    this.weekspanOfMonth      = Day.getWeekspanOfMonth( date );\n    this.fullWeekOfMonth      = Day.getFullWeekOfMonth( date );\n    this.lastWeekspanOfMonth  = Day.getLastWeekspanOfMonth( date );\n    this.lastFullWeekOfMonth  = Day.getLastFullWeekOfMonth( date );\n\n    this.timeIdentifier       = Identifier.Time.get( this );\n    this.dayIdentifier        = Identifier.Day.get( this);\n    this.weekIdentifier       = Identifier.Week.get( this);\n    this.monthIdentifier      = Identifier.Month.get( this);\n    this.quarterIdentifier    = Identifier.Quarter.get( this );\n  }\n\n  // Same\n\n  /**\n   *\n   */\n  public sameDay(day: Day): boolean\n  {\n    return this.dayIdentifier === day.dayIdentifier;\n  }\n\n  /**\n   *\n   */\n  public sameMonth(day: Day): boolean\n  {\n    return this.monthIdentifier === day.monthIdentifier;\n  }\n\n  /**\n   *\n   */\n  public sameWeek(day: Day): boolean\n  {\n    return this.weekIdentifier === day.weekIdentifier;\n  }\n\n  /**\n   *\n   */\n  public sameYear(day: Day): boolean\n  {\n    return this.year === day.year;\n  }\n\n  /**\n   *\n   */\n  public sameQuarter(day: Day): boolean\n  {\n    return this.quarterIdentifier === day.quarterIdentifier;\n  }\n\n  /**\n   *\n   */\n  public sameHour(day: Day): boolean {\n    return this.dayIdentifier === day.dayIdentifier && this.hour === day.hour;\n  }\n\n  /**\n   *\n   */\n  public sameMinute(day: Day): boolean {\n    return this.timeIdentifier === day.timeIdentifier;\n  }\n\n  /**\n   *\n   */\n  public sameTime(time: Time): boolean {\n    return this.hour === time.hour && this.minute === time.minute && this.seconds === time.second && this.millis === time.millisecond;\n  }\n\n  // Comparison\n\n  /**\n   *\n   */\n  public isBefore(day: Day, precision?: moment.unitOfTime.StartOf): boolean {\n    return this.date.isBefore( day.date, precision );\n  }\n\n  /**\n   *\n   */\n  public isSameOrBefore(day: Day, precision?: moment.unitOfTime.StartOf): boolean {\n    return this.date.isSameOrBefore( day.date, precision );\n  }\n\n  /**\n   *\n   */\n  public isAfter(day: Day, precision?: moment.unitOfTime.StartOf): boolean {\n    return this.date.isAfter( day.date, precision );\n  }\n\n  /**\n   *\n   */\n  public isSameOrAfter(day: Day, precision?: moment.unitOfTime.StartOf): boolean {\n    return this.date.isSameOrAfter( day.date, precision );\n  }\n\n  /**\n   *\n   */\n  public max(day: Day): Day {\n    return this.date.isAfter( day.date ) ? this : day;\n  }\n\n  /**\n   *\n   */\n  public min(day: Day): Day {\n    return this.date.isBefore( day.date ) ? this : day;\n  }\n\n  // Between\n\n  public millisBetween(day: Day, op: Op = Op.DOWN, absolute: boolean = true): number {\n    return operate( this.date.diff( day.date, 'milliseconds', true ), op, absolute );\n  }\n\n  public secondsBetween(day: Day, op: Op = Op.DOWN, absolute: boolean = true): number {\n    return operate( this.date.diff( day.date, 'seconds', true ), op, absolute );\n  }\n\n  public minutesBetween(day: Day, op: Op = Op.DOWN, absolute: boolean = true): number {\n    return operate( this.date.diff( day.date, 'minutes', true ), op, absolute );\n  }\n\n  public hoursBetween(day: Day, op: Op = Op.DOWN, absolute: boolean = true): number {\n    return operate( this.date.diff( day.date, 'hours', true ), op, absolute );\n  }\n\n  public daysBetween(day: Day, op: Op = Op.DOWN, absolute: boolean = true): number {\n    return operate( this.date.diff( day.date, 'days', true ), op, absolute );\n  }\n\n  public weeksBetween(day: Day, op: Op = Op.DOWN, absolute: boolean = true): number {\n    return operate( this.date.diff( day.date, 'weeks', true ), op, absolute );\n  }\n\n  public monthsBetween(day: Day, op: Op = Op.DOWN, absolute: boolean = true): number {\n    return operate( this.date.diff( day.date, 'months', true ), op, absolute );\n  }\n\n  public yearsBetween(day: Day, op: Op = Op.DOWN, absolute: boolean = true): number {\n    return operate( this.date.diff( day.date, 'years', true ), op, absolute );\n  }\n\n  public isBetween(start: Day, end: Day, inclusive: boolean = true): boolean {\n    return this.date.isBetween(start.date, end.date, null, inclusive ? '[]' : '[)');\n  }\n\n  public mutate(mutator: (date: moment.Moment) => void): Day {\n    var d = this.toMoment();\n    mutator( d );\n    return new Day( d );\n  }\n\n  public add(amount: number, unit: string): Day {\n    return this.mutate(d => d.add(amount, <DurationInput>unit));\n  }\n\n  public relative(millis: number): Day {\n    return this.mutate(d => d.add(millis, 'milliseconds'));\n  }\n\n  // Days\n\n  public relativeDays(days: number): Day {\n    return this.mutate(d => d.add(days, 'days'));\n  }\n\n  public prev(days: number = 1): Day {\n    return this.relativeDays( -days );\n  }\n\n  public next(days: number = 1): Day {\n    return this.relativeDays( days );\n  }\n\n  public withDayOfMonth(day: number): Day {\n    return this.mutate(d => d.date(day));\n  }\n\n  public withDayOfWeek(dayOfWeek: number): Day {\n    return this.mutate(d => d.day(dayOfWeek));\n  }\n\n  public withDayOfYear(dayOfYear: number): Day {\n    return this.mutate(d => d.dayOfYear(dayOfYear));\n  }\n\n  // Month\n\n  public withMonth(month: number): Day {\n    return this.mutate(d => d.month(month));\n  }\n\n  public relativeMonths(months: number): Day {\n    return this.mutate(d => d.add(months, 'months'));\n  }\n\n  public prevMonth(months: number = 1): Day {\n    return this.relativeMonths( -months );\n  }\n\n  public nextMonth(months: number = 1): Day {\n    return this.relativeMonths( months );\n  }\n\n  // Week Of Year\n\n  public withWeek(week: number, relativeWeek: number = this.week): Day {\n    return this.mutate(d => d.add((week - relativeWeek) * Constants.DAYS_IN_WEEK, 'days'));\n  }\n\n  public withWeekOfYear(week: number): Day {\n    return this.withWeek(week, this.weekOfYear);\n  }\n\n  public withFullWeekOfYear(week: number): Day {\n    return this.withWeek(week, this.fullWeekOfYear);\n  }\n\n  public withWeekspanOfYear(week: number): Day {\n    return this.withWeek(week, this.weekspanOfYear);\n  }\n\n  public withWeekOfMonth(week: number): Day {\n    return this.withWeek(week, this.weekOfMonth);\n  }\n\n  public withWeekspanOfMonth(week: number): Day {\n    return this.withWeek(week, this.weekspanOfMonth);\n  }\n\n  public withFullWeekOfMonth(week: number): Day {\n    return this.withWeek(week, this.fullWeekOfMonth);\n  }\n\n  public relativeWeeks(weeks: number): Day {\n    return this.mutate(d => d.add(weeks, 'weeks'));\n  }\n\n  public prevWeek(weeks: number = 1): Day {\n    return this.relativeWeeks( -weeks );\n  }\n\n  public nextWeek(weeks: number = 1): Day {\n    return this.relativeWeeks( weeks );\n  }\n\n  // Year\n\n  public withYear(year: number): Day {\n    return this.mutate(d => d.year(year));\n  }\n\n  public relativeYears(years: number): Day {\n    return this.mutate(d => d.add(years, 'year'));\n  }\n\n  public prevYear(years: number = 1): Day {\n    return this.relativeYears( -years );\n  }\n\n  public nextYear(years: number = 1): Day {\n    return this.relativeYears( years );\n  }\n\n  // Hour\n\n  public withHour(hour: number): Day {\n    return this.mutate(d => d.hour(hour));\n  }\n\n  public relativeHours(hours: number): Day {\n    return this.mutate(d => d.add(hours, 'hours'));\n  }\n\n  public prevHour(hours: number = 1): Day {\n    return this.relativeHours( -hours );\n  }\n\n  public nextHour(hours: number = 1): Day {\n    return this.relativeHours( hours );\n  }\n\n  // Time\n\n  public withTimes(\n      hour: number = Constants.HOUR_MIN,\n      minute: number = Constants.MINUTE_MIN,\n      second: number = Constants.SECOND_MIN,\n      millisecond: number = Constants.MILLIS_MIN): Day {\n    return this.mutate(d => d.set({hour, minute, second, millisecond}));\n  }\n\n  public withTime(time: Time): Day {\n    return this.withTimes(time.hour, time.minute, time.second, time.millisecond);\n  }\n\n  public asTime(): Time {\n    return new Time(this.hour, this.minute, this.seconds, this.millis);\n  }\n\n  // Start & End\n\n  // Time\n\n  public start(): Day {\n    return this.mutate(d => d.startOf('day'));\n  }\n\n  public isStart(): boolean {\n    return this.hour === Constants.HOUR_MIN &&\n      this.minute === Constants.MINUTE_MIN &&\n      this.seconds === Constants.SECOND_MIN &&\n      this.millis === Constants.MILLIS_MIN;\n  }\n\n  public end(inclusive: boolean = true): Day {\n    return inclusive ?\n      this.mutate(d => d.endOf('day')) :\n      this.mutate(d => d.startOf('day').add(1, 'day'));\n  }\n\n  public isEnd(): boolean {\n    return this.hour === Constants.HOUR_MAX &&\n      this.minute === Constants.MINUTE_MAX &&\n      this.seconds === Constants.SECOND_MAX &&\n      this.millis === Constants.MILLIS_MAX;\n  }\n\n  // Hour\n\n  public startOfHour(): Day {\n    return this.mutate(d => d.startOf('hour'));\n  }\n\n  public isStartOfHour(): boolean {\n    return this.minute === Constants.MINUTE_MIN &&\n      this.seconds === Constants.SECOND_MIN &&\n      this.millis === Constants.MILLIS_MIN;\n  }\n\n  public endOfHour(inclusive: boolean = true): Day {\n    return inclusive ?\n      this.mutate(d => d.endOf('hour')) :\n      this.mutate(d => d.startOf('hour').add(1, 'hour'));\n  }\n\n  public isEndOfHour(): boolean {\n    return this.minute === Constants.MINUTE_MAX &&\n      this.seconds === Constants.SECOND_MAX &&\n      this.millis === Constants.MILLIS_MAX;\n  }\n\n  // Week\n\n  public startOfWeek(): Day {\n    return this.mutate(d => d.startOf('week'));\n  }\n\n  public isStartOfWeek(): boolean {\n    return this.dayOfWeek === Constants.WEEKDAY_MIN;\n  }\n\n  public endOfWeek(inclusive: boolean = true): Day {\n    return inclusive ?\n      this.mutate(d => d.endOf('week')) :\n      this.mutate(d => d.startOf('week').add(1, 'week'));\n  }\n\n  public isEndOfWeek(): boolean {\n    return this.dayOfWeek === Constants.WEEKDAY_MAX;\n  }\n\n  // Month\n\n  public startOfMonth(): Day {\n    return this.mutate(d => d.startOf('month'));\n  }\n\n  public isStartOfMonth(): boolean {\n    return this.dayOfMonth === Constants.DAY_MIN;\n  }\n\n  public endOfMonth(inclusive: boolean = true): Day {\n    return inclusive ?\n      this.mutate(d => d.endOf('month')) :\n      this.mutate(d => d.startOf('month').add(1, 'month'));\n  }\n\n  public isEndOfMonth(): boolean {\n    return this.dayOfMonth === this.daysInMonth();\n  }\n\n  // Year\n\n  public startOfYear(): Day {\n    return this.mutate(d => d.startOf('year'));\n  }\n\n  public isStartOfYear(): boolean {\n    return this.month === Constants.MONTH_MIN && this.dayOfMonth === Constants.DAY_MIN;\n  }\n\n  public endOfYear(inclusive: boolean = true): Day {\n    return inclusive ?\n      this.mutate(d => d.endOf('year')) :\n      this.mutate(d => d.startOf('year').add(1, 'year'));\n  }\n\n  public isEndOfYear(): boolean {\n    return this.month === Constants.MONTH_MAX && this.dayOfMonth === Constants.DAY_MAX;\n  }\n\n  // Days In X\n\n  public daysInMonth(): number {\n    return this.date.daysInMonth();\n  }\n\n  public daysInYear(): number {\n    return this.endOfYear().dayOfYear;\n  }\n\n  public weeksInYear(): number {\n    return this.date.weeksInYear();\n  }\n\n  // Display\n\n  public format(format: string): string {\n    return this.date.format( format );\n  }\n\n  public utc(keepLocalTime?: boolean): Day {\n    return this.mutate(d => d.utc(keepLocalTime));\n  }\n\n  public toMoment(): moment.Moment {\n    return this.date.clone();\n  }\n\n  public toDate(): Date {\n    return this.date.toDate();\n  }\n\n  public toArray(): number[] {\n    return this.date.toArray();\n  }\n\n  public toJSON(): string {\n    return this.date.toJSON();\n  }\n\n  public toISOString(keepOffset: boolean = false): string {\n    return this.date.toISOString( keepOffset );\n  }\n\n  public toObject(): object {\n    return this.date.toObject();\n  }\n\n  public toString(): string {\n    return this.date.toString();\n  }\n\n  // State\n\n  public isDST(): boolean {\n    return this.date.isDST();\n  }\n\n  public isLeapYear(): boolean {\n    return this.date.isLeapYear();\n  }\n\n  // Instances\n\n  public static now(): Day {\n    return new Day(moment());\n  }\n\n  public static today(): Day {\n    return this.now().start();\n  }\n\n  public static tomorrow(): Day {\n    return this.today().next();\n  }\n\n  public static fromMoment(moment: moment.Moment): Day {\n    return moment && moment.isValid() ? new Day( moment ) : null;\n  }\n\n  public static unix(millis: number): Day {\n    return this.fromMoment(moment(millis));\n  }\n\n  public static unixSeconds(millis: number): Day {\n    return this.fromMoment(moment.unix(millis));\n  }\n\n  public static parse(input: DayInput): Day {\n    return Parse.day(input);\n  }\n\n  public static fromString(input: string): Day {\n    return this.fromMoment(moment(input));\n  }\n\n  public static fromFormat(input: string, formats: string | string[]): Day {\n    return this.fromMoment(moment(input, formats));\n  }\n\n  public static fromObject(input: object): Day {\n    return this.fromMoment(moment(input));\n  }\n\n  public static fromDate(input: Date): Day {\n    return this.fromMoment(moment(input));\n  }\n\n  public static fromArray(input: number[]): Day {\n    return this.fromMoment(moment(input));\n  }\n\n  public static fromDayIdentifier(id: number): Day {\n    let date: number = id % 100;\n    let month: number = (Math.floor(id / 100) % 100) - 1;\n    let year: number = Math.floor(id / 10000);\n\n    return this.build(year, month, date);\n  }\n\n  public static build(year: number, month: number,\n    date: number = Constants.DAY_MIN,\n    hour: number = Constants.HOUR_MIN,\n    minute: number = Constants.MINUTE_MIN,\n    second: number = Constants.SECOND_MIN,\n    millisecond: number = Constants.MILLIS_MIN): Day\n  {\n    return new Day( moment({year, month, date, hour, minute, second, millisecond}) );\n  }\n\n\n\n\n\n\n\n\n  public static getWeekspanOfYear(date: moment.Moment): number\n  {\n    return Math.floor( (date.dayOfYear() - 1) / Constants.DAYS_IN_WEEK );\n  }\n\n  public static getLastWeekspanOfYear(date: moment.Moment): number\n  {\n    let lastOfYear = date.clone().endOf('year');\n    let daysInYear: number = lastOfYear.dayOfYear();\n\n    return Math.floor( (daysInYear - date.dayOfYear()) / Constants.DAYS_IN_WEEK );\n  }\n\n  public static getWeekOfYear(date: moment.Moment): number\n  {\n    let firstOfYear = date.clone().startOf('year');\n    let weeks: number = date.week();\n\n    return firstOfYear.day() > Constants.WEEK_OF_MONTH_MINIMUM_WEEKDAY ? weeks - 1 : weeks;\n  }\n\n  public static getFullWeekOfYear(date: moment.Moment): number\n  {\n    let firstOfYear = date.clone().startOf('year');\n    let weeks: number = date.week();\n\n    return firstOfYear.day() === Constants.WEEKDAY_MIN ? weeks : weeks - 1;\n  }\n\n  public static getLastFullWeekOfYear(date: moment.Moment): number\n  {\n    let firstOfYear = date.clone().startOf('year');\n    let weeks: number = date.week();\n    let weeksMax: number = date.weeksInYear();\n    let lastWeek: number = weeksMax - weeks;\n\n    return firstOfYear.day() === Constants.WEEKDAY_MIN ? lastWeek + 1 : lastWeek;\n  }\n\n  public static getWeekspanOfMonth(date: moment.Moment): number\n  {\n    return Math.floor((date.date() - 1) / Constants.DAYS_IN_WEEK);\n  }\n\n  public static getLastWeekspanOfMonth(date: moment.Moment): number\n  {\n    return Math.floor((date.daysInMonth() - date.date()) / Constants.DAYS_IN_WEEK);\n  }\n\n  public static getFullWeekOfMonth(date: moment.Moment): number\n  {\n    return Math.floor((date.date() - 1 - date.day() + Constants.DAYS_IN_WEEK) / Constants.DAYS_IN_WEEK);\n  }\n\n  public static getLastFullWeekOfMonth(date: moment.Moment): number\n  {\n    return Math.floor((date.daysInMonth() - date.date() - (Constants.WEEKDAY_MAX - date.day()) + Constants.DAYS_IN_WEEK) / Constants.DAYS_IN_WEEK);\n  }\n\n  public static getWeekOfMonth(date: moment.Moment): number\n  {\n    let dom = date.date();\n    let dow = date.day();\n    let sundayDate = dom - dow;\n\n    return Math.floor( ( sundayDate + Constants.WEEK_OF_MONTH_MINIMUM_WEEKDAY + 5 ) / Constants.DAYS_IN_WEEK );\n  }\n\n  public static getLastDayOfMonth(date: moment.Moment): number\n  {\n    return date.daysInMonth() - date.date() + 1;\n  }\n\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/Day.ts","\nimport { Op } from './Operation';\nimport { Day } from './Day';\nimport { DaySpan } from './DaySpan';\nimport { CalendarEvent } from './CalendarEvent';\nimport { Iterator } from './Iterator';\n\n\n/**\n * A day in a [[Calendar]] with extra information relative to any selection on\n * the calendar, the current date, or events on the day.\n *\n * @typeparam T The type of data stored in the [[Event]] class.\n * @typeparam M The type of metadata stored in the schedule.\n */\nexport class CalendarDay<T, M> extends Day\n{\n\n  /**\n   * Whether this day is the current day (ex: today).\n   */\n  public currentDay: boolean = false;\n\n  /**\n   * Whether this day is on the same week as the current day (ex: today).\n   */\n  public currentWeek: boolean = false;\n\n  /**\n   * Whether this day is on the same month as the current day (ex: today).\n   */\n  public currentMonth: boolean = false;\n\n  /**\n   * Whether this day is on the same year as the current day (ex: today).\n   */\n  public currentYear: boolean = false;\n\n  /**\n   * How many days away this day is from the current day (ex: today). If this\n   * day is the current day the offset is 0. If this day is before the current\n   * day it will be the negative number of days away. Otherwise this will be\n   * positive meaning this day is after the current day by the given days.\n   */\n  public currentOffset: number = 0;\n\n  /**\n   * Whether this day is part of a selection on the calendar.\n   */\n  public selectedDay: boolean = false;\n\n  /**\n   * Whether this day is on the same week that the calendar selection is.\n   */\n  public selectedWeek: boolean = false;\n\n  /**\n   * Whether this day is on the same month that the calendar selection is.\n   */\n  public selectedMonth: boolean = false;\n\n  /**\n   * Whether this day is on the same year that the calendar selection is.\n   */\n  public selectedYear: boolean = false;\n\n  /**\n   * Whether this day is in the current calendar or not. Some days are outside\n   * the calendar span and used to fill in weeks. Month calendars will fill in\n   * days so the list of days in the calendar start on Sunday and end on Saturday.\n   */\n  public inCalendar: boolean = false;\n\n  /**\n   * The list of events on this day based on the settings and schedules in the\n   * calendar.\n   */\n  public events: CalendarEvent<T, M>[] = [];\n\n\n  /**\n   * Creates an iterator for the events on this day.\n   *\n   * @returns The new iterator for the events on this day.\n   */\n  public iterateEvents(): Iterator<CalendarEvent<T, M>>\n  {\n    return Iterator.forArray( this.events );\n  }\n\n\n  /**\n   * Updates the current flags on this day given the current day (ex: today).\n   *\n   * @param current The current day of the calendar.\n   */\n  public updateCurrent(current: Day): this\n  {\n    this.currentDay = this.sameDay(current);\n    this.currentWeek = this.sameWeek(current);\n    this.currentMonth = this.sameMonth(current);\n    this.currentYear = this.sameYear(current);\n    this.currentOffset = this.daysBetween(current, Op.DOWN, false);\n\n    return this;\n  }\n\n  /**\n   * Updates the selection flags on this day given the selection range on the\n   * calendar.\n   *\n   * @param selected The span of days selected on the calendar.\n   */\n  public updateSelected(selected: DaySpan): this\n  {\n    this.selectedDay = selected.matchesDay(this);\n    this.selectedWeek = selected.matchesWeek(this);\n    this.selectedMonth = selected.matchesMonth(this);\n    this.selectedYear = selected.matchesYear(this);\n\n    return this;\n  }\n\n  /**\n   * Clears the selection flags on this day. This is done when the selection on\n   * the calendar is cleared.\n   */\n  public clearSelected(): this\n  {\n    this.selectedDay = this.selectedWeek = this.selectedMonth = this.selectedYear = false;\n\n    return this;\n  }\n\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/CalendarDay.ts","\nimport { Constants } from './Constants';\nimport { Day } from './Day';\nimport { DaySpan, DaySpanBounds } from './DaySpan';\nimport { Event } from './Event';\nimport { Identifier, IdentifierInput } from './Identifier';\nimport { Schedule } from './Schedule';\n\n\n/**\n * An instance of an [[Event]] on a given day of a [[Calendar]] generated by\n * the event's [[Schedule]].\n *\n * @typeparam T The type of data stored in the [[Event]] class.\n * @typeparam M The type of metadata stored in the schedule and in this class.\n */\nexport class CalendarEvent<T, M>\n{\n\n  /**\n   * The relatively unique identifier of this event. It is generated based on\n   * the index of the schedule in the calendar and the time of day listed in the\n   * schedule. This number will no longer be unique if the schedule has more\n   * than [[Constants.MAX_EVENTS_PER_DAY]] occurrences in a single day\n   * (based on number of times in [[Schedule.times]]).\n   */\n  public id: number;\n\n  /**\n   * The event with the schedule.\n   */\n  public event: Event<T, M>;\n\n  /**\n   * Any metadata specified for this event instance in the schedule.\n   */\n  public meta: M;\n\n  /**\n   * The day this event occurs on.\n   */\n  public day: Day;\n\n  /**\n   * The span of time this event occurs. If this is an all day event this span\n   * will start at the beginning of the day and end at the beginning of the\n   * next day.\n   *\n   * @see [[Schedule.isFullDay]]\n   */\n  public time: DaySpan;\n\n  /**\n   * Whether this event is an all day event.\n   *\n   * @see [[Schedule.isFullDay]]\n   */\n  public fullDay: boolean;\n\n  /**\n   * Whether this event is the first day of an occurrence. A calendar can\n   * generate multiple [[CalendarEvent]] instances over each day it covers if\n   * [[Calendar.repeatCovers]] is true. These instances have matching\n   * [[CalendarEvent.id]] values.\n   */\n  public starting: boolean;\n\n  /**\n   * Whether this event is the last day of an occurrence. A calendar can\n   * generate multiple [[CalendarEvent]] instances over each day it covers if\n   * [[Calendar.repeatCovers]] is true. These instances have matching\n   * [[CalendarEvent.id]] values.\n   */\n  public ending: boolean;\n\n  /**\n   * Whether this event instance was marked as cancelled in the schedule.\n   */\n  public cancelled: boolean;\n\n  /**\n   * The row this event is on in a visual calendar. An event can span multiple\n   * days and it is desirable to have the occurrence on each day to line up.\n   * This is only set when [[Calendar.updateRows]] is true or manually set.\n   * This value makes sense for visual calendars for all day events or when the\n   * visual calendar is not positioning events based on their time span.\n   */\n  public row: number = 0;\n\n  /**\n   * The column this event is on in a visual calendar. An event can have its\n   * time overlap with another event displaying one of the events in another\n   * column. This is only set when [[Calendar.updateColumns]] is true or\n   * manually set. This value makes sense for visual calendars that are\n   * displaying event occurrences at specific times positioned accordingly.\n   */\n  public col: number = 0;\n\n  /**\n   * Define width of event column in visual calendar.\n   * Don't mix it up with day or week column width.\n   */\n  public colWidth: number = 0;\n\n  /**\n   * Creates a new event instance given the id, the event paired with the\n   * schedule, the schedule, the time span of the event, and the day on the\n   * calendar the event belongs to.\n   *\n   * @param id The relatively unique identifier of this event.\n   * @param event The event which created this instance.\n   * @param time The time span of this event.\n   * @param actualDay The day on the calendar this event is for.\n   */\n  public constructor(id: number, event: Event<T, M>, time: DaySpan, actualDay: Day)\n  {\n    this.id = id;\n    this.event = event;\n    this.time = time;\n    this.day = actualDay;\n    this.fullDay = event.schedule.isFullDay();\n    this.meta = event.schedule.getMeta( time.start );\n    this.cancelled = event.schedule.isCancelled( time.start );\n    this.starting = time.isPoint || time.start.sameDay( actualDay );\n    this.ending = time.isPoint || time.end.relative(-1).sameDay( actualDay );\n  }\n\n  /**\n   * The id of the schedule uniqe within the calendar which generated this event.\n   */\n  public get scheduleId(): number\n  {\n    return Math.floor( this.id / Constants.MAX_EVENTS_PER_DAY );\n  }\n\n  /**\n   * The start timestamp of the event.\n   */\n  public get start(): Day\n  {\n    return this.time.start;\n  }\n\n  /**\n   * The end timestamp of the event.\n   */\n  public get end(): Day\n  {\n    return this.time.end;\n  }\n\n  /**\n   * The schedule which generated this event.\n   */\n  public get schedule(): Schedule<M>\n  {\n    return this.event.schedule;\n  }\n\n  /**\n   * The related event data.\n   */\n  public get data(): T\n  {\n    return this.event.data;\n  }\n\n  /**\n   * An [[IdentifierInput]] for the start of this event.\n   */\n  public get identifier(): IdentifierInput\n  {\n    return this.identifierType.get( this.start );\n  }\n\n  /**\n   * The [[Identifier]] for this event. Either [[Identifier.Day]] or\n   * [[Identifier.Time]].\n   */\n  public get identifierType(): Identifier\n  {\n    return this.schedule.identifierType;\n  }\n\n  /**\n   * Returns a delta value between 0 and 1 which represents where the\n   * [[CalendarEvent.start]] is relative to [[CalendarEvent.day]]. The delta\n   * value would be less than 0 if the start of the event is before\n   * [[CalendarEvent.day]].\n   */\n  public get startDelta(): number\n  {\n    return this.time.startDelta( this.day );\n  }\n\n  /**\n   * Returns a delta value between 0 and 1 which represents where the\n   * [[CalendarEvent.end]] is relative to [[CalendarEvent.day]]. The delta value\n   * would be greater than 1 if the end of the event is after\n   * [[CalendarEvent.day]].\n   */\n  public get endDelta(): number\n  {\n    return this.time.endDelta( this.day );\n  }\n\n  /**\n   * Calculates the bounds for this event if it were placed in a rectangle which\n   * represents a day (24 hour period). By default the returned values are\n   * between 0 and 1 and can be scaled by the proper rectangle dimensions or the\n   * rectangle dimensions can be passed to this function.\n   *\n   * @param dayHeight The height of the rectangle of the day.\n   * @param dayWidth The width of the rectangle of the day.\n   * @param columnOffset The offset in the rectangle of the day to adjust this\n   *    event by if it intersects or is contained in a previous event. This also\n   *    reduces the width of the returned bounds to keep the bounds in the\n   *    rectangle of the day.\n   * @param clip `true` if the bounds should stay in the day rectangle, `false`\n   *    and the bounds may go outside the rectangle of the day for multi-day\n   *    events.\n   * @param offsetX How much to translate the left & right properties by.\n   * @param offsetY How much to translate the top & bottom properties by.\n   * @returns The calculated bounds for this event.\n   */\n  public getTimeBounds(dayHeight: number = 1, dayWidth: number = 1, columnOffset: number = 0.1, clip: boolean = true, offsetX: number = 0, offsetY: number = 0): DaySpanBounds\n  {\n    return this.time.getBounds( this.day, dayHeight, dayWidth, this.col, this.colWidth, clip, offsetX, offsetY );\n  }\n\n  /**\n   * Changes the cancellation status of this event. By default this cancels\n   * this event - but `false` may be passed to undo a cancellation.\n   *\n   * @param cancelled Whether the event should be cancelled.\n   */\n  public cancel(cancelled: boolean = true): this\n  {\n    this.schedule.setCancelled( this.start, cancelled );\n    this.cancelled = cancelled;\n\n    return this;\n  }\n\n  /**\n   * Changes the exclusion status of this event. By default this excludes this\n   * event - but `false`  may be passed to undo an exclusion.\n   *\n   * @param excluded Whether the event should be excluded.\n   */\n  public exclude(excluded: boolean = true): this\n  {\n    this.schedule.setExcluded( this.start, excluded );\n\n    return this;\n  }\n\n  /**\n   * Moves this event to potentially another day and time. A move is\n   * accomplished by excluding the current event and adding an inclusion of the\n   * new day & time. Any [[CalendarEvent.meta]] on this event will be moved to\n   * the new event. If the schedule represents a single event\n   * ([[Schedule.isSingleEvent]]) then the schedule frequencies are updated\n   * to match the timestamp provided.\n   *\n   * @param toTime The timestamp to move this event to.\n   * @returns Whether the event was moved to the given time.\n   */\n  public move(toTime: Day): boolean\n  {\n    return this.schedule.move( toTime, this.start );\n  }\n\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/CalendarEvent.ts","import { Functions as fn } from \"./Functions\";\nimport { Day, DayInput } from \"./Day\";\nimport { DaySpan } from \"./DaySpan\";\nimport { Schedule } from \"./Schedule\";\nimport { Event, EventInput } from \"./Event\";\nimport { Op } from \"./Operation\";\nimport { Units } from \"./Units\";\nimport { Parse } from \"./Parse\";\nimport { SortEvent } from \"./Sort\";\nimport { Constants } from \"./Constants\";\nimport { CalendarDay } from \"./CalendarDay\";\nimport { CalendarEvent } from \"./CalendarEvent\";\nimport { Iterator, IteratorAction } from \"./Iterator\";\n\n\n/**\n * A function which moves a given day by some amount and some unit. This is\n * used to shift a calendar's frame via [[Calendar.next]] and [[Calendar.prev]].\n *\n * @param day The day to move.\n * @param amount The amount to move the day by.\n * @returns A new day instance moved by the given amount.\n */\nexport type CalendarMover = (day: Day, amount: number) => Day;\n\n/**\n * A definition for a given [[Units]] which informs a calendar how to setup the\n * [[Calendar.span]] and how to move with [[Calendar.move]].\n */\nexport interface CalendarTypeDefinition {\n  getStart(around: Day, size: number, focus: number): Day;\n\n  getEnd(start: Day, size: number, focus: number): Day;\n\n  moveStart(day: Day, amount: number): Day;\n\n  moveEnd(day: Day, amount: number): Day;\n\n  defaultInput: any\n}\n\n/**\n * A map of [[CalendarTypeDefinition]] keyed by the [[Units]].\n */\nexport type CalendarTypeDefinitionMap = { [unit: number]: CalendarTypeDefinition };\n\n/**\n * Input used to initialize or mass change the properties of a [[Calendar]].\n *\n * @typeparam T The type of data stored in the [[Event]] class.\n * @typeparam M The type of metadata stored in the schedule.\n */\nexport interface CalendarInput<T, M> {\n\n  /**\n   * @see [[Calendar.fill]]\n   */\n  fill?: boolean;\n  /**\n   * @see [[Calendar.minimumSize]]\n   */\n  minimumSize?: number;\n  /**\n   * @see [[Calendar.repeatCovers]]\n   */\n  repeatCovers?: boolean;\n  /**\n   * @see [[Calendar.listTimes]]\n   */\n  listTimes?: boolean;\n  /**\n   * @see [[Calendar.eventsOutside]]\n   */\n  eventsOutside?: boolean;\n  /**\n   * @see [[Calendar.updateRows]]\n   */\n  updateRows?: boolean;\n  /**\n   * @see [[Calendar.updateColumns]]\n   */\n  updateColumns?: boolean;\n  /**\n   * @see [[Calendar.eventSorter]]\n   */\n  eventSorter?: SortEvent<T, M>;\n  /**\n   * @see [[Calendar.events]]\n   */\n  events?: EventInput<T, M>[];\n  /**\n   * @see [[Calendar.type]]\n   */\n  type?: Units;\n  /**\n   * @see [[Calendar.size]]\n   */\n  size?: number; // 1\n  /**\n   * @see [[Calendar.parseMeta]]\n   */\n  parseMeta?: (input: any) => M;\n  /**\n   * @see [[Calendar.parseData]]\n   */\n  parseData?: (input: any) => T;\n  /**\n   * When morphing a calendar to a fewer number of days, do we want to keep\n   * today in the calendar if it is already in the calendar?\n   */\n  preferToday?: boolean; // true\n  /**\n   * What day should the calendar be based around (contain)?\n   */\n  around?: DayInput; // null\n  /**\n   * When morphing a calendar and `preferToday` is false OR today is not in the\n   * calendar AND `around` is not specified, we will pick a day at this number\n   * in the current calendar (a value between 0 and 1 signifying the start and\n   * and of the current calendar).\n   */\n  otherwiseFocus?: number; // 0.499999\n  /**\n   * When morphing or creating passing a value of `true` will avoid calling\n   * [[Calendar.refresh]] as is typically done right after each of those\n   * functions.\n   */\n  delayRefresh?: boolean; // false\n}\n\n/**\n * A collection of [[CalendarDay]]s, the events on the calendar, and all\n * [[CalendarEvent]]s generated based on the events.\n *\n * @typeparam T The type of data stored in the [[Event]] class.\n * @typeparam M The type of metadata stored in the schedule.\n */\nexport class Calendar<T, M> {\n\n  /**\n   * The span of days in the calendar.\n   */\n  public span: DaySpan;\n\n  /**\n   * The full span of days represented on the calendar. This may be different\n   * than the [[Calendar.span]] when [[Calendar.fill]] is `true` and the\n   * calendar is representing months or years and the days need to start on\n   * Sunday and end on Saturday.\n   */\n  public filled: DaySpan;\n\n  /**\n   * The number of days in the calendar specified by [[Calendar.span]].\n   */\n  public length: number;\n\n  /**\n   * The type of calendar.\n   */\n  public type: Units;\n\n  /**\n   * The size of the calendar. When the calendar type is...\n   *\n   * - [[Units.DAY]]: The number of days in the calendar.\n   * - [[Units.WEEK]]: The number of weeks in the calendar.\n   * - [[Units.MONTH]]: The number of months in the calendar.\n   * - [[Units.YEAR]]: The number of years in the calendar.\n   */\n  public size: number;\n\n  /**\n   * The function used to move the start day of the calendar when functions like\n   * [[Calendar.next]] or [[Calendar.prev]] are called.\n   */\n  public moveStart: CalendarMover;\n\n  /**\n   * The function used to move the end day of the calendar when functions like\n   * [[Calendar.next]] or [[Calendar.prev]] are called.\n   */\n  public moveEnd: CalendarMover;\n\n\n  /**\n   * If the calendar should be filled in so the first day of the calendar is\n   * Sunday and the last day is Saturday.\n   */\n  public fill: boolean = false;\n\n  /**\n   * The minimum number of days in the calendar no matter what the type or size\n   * is. This can be used to display a month with a constant number of weeks -\n   * because not all months contain the same number of weeks.\n   */\n  public minimumSize: number = 0;\n\n  /**\n   * When `true` a [[CalendarEvent]] instance exists on each [[CalendarDay]]\n   * the event covers even if the event didn't start on that day.\n   */\n  public repeatCovers: boolean = true;\n\n  /**\n   * When `true` an event instance will be created for each time specified on\n   * the schedule. If the schedule specifies an all day event then only one\n   * event is added to a day. This is typically done when displaying days or\n   * weeks and events can be displayed on a timeline.\n   */\n  public listTimes: boolean = false;\n\n  /**\n   * When `true` events will be added to days \"outside\" the calendar. Days\n   * outside the calendar are days filled in when [[Calendar.fill]] is `true`.\n   * More specifically days that are in [[Calendar.filled]] and not in\n   * [[Calendar.span]].\n   */\n  public eventsOutside: boolean = false;\n\n  /**\n   * When `true` [[CalendarEvent.row]] will be set so when visually displaying\n   * the event with others multi-day events will align and not overlap.\n   */\n  public updateRows: boolean = false;\n\n  /**\n   * When `true` [[CalendarEvent.col]] will be set so when visually displaying\n   * the event based on start and end time any events that overlap with each\n   * other will be \"indented\" to see the event below it.\n   */\n  public updateColumns: boolean = false;\n\n  /**\n   * The function (if any) which sorts the events on a calendar day.\n   */\n  public eventSorter: SortEvent<T, M> = null;\n\n  /**\n   * A function to use when parsing meta input into the desired type.\n   *\n   * @param input The input to parse.\n   * @returns The meta parsed from the given input, if any.\n   */\n  public parseMeta: (input: any) => M = (x => <M>x);\n\n  /**\n   * A function to use when parsing meta input into the desired type.\n   *\n   * @param input The input to parse.\n   * @returns The meta parsed from the given input, if any.\n   */\n  public parseData: (input: any) => T = (x => <T>x);\n\n  /**\n   * A selection of days on the calendar. If no days are selected this is `null`.\n   * This is merely used to keep the selection flags in [[CalendarDay]] updated\n   * via [[Calendar.refreshSelection]].\n   */\n  public selection: DaySpan = null;\n\n  /**\n   * The array of days in this calendar and their events.\n   */\n  public days: CalendarDay<T, M>[] = [];\n\n  /**\n   * The array of scheduled events added to the calendar.\n   */\n  public events: Event<T, M>[] = [];\n\n  /**\n   * The array of visible events on the calendar. This is built based on the\n   * span of the schedule in the given event and also the [[Event.visible]] flag.\n   */\n  public visible: Event<T, M>[] = [];\n\n\n  /**\n   * Creates a new calendar given a span, type, size, moving functions, and\n   * optionally some default properties for the calendar.\n   *\n   * @param start The first day on the calendar.\n   * @param end The last day on the calendar.\n   * @param type The calendar type used for describing the calendar and splitting it.\n   * @param size The number of calendar types in this calendar.\n   * @param moveStart The function to move the start day.\n   * @param moveEnd The function to move the end by.\n   * @param input The default properties for this calendar.\n   * @see [[Calendar.start]]\n   * @see [[Calendar.end]]\n   * @see [[Calendar.type]]\n   * @see [[Calendar.size]]\n   * @see [[Calendar.moveStart]]\n   * @see [[Calendar.moveEnd]]\n   */\n  public constructor(start: Day, end: Day, type: Units, size: number, moveStart: CalendarMover, moveEnd: CalendarMover, input?: CalendarInput<T, M>) {\n    this.span = new DaySpan(start, end);\n    this.filled = new DaySpan(start, end);\n    this.type = type;\n    this.size = size;\n    this.moveStart = moveStart;\n    this.moveEnd = moveEnd;\n\n    if (fn.isDefined(input)) {\n      this.set(input);\n    }\n    else {\n      this.refresh();\n    }\n  }\n\n  /**\n   * Changes the calendar possibly morphing it to a different type or size if\n   * specified in the given input. If the type and size are not morphed then\n   * the following properties may be updated:\n   *\n   * - [[Calendar.fill]]\n   * - [[Calendar.minimumSize]]\n   * - [[Calendar.repeatCovers]]\n   * - [[Calendar.listTimes]]\n   * - [[Calendar.eventsOutside]]\n   * - [[Calendar.updateRows]]\n   * - [[Calendar.updateColumns]]\n   * - [[Calendar.eventSorter]]\n   * - [[Calendar.events]]\n   * - [[Calendar.parseData]]\n   * - [[Calendar.parseMeta]]\n   *\n   * If [[CalendarInput.delayRefresh]] is not given with `true` then\n   * [[Calendar.refresh]] will be called once the calendar properties have been\n   * updated.\n   *\n   * @param input The new properties for this calendar to overwrite with.\n   */\n  public set(input: CalendarInput<T, M>): this {\n    type CTD = CalendarTypeDefinition;\n\n    const typeChange: boolean = fn.isDefined(input.type) && input.type !== this.type;\n    const sizeChange: boolean = fn.isDefined(input.size) && input.size !== this.size;\n\n    if (typeChange || sizeChange) {\n      const focus: number = fn.coalesce(input.otherwiseFocus, 0.4999);\n      const prefer: boolean = fn.coalesce(input.preferToday, true);\n      const size: number = fn.coalesce(input.size, this.size);\n      const type: Units = fn.coalesce(input.type, this.type);\n      let around: DayInput = fn.coalesce(input.around, this.days[Math.floor((this.days.length - 1) * focus)]);\n      const today: Day = Day.today();\n\n      if (!around || (prefer && this.span.matchesDay(today))) {\n        around = today;\n      }\n\n      const meta: CTD = Calendar.TYPES[type];\n      const start: Day = meta.getStart(Day.parse(around), size, focus);\n      const end: Day = meta.getEnd(start, size, focus);\n\n      this.span.start = start;\n      this.span.end = end;\n      this.type = type;\n      this.size = size;\n      this.moveStart = meta.moveStart;\n      this.moveEnd = meta.moveEnd;\n    }\n    else if (input.around) {\n      const focus: number = fn.coalesce(input.otherwiseFocus, 0.4999);\n      const around: Day = Day.parse(input.around);\n      const type: Units = this.type;\n      const size: number = this.size;\n      const meta: CTD = Calendar.TYPES[type];\n      const start: Day = meta.getStart(around, size, focus);\n      const end: Day = meta.getEnd(start, size, focus);\n\n      this.span.start = start;\n      this.span.end = end;\n    }\n\n    this.fill = fn.coalesce(input.fill, this.fill);\n    this.minimumSize = fn.coalesce(input.minimumSize, this.minimumSize);\n    this.repeatCovers = fn.coalesce(input.repeatCovers, this.repeatCovers);\n    this.listTimes = fn.coalesce(input.listTimes, this.listTimes);\n    this.eventsOutside = fn.coalesce(input.eventsOutside, this.eventsOutside);\n    this.updateRows = fn.coalesce(input.updateRows, this.updateRows);\n    this.updateColumns = fn.coalesce(input.updateColumns, this.updateColumns);\n    this.eventSorter = fn.coalesce(input.eventSorter, this.eventSorter);\n    this.parseMeta = fn.coalesce(input.parseMeta, this.parseMeta);\n    this.parseData = fn.coalesce(input.parseData, this.parseData);\n\n    if (fn.isArray(input.events)) {\n      this.setEvents(input.events, true);\n    }\n\n    if (!input.delayRefresh) {\n      this.refresh();\n    }\n\n    return this;\n  }\n\n  /**\n   * Sets the [[Calendar.minimumSize]] value and returns `this` for method\n   * chaining.\n   *\n   * @param minimumSize The new value.\n   */\n  public withMinimumSize(minimumSize: number): this {\n    this.minimumSize = minimumSize;\n    this.refresh();\n\n    return this;\n  }\n\n  /**\n   * Sets the [[Calendar.repeatCovers]] value and returns `this` for method\n   * chaining.\n   *\n   * @param repeatCovers The new value.\n   */\n  public withRepeatCovers(repeatCovers: boolean): this {\n    this.repeatCovers = repeatCovers;\n    this.refreshEvents();\n\n    return this;\n  }\n\n  /**\n   * Sets the [[Calendar.listTimes]] value and returns `this` for method\n   * chaining.\n   *\n   * @param listTimes The new value.\n   */\n  public withListTimes(listTimes: boolean): this {\n    this.listTimes = listTimes;\n    this.refreshEvents();\n\n    return this;\n  }\n\n  /**\n   * Sets the [[Calendar.eventsOutside]] value and returns `this` for method\n   * chaining.\n   *\n   * @param eventsOutside The new value.\n   */\n  public withEventsOutside(eventsOutside: boolean): this {\n    this.eventsOutside = eventsOutside;\n    this.refreshEvents();\n\n    return this;\n  }\n\n  /**\n   * Sets the [[Calendar.updateRows]] value and returns `this` for method\n   * chaining.\n   *\n   * @param updateRows The new value.\n   * @param refresh If the rows should be updated now if `updateRows` is `true`.\n   */\n  public withUpdateRows(updateRows: boolean, refresh: boolean = true): this {\n    this.updateRows = updateRows;\n\n    if (refresh && updateRows) {\n      this.refreshRows();\n    }\n\n    return this;\n  }\n\n  /**\n   * Sets the [[Calendar.updateColumns]] value and returns `this` for method\n   * chaining.\n   *\n   * @param updateColumns The new value.\n   * @param refresh If the columns should be updated now if `updateColumns` is\n   *    `true`.\n   */\n  public withUpdateColumns(updateColumns: boolean, refresh: boolean = true): this {\n    this.updateColumns = updateColumns;\n\n    if (refresh && updateColumns) {\n      this.refreshColumns();\n    }\n\n    return this;\n  }\n\n  /**\n   * Returns the start day of the calendar. If this calendar is filled, this\n   * may not represent the very first day in the calendar.\n   */\n  public get start(): Day {\n    return this.span.start;\n  }\n\n  /**\n   * Returns the end day of the calendar. If this calendar is filled, this\n   * may not represent the very last day in the calendar.\n   */\n  public get end(): Day {\n    return this.span.end;\n  }\n\n  /**\n   * Returns the summary of the span of time this calendar represents.\n   *\n   * @param dayOfWeek [[DaySpan.summary]]\n   * @param short [[DaySpan.summary]]\n   * @param repeat [[DaySpan.summary]]\n   * @param contextual [[DaySpan.summary]]\n   * @param delimiter [[DaySpan.summary]]\n   * @see [[DaySpan.summary]]\n   */\n  public summary(dayOfWeek: boolean = true, short: boolean = false, repeat: boolean = false, contextual: boolean = true, delimiter: string = \" - \"): string {\n    return this.span.summary(this.type, dayOfWeek, short, repeat, contextual, delimiter);\n  }\n\n  /**\n   * Splits up this calendar into an iterable collection of calendars. The\n   * resulting iterator will return `size / by` number of calendars.\n   *\n   * @param by The new size of the resulting calendars. If the the size of the\n   *    current calendar is not divisible by this value the resulting calendars\n   *    may cover more or less than this calendar covers.\n   * @returns An iterator for the calendars produced.\n   */\n  public split(by: number = 1): Iterator<Calendar<T, M>> {\n    return new Iterator<Calendar<T, M>>(iterator => {\n      let start: Day = this.start;\n      let end: Day = this.moveEnd(this.end, by - this.size);\n\n      for (let i = 0; i < this.size; i++) {\n        let calendar = new Calendar(start, end, this.type, by, this.moveStart, this.moveEnd, this);\n\n        if (iterator.act(calendar) === IteratorAction.Stop) {\n          return;\n        }\n\n        start = this.moveStart(start, by);\n        end = this.moveEnd(end, by);\n      }\n    });\n  }\n\n  /**\n   * Refreshes the days and events in this calendar based on the start and end\n   * days, the calendar properties, and its eventss.\n   *\n   * @param today The current day to update the calendar days via\n   *    [[CalendarDay.updateCurrent]].\n   */\n  public refresh(today: Day = Day.today()): this {\n    this.length = this.span.days(Op.UP, true);\n    this.resetDays();\n    this.refreshCurrent(today);\n    this.refreshSelection();\n    this.refreshVisible();\n    this.refreshEvents();\n\n    return this;\n  }\n\n  /**\n   * Updates the [[Calendar.filled]] span based on [[Calendar.start]],\n   * [[Calendar.end]], and [[Calendar.fill]] properties.\n   */\n  public resetFilled(): this {\n    this.filled.start = this.fill ? this.start.startOfWeek() : this.start;\n    this.filled.end = this.fill ? this.end.endOfWeek() : this.end;\n\n    return this;\n  }\n\n  /**\n   * Updates [[Calendar.days]] to match the span of days in the calendar.\n   */\n  public resetDays(): this {\n    this.resetFilled();\n\n    const days: CalendarDay<T, M>[] = this.days;\n    const filled: DaySpan = this.filled;\n    let current: Day = filled.start;\n    const daysBetween: number = filled.days(Op.UP);\n    const total: number = Math.max(this.minimumSize, daysBetween);\n\n    for (let i = 0; i < total; i++) {\n      let day: CalendarDay<T, M> = days[i];\n\n      if (!day || !day.sameDay(current)) {\n        day = new CalendarDay<T, M>(current.date);\n\n        if (i < days.length) {\n          days.splice(i, 1, day);\n        }\n        else {\n          days.push(day);\n        }\n      }\n\n      day.inCalendar = this.span.contains(day);\n\n      current = current.next();\n    }\n\n    if (days.length > total) {\n      days.splice(total, days.length - total);\n    }\n\n    return this;\n  }\n\n  /**\n   * Updates the list of visible schedules.\n   */\n  public refreshVisible(): this {\n    const start: Day = this.filled.start;\n    const end: Day = this.filled.end;\n\n    this.visible = this.events.filter(e => {\n      return e.visible && e.schedule.matchesRange(start, end);\n    });\n\n    return this;\n  }\n\n  /**\n   * Updates the days with the current day via [[CalendarDay.updateCurrent]].\n   *\n   * @param today The new current day.\n   */\n  public refreshCurrent(today: Day = Day.today()): this {\n    this.iterateDays().iterate(d => {\n      d.updateCurrent(today);\n    });\n\n    return this;\n  }\n\n  /**\n   * Updates the selection flags in [[CalendarDay]] based on the\n   * [[Calendar.selection]] property.\n   */\n  public refreshSelection(): this {\n    this.iterateDays().iterate(d => {\n      if (this.selection) {\n        d.updateSelected(this.selection);\n      }\n      else {\n        d.clearSelected();\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Updates the [[CalendarDay.events]] based on the events in this calendar\n   * and the following properties:\n   *\n   * - [[Calendar.eventsForDay]]\n   * - [[Calendar.eventsOutside]]\n   * - [[Calendar.listTimes]]\n   * - [[Calendar.repeatCovers]]\n   * - [[Calendar.updateRows]]\n   * - [[Calendar.updateColumns]]\n   */\n  public refreshEvents(): this {\n    this.iterateDays().iterate(d => {\n      if (d.inCalendar || this.eventsOutside) {\n        d.events = this.eventsForDay(d, this.listTimes, this.repeatCovers);\n      }\n    });\n\n    if (this.updateRows) {\n      this.refreshRows();\n    }\n\n    if (this.updateColumns) {\n      this.refreshColumns();\n    }\n\n    return this;\n  }\n\n  /**\n   * Refreshes the [[CalendarEvent.row]] property as described in the link.\n   */\n  public refreshRows(): this {\n    type EventToRowMap = { [id: number]: number };\n    type UsedMap = { [row: number]: boolean };\n\n    let eventToRow: EventToRowMap = {};\n    const onlyFullDay: boolean = this.listTimes;\n\n    this.iterateDays().iterate(d => {\n      if (d.dayOfWeek === 0) {\n        eventToRow = {};\n      }\n\n      const used: UsedMap = {};\n\n      for (const event of d.events) {\n        if (onlyFullDay && !event.fullDay) {\n          continue;\n        }\n\n        if (event.id in eventToRow) {\n          used[event.row = eventToRow[event.id]] = true;\n        }\n      }\n\n      let rowIndex: number = 0;\n\n      for (const event of d.events) {\n        if ((onlyFullDay && !event.fullDay) || event.id in eventToRow) {\n          continue;\n        }\n\n        while (used[rowIndex]) {\n          rowIndex++;\n        }\n\n        eventToRow[event.id] = event.row = rowIndex;\n\n        rowIndex++;\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Refreshes the [[CalendarEvent.col]] and [[CalendarEvent.colWidth]] property as described in the link.\n   *\n   * Based on https://stackoverflow.com/questions/11311410/visualization-of-calendar-events-algorithm-to-layout-events-with-maximum-width\n   * 1. Think of an unlimited grid with just a left edge.\n   * 2. Each event is one cell wide, and the height and vertical position is fixed based on starting and ending times.\n   * 3. Try to place each event in a column as far left as possible, without it intersecting any earlier event in that column.\n   * 4. Then, when each connected group of events is placed, their actual widths will be 1/n of the maximum number of columns used by the group.\n   * 5. You could also expand the events at the far left and right to use up any remaining space.\n   */\n  public refreshColumns(): this {\n    this.iterateDays().iterate(d => {\n      let columns: CalendarEvent<T, M>[][] = [];\n      let lastEventEnding: number = null;\n\n      const events = d.events;\n\n      events.sort((e1, e2) => {\n        if (e1.time.start.time < e2.time.start.time) return -1;\n        if (e1.time.start.time > e2.time.start.time) return 1;\n        if (e1.time.end.time < e2.time.end.time) return -1;\n        if (e1.time.end.time > e2.time.end.time) return 1;\n\n        return 0;\n      });\n\n      for (const event of events) {\n\n        // Check if a new event group needs to be started\n        if (lastEventEnding !== null && event.time.start.time >= lastEventEnding) {\n          // The latest event is later than any of the event in the\n          // current group. There is no overlap. Output the current\n          // event group and start a new event group.\n          packEvents(columns);\n          columns = []; // This starts new event group.\n          lastEventEnding = null;\n        }\n\n        let placed = false;\n        for (let i = 0; i < columns.length; i++) {\n          const col = columns[i];\n\n          if (!collidesWith(col[col.length - 1], event)) {\n            col.push(event);\n            placed = true;\n            break;\n          }\n        }\n\n        // It was not possible to place the event. Add a new column\n        // for the current event group.\n        if (!placed) {\n          columns.push([event]);\n        }\n\n        // Remember the latest event end time of the current group.\n        // This is later used to determine if a new groups starts.\n        if (lastEventEnding === null || event.time.end.time > lastEventEnding) {\n          lastEventEnding = event.time.end.time;\n        }\n      }\n\n      if (columns.length > 0) {\n        packEvents(columns);\n      }\n    });\n\n    /**\n     * Make the layout for a group of events by set the left offset\n     * and width for each event in the connected group.\n     * Step 4 in the algorithm.\n     */\n    function packEvents(columns: CalendarEvent<T, M>[][]): void {\n      const columnsLength = columns.length;\n\n      columns.forEach((col, colIndex) => {\n        col.forEach(event => {\n          const colSpan = expandEvent(event, colIndex, columns);\n          event.col = colIndex / columnsLength;\n          event.colWidth = colSpan / columnsLength;\n        })\n      })\n    }\n\n    /**\n     * Check if two events collide.\n     */\n    function collidesWith(e1: CalendarEvent<T, M>, e2: CalendarEvent<T, M>): boolean {\n      return e1.time.end.time > e2.time.start.time && e1.time.start.time < e2.time.end.time;\n    }\n\n    /**\n     * Expand events at the far right to use up any remaining space.\n     * Return number how many columns the event can expand into, without\n     * colliding with other events.\n     * Step 5 in the algorithm.\n     */\n    function expandEvent(e1: CalendarEvent<T, M>, colIndex: number, columns: CalendarEvent<T, M>[][]): number {\n      let colSpan = 1;\n\n      for (let i = colIndex + 1; i < columns.length; i++) {\n        const col = columns[i];\n\n        for (let j = 0; j < col.length; j++) {\n          const e2 = col[j];\n\n          if (collidesWith(e1, e2)) {\n            return colSpan;\n          }\n        }\n        colSpan++;\n      }\n\n      return colSpan;\n    }\n\n    return this;\n  }\n\n  /**\n   * Gets the calendar day for the given day.\n   *\n   * @param input The day to get the calendar day for.\n   * @returns The reference to the calendar day, or null if the given input\n   *    is not on this calendar.\n   */\n  public getDay(input: DayInput): CalendarDay<T, M> {\n    const parsed: Day = Day.parse(input);\n\n    if (parsed) {\n      const dayCount: number = parsed.start().daysBetween(this.days[0], Op.DOWN, false);\n\n      return this.days[dayCount];\n    }\n\n    return null;\n  }\n\n  /**\n   * Iterates over all days in this calendar and passes each day to `iterator`.\n   *\n   * @param iterator The function to pass [[CalendarDay]]s to.\n   */\n  public iterateDays(): Iterator<CalendarDay<T, M>> {\n    return new Iterator<CalendarDay<T, M>>(iterator => {\n      const days: CalendarDay<T, M>[] = this.days;\n\n      for (let i = 0; i < days.length; i++) {\n        switch (iterator.act(days[i])) {\n          case IteratorAction.Stop:\n            return;\n        }\n      }\n    });\n  }\n\n  /**\n   * Returns the events for the given day optionally looking at schedule times,\n   * optionally looking at events which cover multiple days, and optionally\n   * sorted with the given function.\n   *\n   * @param day The day to find events for.\n   * @param getTimes When `true` an event is added to the result for each time\n   *    specified in the schedule.\n   * @param covers When `true` events which don't start on the given day but do\n   *    overlap are added to the result.\n   * @param sorter The function to sort the events by, if any.\n   * @returns An array of events that occurred on the given day.\n   */\n  public eventsForDay(day: Day, getTimes: boolean = true, covers: boolean = true, sorter: SortEvent<T, M> = this.eventSorter): CalendarEvent<T, M>[] {\n    const events: CalendarEvent<T, M>[] = [];\n    const entries: Event<T, M>[] = this.visible;\n\n    for (let entryIndex = 0; entryIndex < entries.length; entryIndex++) {\n      const entry: Event<T, M> = entries[entryIndex];\n      const schedule: Schedule<M> = entry.schedule;\n      const eventId: number = entryIndex * Constants.MAX_EVENTS_PER_DAY;\n      let timeIndex: number = 0;\n\n      schedule.iterateSpans(day, covers).iterate((span, iterator) => {\n        events.push(new CalendarEvent(eventId + timeIndex++, entry, span, day));\n\n        if (!getTimes) {\n          iterator.stop();\n        }\n      });\n    }\n\n    if (sorter) {\n      events.sort(sorter);\n    }\n\n    return events;\n  }\n\n  /**\n   * Finds the event given one of the ways to identify the event.\n   *\n   * @param input The value to use to search for an event.\n   * @returns The refrence to the event or null if not found.\n   */\n  public findEvent(id: any): Event<T, M> {\n    for (const event of this.events) {\n      if (event === id || event.schedule === id || event.data === id || event.id === id) {\n        return event;\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Removes the list of events if they exist in the calendar.\n   *\n   * @param events The array of events to remove if they exist. If no\n   *    events are passed (via `null`) then all events will be removed\n   *    from the calendar.\n   * @param delayRefresh When `true` the [[Calendar.refreshEvents]] will not be\n   *    called after the events are removed.\n   * @see [[Calendar.removeEvent]]\n   * @see [[Calendar.refreshEvents]]\n   */\n  public removeEvents(events: any[] = null, delayRefresh: boolean = false): this {\n    if (events) {\n      for (const event of events) {\n        this.removeEvent(event, true);\n      }\n    }\n    else {\n      this.events = [];\n    }\n\n    this.refreshVisible();\n\n    if (!delayRefresh) {\n      this.refreshEvents();\n    }\n\n    return this;\n  }\n\n  /**\n   * Removes the given event if it exists on the calendar.\n   *\n   * @param event The event to remove if it exists.\n   * @param delayRefresh When `true` the [[Calendar.refreshEvents]] will not be\n   *    called after the event is removed.\n   * @see [[Calendar.refreshEvents]]\n   */\n  public removeEvent(event: any, delayRefresh: boolean = false): this {\n    const found: Event<T, M> = this.findEvent(event);\n\n    if (found) {\n      this.events.splice(this.events.indexOf(found), 1);\n\n      this.refreshVisible();\n\n      if (!delayRefresh) {\n        this.refreshEvents();\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * Adds the given event to this calendar if it doesn't exist already (or\n   * `allowDuplicates` is `true`).\n   *\n   * @param event The event to add to the calendar.\n   * @param allowDuplicates If an event can be added more than once.\n   * @param delayRefresh When `true` the [[Calendar.refreshEvents]] will not be\n   *    called after the event is added.\n   * @see [[Calendar.refreshEvents]]\n   */\n  public addEvent(event: EventInput<T, M>, allowDuplicates: boolean = false, delayRefresh: boolean = false): this {\n    const parsed: Event<T, M> = Parse.event<T, M>(event, this.parseData, this.parseMeta);\n\n    if (!allowDuplicates) {\n      const existing = this.findEvent(parsed);\n\n      if (existing) {\n        return this;\n      }\n    }\n\n    this.events.push(parsed);\n\n    this.refreshVisible();\n\n    if (!delayRefresh) {\n      this.refreshEvents();\n    }\n\n    return this;\n  }\n\n  /**\n   * Adds the given events to this calendar if they don't exist already (or\n   * `allowDuplicates` is `true`).\n   *\n   * @param events The events to add to the calendar.\n   * @param allowDuplicates If an event can be added more than once.\n   * @param delayRefresh When `true` the [[Calendar.refreshEvents]] will not be\n   *    called after the events are added.\n   * @see [[Calendar.refreshEvents]]\n   */\n  public addEvents(events: EventInput<T, M>[], allowDuplicates: boolean = false, delayRefresh: boolean = false): this {\n    for (const event of events) {\n      this.addEvent(event, allowDuplicates, true);\n    }\n\n    if (!delayRefresh) {\n      this.refreshEvents();\n    }\n\n    return this;\n  }\n\n  /**\n   * Sets the given events to this calendar replacing the current list of\n   * events.\n   *\n   * @param events The events to set to the calendar.\n   * @param delayRefresh When `true` the [[Calendar.refreshEvents]] will not be\n   *    called after the events are added.\n   * @see [[Calendar.refreshEvents]]\n   */\n  public setEvents(events: EventInput<T, M>[], delayRefresh: boolean = false): this {\n    const parsedEvents = [];\n\n    for (let i = 0; i < events.length; i++) {\n      let parsed: Event<T, M> = Parse.event<T, M>(events[i], this.parseData, this.parseMeta);\n\n      if (parsed) {\n        parsedEvents.push(parsed);\n      }\n    }\n\n    this.events = parsedEvents;\n\n    this.refreshVisible();\n\n    if (!delayRefresh) {\n      this.refreshEvents();\n    }\n\n    return this;\n  }\n\n  /**\n   * Sets the selection point or range of the calendar and updates the flags\n   * in the days.\n   *\n   * @param start The start of the selection.\n   * @param end The end of the selection.\n   * @see [[Calendar.refreshSelection]]\n   */\n  public select(start: Day, end: Day = start): this {\n    this.selection = new DaySpan(start, end);\n    this.refreshSelection();\n\n    return this;\n  }\n\n  /**\n   * Sets the selection of the calendar to nothing.\n   *\n   * @see [[Calendar.refreshSelection]]\n   */\n  public unselect(): this {\n    this.selection = null;\n    this.refreshSelection();\n\n    return this;\n  }\n\n  /**\n   * Shifts the calendar days by the given amount.\n   *\n   * @param jump The amount to shift the calendar by.\n   * @param delayRefresh When `true` [[Calendar.refresh]] will not be called\n   *    after calendar is moved.\n   */\n  public move(jump: number = this.size, delayRefresh: boolean = false): this {\n    this.span.start = this.moveStart(this.start, jump);\n    this.span.end = this.moveEnd(this.end, jump);\n\n    if (!delayRefresh) {\n      this.refresh();\n    }\n\n    return this;\n  }\n\n  /**\n   * Moves the calenndar to the next set of days.\n   *\n   * @param jump The amount to shift the calendar by.\n   * @param delayRefresh When `true` [[Calendar.refresh]] will not be called\n   *    after calendar is moved.\n   */\n  public next(jump: number = this.size, delayRefresh: boolean = false): this {\n    return this.move(jump, delayRefresh);\n  }\n\n  /**\n   * Moves the calenndar to the previous set of days.\n   *\n   * @param jump The amount to shift the calendar by.\n   * @param delayRefresh When `true` [[Calendar.refresh]] will not be called\n   *    after calendar is moved.\n   */\n  public prev(jump: number = this.size, delayRefresh: boolean = false): this {\n    return this.move(-jump, delayRefresh);\n  }\n\n  /**\n   * Converts this calendar to input which can be used to later recreate this\n   * calendar. The only properties of the calendar which will be loss is the\n   * [[Calendar.eventSorter]] property because it is a function.\n   *\n   * @param plain If the returned input should be plain objects as opposed\n   *    to [[Day]] and [[Event]] instances.\n   * @param plainData A function to convert [[Event.data]] to a plain object if\n   *    it is not already.\n   * @param plainMeta A function to convert values in [[Schedule.meta]] to plain\n   *    objects if they are not alreday.\n   * @returns The input generated from this calendar.\n   */\n  public toInput(plain: boolean = false,\n                 plainData: (data: T) => any = d => d,\n                 plainMeta: (meta: M) => any = m => m): CalendarInput<T, M> {\n    const out: CalendarInput<T, M> = {};\n\n    out.type = this.type;\n    out.size = this.size;\n    out.fill = this.fill;\n    out.minimumSize = this.minimumSize;\n    out.repeatCovers = this.repeatCovers;\n    out.listTimes = this.listTimes;\n    out.eventsOutside = this.eventsOutside;\n    out.updateRows = this.updateRows;\n    out.updateColumns = this.updateColumns;\n    out.around = plain ? this.span.start.time : this.span.start;\n    out.events = [];\n\n    for (let event of this.events) {\n      if (plain) {\n        const plainEvent: any = {};\n\n        if (fn.isDefined(event.id)) {\n          plainEvent.id = event.id;\n        }\n\n        if (fn.isDefined(event.data)) {\n          plainEvent.data = plainData(event.data);\n        }\n\n        if (!event.visible) {\n          plainEvent.visible = event.visible;\n        }\n\n        plainEvent.schedule = event.schedule.toInput();\n\n        const meta = plainEvent.schedule.meta;\n\n        if (meta) {\n          for (const identifier in meta) {\n            meta[identifier] = plainMeta(meta[identifier]);\n          }\n        }\n\n        out.events.push(plainEvent);\n      }\n      else {\n        out.events.push(event);\n      }\n    }\n\n    return out;\n  }\n\n  /**\n   * Creates a calendar based on the given input.\n   *\n   * @param input The input which has at least the `type` specified.\n   * @returns A new calendar instance.\n   */\n  public static fromInput<T, M>(input: CalendarInput<T, M>): Calendar<T, M> {\n    let initial: Day = Day.today();\n\n    return new Calendar(initial, initial, null, 1, null, null, input);\n  }\n\n  /**\n   * Creates a calendar based around a given unit optionally focused around a\n   * given day.\n   *\n   * @param type The unit of the calendar.\n   * @param days The number of units in the calendar.\n   * @param around The day to focus the calendar on.\n   * @param focus The value which describes how months are added around the given\n   *    day. The default value will center the calendar around the given day.\n   *    When the value is `0` the given day is the first day in the calendar,\n   *    and when the value is `1` the given day is the last day in the calendar.\n   * @param input The default properties for the calendar.\n   * @returns A new calendar instance.\n   */\n  public static forType<T, M>(type: Units, size: number = 1, around: Day = Day.today(), focus: number = 0.49999, input?: CalendarInput<T, M>): Calendar<T, M> {\n    let meta: CalendarTypeDefinition = this.TYPES[type];\n    let start: Day = meta.getStart(around, size, focus);\n    let end: Day = meta.getEnd(start, size, focus);\n\n    return new Calendar<T, M>(start, end, type, size, meta.moveStart, meta.moveEnd, input || meta.defaultInput);\n  }\n\n\n  /**\n   * Creates a calendar based around days optionally focused around a given day.\n   *\n   * @param days The number of days in the calendar.\n   * @param around The day to focus the calendar on.\n   * @param focus The value which describes how days are added around the given\n   *    day. The default value will center the calendar around the given day.\n   *    When the value is `0` the given day is the first day in the calendar,\n   *    and when the value is `1` the given day is the last day in the calendar.\n   * @param input The default properties for the calendar.\n   * @returns A new calendar instance.\n   * @see [[Calendar.forType]]\n   */\n  public static days<T, M>(days: number = 1, around: Day = Day.today(), focus: number = 0.4999, input?: CalendarInput<T, M>): Calendar<T, M> {\n    return this.forType(Units.DAY, days, around, focus, input);\n  }\n\n  /**\n   * Creates a calendar based around weeks optionally focused around a given day.\n   *\n   * @param days The number of weeks in the calendar.\n   * @param around The day to focus the calendar on.\n   * @param focus The value which describes how weeks are added around the given\n   *    day. The default value will center the calendar around the given day.\n   *    When the value is `0` the given day is the first day in the calendar,\n   *    and when the value is `1` the given day is the last day in the calendar.\n   * @param input The default properties for the calendar.\n   * @returns A new calendar instance.\n   * @see [[Calendar.forType]]\n   */\n  public static weeks<T, M>(weeks: number = 1, around: Day = Day.today(), focus: number = 0.4999, input?: CalendarInput<T, M>): Calendar<T, M> {\n    return this.forType(Units.WEEK, weeks, around, focus, input);\n  }\n\n  /**\n   * Creates a calendar based around months optionally focused around a given day.\n   *\n   * @param days The number of months in the calendar.\n   * @param around The day to focus the calendar on.\n   * @param focus The value which describes how months are added around the given\n   *    day. The default value will center the calendar around the given day.\n   *    When the value is `0` the given day is the first day in the calendar,\n   *    and when the value is `1` the given day is the last day in the calendar.\n   * @param input The default properties for the calendar.\n   * @returns A new calendar instance.\n   * @see [[Calendar.forType]]\n   */\n  public static months<T, M>(months: number = 1, around: Day = Day.today(), focus: number = 0.4999, input?: CalendarInput<T, M>): Calendar<T, M> {\n    return this.forType(Units.MONTH, months, around, focus, input);\n  }\n\n  /**\n   * Creates a calendar based around years optionally focused around a given day.\n   *\n   * @param days The number of years in the calendar.\n   * @param around The day to focus the calendar on.\n   * @param focus The value which describes how years are added around the given\n   *    day. The default value will center the calendar around the given day.\n   *    When the value is `0` the given day is the first day in the calendar,\n   *    and when the value is `1` the given day is the last day in the calendar.\n   * @param input The default properties for the calendar.\n   * @returns A new calendar instance.\n   * @see [[Calendar.forType]]\n   */\n  public static years<T, M>(years: number = 1, around: Day = Day.today(), focus: number = 0.4999, input?: CalendarInput<T, M>): Calendar<T, M> {\n    return this.forType(Units.YEAR, years, around, focus, input);\n  }\n\n  /**\n   * A map of functions and properties by [[Units]] used to create or morph\n   * Calendars.\n   */\n  public static TYPES: CalendarTypeDefinitionMap =\n    {\n      [Units.DAY]:\n        {\n          getStart(around: Day, size: number, focus: number): Day {\n            return around.start().relativeDays(-Math.floor(size * focus));\n          },\n          getEnd(start: Day, size: number, focus: number): Day {\n            return start.relativeDays(size - 1).end();\n          },\n          moveStart(day: Day, amount: number): Day {\n            return day.relativeDays(amount);\n          },\n          moveEnd(day: Day, amount: number): Day {\n            return day.relativeDays(amount);\n          },\n          defaultInput: <any>undefined\n        },\n      [Units.WEEK]:\n        {\n          getStart(around: Day, size: number, focus: number): Day {\n            return around.start().startOfWeek().relativeWeeks(-Math.floor(size * focus));\n          },\n          getEnd(start: Day, size: number, focus: number): Day {\n            return start.relativeWeeks(size - 1).endOfWeek();\n          },\n          moveStart(day: Day, amount: number): Day {\n            return day.relativeWeeks(amount);\n          },\n          moveEnd(day: Day, amount: number): Day {\n            return day.relativeWeeks(amount);\n          },\n          defaultInput: <any>undefined\n        },\n      [Units.MONTH]:\n        {\n          getStart(around: Day, size: number, focus: number): Day {\n            return around.start().startOfMonth().relativeMonths(-Math.floor(size * focus));\n          },\n          getEnd(start: Day, size: number, focus: number): Day {\n            return start.relativeMonths(size - 1).endOfMonth();\n          },\n          moveStart(day: Day, amount: number): Day {\n            return day.relativeMonths(amount);\n          },\n          moveEnd(day: Day, amount: number): Day {\n            return day.startOfMonth().relativeMonths(amount).endOfMonth();\n          },\n          defaultInput: { fill: true }\n        },\n      [Units.YEAR]:\n        {\n          getStart(around: Day, size: number, focus: number): Day {\n            return around.start().startOfYear().relativeYears(-Math.floor(size * focus));\n          },\n          getEnd(start: Day, size: number, focus: number): Day {\n            return start.relativeYears(size - 1).endOfYear();\n          },\n          moveStart(day: Day, amount: number): Day {\n            return day.relativeYears(amount);\n          },\n          moveEnd(day: Day, amount: number): Day {\n            return day.relativeYears(amount);\n          },\n          defaultInput: { fill: true }\n        }\n    };\n\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/Calendar.ts","\n/**\n * The months in a year.\n */\nexport class Month\n{\n\n  public static JANUARY: number = 0;\n  public static FEBRUARY: number = 1;\n  public static MARCH: number = 2;\n  public static APRIL: number = 3;\n  public static MAY: number = 4;\n  public static JUNE: number = 5;\n  public static JULY: number = 6;\n  public static AUGUST: number = 7;\n  public static SEPTEMBER: number = 8;\n  public static OCTOBER: number = 9;\n  public static NOVEMBER: number = 10;\n  public static DECEMBER: number = 11;\n\n  /**\n   * The full list of months in a year.\n   */\n  public static LIST: number[] = [\n    Month.JANUARY,\n    Month.FEBRUARY,\n    Month.MARCH,\n    Month.APRIL,\n    Month.MAY,\n    Month.JUNE,\n    Month.JULY,\n    Month.AUGUST,\n    Month.SEPTEMBER,\n    Month.OCTOBER,\n    Month.NOVEMBER,\n    Month.DECEMBER\n  ];\n\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/Month.ts","\n\n/**\n * The days in a week.\n */\nexport class Weekday\n{\n\n  public static SUNDAY: number = 0;\n  public static MONDAY: number = 1;\n  public static TUESDAY: number = 2;\n  public static WEDNESDAY: number = 3;\n  public static THURSDAY: number = 4;\n  public static FRIDAY: number = 5;\n  public static SATURDAY: number = 6;\n\n  /**\n   * The full list of days in a week.\n   */\n  public static LIST: number[] = [\n    Weekday.SUNDAY,\n    Weekday.MONDAY,\n    Weekday.TUESDAY,\n    Weekday.WEDNESDAY,\n    Weekday.THURSDAY,\n    Weekday.FRIDAY,\n    Weekday.SATURDAY\n  ];\n\n  /**\n   * The list of days starting with Monday and ending on Friday.\n   */\n  public static WEEK: number[] = [\n    Weekday.MONDAY,\n    Weekday.TUESDAY,\n    Weekday.WEDNESDAY,\n    Weekday.THURSDAY,\n    Weekday.FRIDAY\n  ];\n\n  /**\n   * The days on the weekend, starting with Saturday and ending with Sunday.\n   */\n  public static ENDS: number[] = [\n    Weekday.SATURDAY,\n    Weekday.SUNDAY\n  ];\n\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/Weekday.ts","\nimport { CalendarEvent } from './CalendarEvent';\nimport { Event } from './Event';\n\n\n/**\n * A function which takes two [[CalendarEvent]]s and returns a number which\n * instructs a sort which event goes before the other in a list.\n *\n * @param a The first event.\n * @param b The second event.\n * @returns When both events are considered equal `0` is returned, when the\n *    first event should go before the second event a negative number is\n *    returned, when the second event should go before the first event a\n *    positive number is returned.\n */\nexport type SortEvent<T, M> = (a: CalendarEvent<T, M>, b: CalendarEvent<T, M>) => number;\n\n/**\n * A class with [[SortEvent]] functions and functions which accept other\n * [[SortEvent]]s and return a new [[SortEvent]].\n *\n * ```typescript\n * // Sorts full day events first, then events in descending order based on start time.\n * Sorts.List([Sorts.FullDay, Sorts.Desc(Sorts.Start)]);\n * ```\n */\nexport class Sorts\n{\n\n  /**\n   * Sorts the two events by their start time - the earliest event being first\n   * in order.\n   *\n   * @param a The first event.\n   * @param b The second event.\n   * @returns The difference in time between the start of `a` and `b`.\n   * @see [[CalendarEvent.time]]\n   */\n  public static Start<T, M>(a: CalendarEvent<T, M>, b: CalendarEvent<T, M>): number\n  {\n    return a.time.start.time - b.time.start.time;\n  }\n\n  /**\n   * Sorts the two events by their end time - the earliest to end being first\n   * in order.\n   *\n   * @param a The first event.\n   * @param b The second event.\n   * @returns The difference in time between the end of `a` and `b`.\n   * @see [[CalendarEvent.time]]\n   */\n  public static End<T, M>(a: CalendarEvent<T, M>, b: CalendarEvent<T, M>): number\n  {\n    return a.time.end.time - b.time.end.time;\n  }\n\n  /**\n   * Sorts the two events placing the full day events before the timed events.\n   *\n   * @param a The first event.\n   * @param b The second event.\n   * @returns If both are timed or both are full day then `0` is returned,\n   *    otherwise `-1` is returned if `a` is full day and `1` is returned if\n   *    `b` is full day.\n   * @see [[CalendarEvent.fullDay]]\n   */\n  public static FullDay<T, M>(a: CalendarEvent<T, M>, b: CalendarEvent<T, M>): number\n  {\n    let af: number = a.fullDay ? 0 : 1;\n    let bf: number = b.fullDay ? 0 : 1;\n\n    return af - bf;\n  }\n\n  /**\n   * Sorts the two events placing the shorter events before the longer events.\n   * Full day or multiple day events actually take up a day and will be ordered\n   * last.\n   *\n   * @param a The first event.\n   * @param b The second event.\n   * @returns The difference in milliseconds between `a` and `b`.\n   * @see [[CalendarEvent.time]]\n   * @see [[DaySpan.millis]]\n   */\n  public static Duration<T, M>(a: CalendarEvent<T, M>, b: CalendarEvent<T, M>): number\n  {\n    return a.time.millis() - b.time.millis();\n  }\n\n  /**\n   * Returns a [[SortEvent]] that effectively orders the given sorter in the\n   * opposite (often descending) order.\n   *\n   * @param sorter The sorter to reverse.\n   * @returns A new sorter which reverses the one passed in.\n   */\n  public static Desc<T, M>(sorter: SortEvent<T, M>): SortEvent<T, M>\n  {\n    return (a, b) =>\n    {\n      return sorter( b, a );\n    };\n  }\n\n  /**\n   * Returns a [[SortEvent]] that orders the events based on a string in each\n   * event. A function must be supplied which takes an event of type `T` and\n   * returns a string.\n   *\n   * @param getString A function which returns a string from the event.\n   * @returns A sorter which sorts strings alphabetically.\n   */\n  public static Alphabetical<T, M>(getString: (event: Event<T, M>) => string): SortEvent<T, M>\n  {\n    return (a, b) =>\n    {\n      let as: string = getString( a.event ) || '';\n      let bs: string = getString( b.event ) || '';\n\n      return as.localeCompare( bs );\n    };\n  }\n\n  /**\n   * Returns a [[SortEvent]] that orders events based on a number in each event.\n   * A function must be supplied which takes an event of type `T` and returns\n   * a number.\n   *\n   * @param getOrder A function which returns a number from the event.\n   * @returns A sorter which sorts events based on a number in ascending order.\n   */\n  public static Ordered<T, M>(getOrder: (event: Event<T, M>) => number): SortEvent<T, M>\n  {\n    return (a, b) =>\n    {\n      let ao: number = getOrder( a.event );\n      let bo: number = getOrder( b.event );\n\n      return ao - bo;\n    };\n  }\n\n  /**\n   * Returns a [[SortEvent]] that orders events based on an array of sorters.\n   * The first sorter which returns a non-zero result is used.\n   *\n   * @param sorters A list of sorting functions to test one at a time.\n   * @returns A sorter which sorts based on a list of sorters.\n   */\n  public static List<T, M>(sorters: SortEvent<T, M>[]): SortEvent<T, M>\n  {\n    return (a, b) =>\n    {\n      for (let sorter of sorters)\n      {\n        let compare: number = sorter(a, b);\n\n        if (compare !== 0)\n        {\n          return compare;\n        }\n      }\n\n      return 0;\n    };\n  }\n\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/Sort.ts"],"sourceRoot":""}